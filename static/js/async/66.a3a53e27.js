"use strict";(self.webpackChunknote=self.webpackChunknote||[]).push([["66"],{7510:function(n,e,t){t.r(e),t.d(e,{default:()=>i});var s=t(5893),o=t(65);function r(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",code:"code",h2:"h2",h3:"h3",pre:"pre",h4:"h4"},(0,o.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"渲染器",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#渲染器",children:"#"}),"渲染器"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"渲染器"}),"的作用是将",(0,s.jsxs)(e.strong,{children:["虚拟",(0,s.jsx)(e.code,{children:"DOM"}),(0,s.jsx)(e.strong,{children:"渲染为特定平台上的"}),"真实元素"]}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["虚拟",(0,s.jsx)(e.code,{children:"DOM"}),"与真实",(0,s.jsx)(e.code,{children:"DOM"}),"的结构一样，是由一个个虚拟节点",(0,s.jsx)(e.code,{children:"VNode"}),"组成的树形结构。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"渲染器"}),"把虚拟",(0,s.jsx)(e.code,{children:"DOM"}),"节点渲染为真实",(0,s.jsx)(e.code,{children:"DOM"}),"节点的过程叫作",(0,s.jsx)(e.strong,{children:"挂载"}),"。"]}),"\n",(0,s.jsxs)(e.h2,{id:"vnode",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#vnode",children:"#"}),"VNode"]}),"\n",(0,s.jsxs)(e.h3,{id:"vnode的类型",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#vnode的类型",children:"#"}),"VNode的类型"]}),"\n",(0,s.jsxs)(e.p,{children:["常规的",(0,s.jsx)(e.code,{children:"VNode"}),"包括",(0,s.jsx)(e.code,{children:"Text"}),"、",(0,s.jsx)(e.code,{children:"Comment"}),"、",(0,s.jsx)(e.code,{children:"Static"}),"、",(0,s.jsx)(e.code,{children:"Fragment"}),"这几种类型。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"// 所有VNode类型\nexport type VNodeTypes =\n  | string\n  | VNode\n  | Component\n  | typeof Text\n  | typeof Static\n  | typeof Comment\n  | typeof Fragment\n  | typeof TeleportImpl\n  | typeof SuspenseImpl\n\nexport const Text = Symbol(__DEV__ ? 'Text' : undefined)  // 纯文本\nexport const Comment = Symbol(__DEV__ ? 'Comment' : undefined) // 注释类\nexport const Static = Symbol(__DEV__ ? 'Static' : undefined) // 静态html\nexport const Fragment = (Symbol(__DEV__ ? 'Fragment' : undefined) as any) as {\n  __isFragment: true\n  new (): {\n    $props: VNodeProps\n  }\n}  // fragment html片段，根节点是多个节点\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"VNode"}),"的内容："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"const vnode: VNode = {\n  __v_isVNode: true,\n  [ReactiveFlags.SKIP]: true,\n  type,\n  props,\n  key: props && normalizeKey(props),\n  ref: props && normalizeRef(props),\n  scopeId: currentScopeId,\n  children: null,\n  component: null,\n  suspense: null,\n  ssContent: null,\n  ssFallback: null,\n  dirs: null,\n  transition: null,\n  el: null,\n  anchor: null,\n  target: null,\n  targetAnchor: null,\n  staticCount: 0,\n  shapeFlag,  // 用于\n  patchFlag,\n  dynamicProps,\n  dynamicChildren: null,\n  appContext: null\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"createVNode"}),"位于",(0,s.jsx)(e.code,{children:"@vue/runtime-core/vnode.ts"}),"，在生产环境调用了第317行的",(0,s.jsx)(e.code,{children:"_createVNode"}),"，其代码如下："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:'function _createVNode(\n  type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT,\n  props: (Data & VNodeProps) | null = null,\n  children: unknown = null,\n  patchFlag: number = 0,\n  dynamicProps: string[] | null = null,\n  isBlockNode = false\n): VNode {\n  if (!type || type === NULL_DYNAMIC_COMPONENT) {\n    type = Comment\n  }\n\n  if (isVNode(type)) {\n    // createVNode receiving an existing vnode. This happens in cases like\n    // <component :is="vnode"/>\n    // #2078 make sure to merge refs during the clone instead of overwriting it\n    const cloned = cloneVNode(type, props, true /* mergeRef: true */)\n    if (children) {\n      normalizeChildren(cloned, children)\n    }\n    return cloned\n  }\n\n  // class component normalization.\n  if (isClassComponent(type)) {\n    type = type.__vccOpts\n  }\n\n  // class & style normalization.\n  if (props) {\n    // for reactive or proxy objects, we need to clone it to enable mutation.\n    if (isProxy(props) || InternalObjectKey in props) {\n      props = extend({}, props)\n    }\n    let { class: klass, style } = props\n    if (klass && !isString(klass)) {\n      props.class = normalizeClass(klass)\n    }\n    if (isObject(style)) {\n      // reactive state objects need to be cloned since they are likely to be\n      // mutated\n      if (isProxy(style) && !isArray(style)) {\n        style = extend({}, style)\n      }\n      props.style = normalizeStyle(style)\n    }\n  }\n\n  // encode the vnode type information into a bitmap\n  const shapeFlag = isString(type)\n    ? ShapeFlags.ELEMENT\n    : __FEATURE_SUSPENSE__ && isSuspense(type)\n      ? ShapeFlags.SUSPENSE\n      : isTeleport(type)\n        ? ShapeFlags.TELEPORT\n        : isObject(type)\n          ? ShapeFlags.STATEFUL_COMPONENT\n          : isFunction(type)\n            ? ShapeFlags.FUNCTIONAL_COMPONENT\n            : 0\n\n  const vnode: VNode = {\n    // ... 省略VNode内容\n  }\n\n  normalizeChildren(vnode, children)\n\n  // normalize suspense children\n  if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {\n    const { content, fallback } = normalizeSuspenseChildren(vnode)\n    vnode.ssContent = content\n    vnode.ssFallback = fallback\n  }\n\n  if (\n    shouldTrack > 0 &&\n    // avoid a block node from tracking itself\n    !isBlockNode &&\n    // has current parent block\n    currentBlock &&\n    // presence of a patch flag indicates this node needs patching on updates.\n    // component nodes also should always be patched, because even if the\n    // component doesn\'t need to update, it needs to persist the instance on to\n    // the next vnode so that it can be properly unmounted later.\n    (patchFlag > 0 || shapeFlag & ShapeFlags.COMPONENT) &&\n    // the EVENTS flag is only for hydration and if it is the only flag, the\n    // vnode should not be considered dynamic due to handler caching.\n    patchFlag !== PatchFlags.HYDRATE_EVENTS\n  ) {\n    currentBlock.push(vnode)\n  }\n\n  return vnode\n}\n'})}),"\n",(0,s.jsxs)(e.h2,{id:"渲染器的基本结构",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#渲染器的基本结构",children:"#"}),"渲染器的基本结构"]}),"\n",(0,s.jsxs)(e.p,{children:["在",(0,s.jsx)(e.code,{children:"Vue3"}),"中渲染器被抽象成了一个对象，其",(0,s.jsx)(e.code,{children:"TypeScript"}),"类型定义位于",(0,s.jsx)(e.code,{children:"@vue/runtime-core/renderer.ts"}),"中："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"export interface Renderer<HostElement = RendererElement> {\n  render: RootRenderFunction<HostElement>\n  createApp: CreateAppFunction<HostElement>\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["主要就是一个拥有",(0,s.jsx)(e.code,{children:"render"}),"和",(0,s.jsx)(e.code,{children:"createApp"}),"方法的对象。"]}),"\n",(0,s.jsxs)(e.p,{children:["在",(0,s.jsx)(e.code,{children:"Vue3"}),"中可以通过",(0,s.jsx)(e.code,{children:"createRenderer"}),"自定义渲染器，浏览器平台的",(0,s.jsx)(e.code,{children:"DOM"}),"渲染器就是自定义渲染器的一个实现。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"export function createRenderer<\n  HostNode = RendererNode,\n  HostElement = RendererElement\n>(options: RendererOptions<HostNode, HostElement>) {\n  return baseCreateRenderer<HostNode, HostElement>(options)\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"createRenderer"}),"函数将自定义渲染器的依赖抽象成了",(0,s.jsx)(e.code,{children:"RendererOptions"}),"，其",(0,s.jsx)(e.code,{children:"TypeScript"}),"类型定义如下："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"export interface RendererOptions<\n  HostNode = RendererNode,\n  HostElement = RendererElement\n> {\n  patchProp(\n    el: HostElement,\n    key: string,\n    prevValue: any,\n    nextValue: any,\n    isSVG?: boolean,\n    prevChildren?: VNode<HostNode, HostElement>[],\n    parentComponent?: ComponentInternalInstance | null,\n    parentSuspense?: SuspenseBoundary | null,\n    unmountChildren?: UnmountChildrenFn\n  ): void\n  insert(el: HostNode, parent: HostElement, anchor?: HostNode | null): void\n  remove(el: HostNode): void\n  createElement(\n    type: string,\n    isSVG?: boolean,\n    isCustomizedBuiltIn?: string,\n    vnodeProps?: (VNodeProps & { [key: string]: any }) | null\n  ): HostElement\n  createText(text: string): HostNode\n  createComment(text: string): HostNode\n  setText(node: HostNode, text: string): void\n  setElementText(node: HostElement, text: string): void\n  parentNode(node: HostNode): HostElement | null\n  nextSibling(node: HostNode): HostNode | null\n  querySelector?(selector: string): HostElement | null\n  setScopeId?(el: HostElement, id: string): void\n  cloneNode?(node: HostNode): HostNode\n  insertStaticContent?(\n    content: string,\n    parent: HostElement,\n    anchor: HostNode | null,\n    isSVG: boolean,\n    start?: HostNode | null,\n    end?: HostNode | null\n  ): [HostNode, HostNode]\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"mount",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#mount",children:"#"}),"mount"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"app"}),"的",(0,s.jsx)(e.code,{children:"mount"}),"方法中的",(0,s.jsx)(e.code,{children:"render"}),"由",(0,s.jsx)(e.code,{children:"createAppAPI"}),"作为参数传入，来源于",(0,s.jsx)(e.code,{children:"@vue/runtime-core/renderer.ts"}),"中的",(0,s.jsx)(e.code,{children:"baseCreateRenderer"}),"方法定义："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const render: RootRenderFunction = (vnode, container) => {\n  if (vnode == null) {\n    if (container._vnode) {\n      unmount(container._vnode, null, null, true)\n    }\n  } else {\n    patch(container._vnode || null, vnode, container)\n  }\n  flushPostFlushCbs()  // TODO 待解析\n  container._vnode = vnode\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"render"}),"方法主要有两个逻辑分支，如果",(0,s.jsx)(e.code,{children:"vnode"}),"不为",(0,s.jsx)(e.code,{children:"null"}),"时，为新建或者更新逻辑，调用",(0,s.jsx)(e.code,{children:"patch"}),"方法；如果",(0,s.jsx)(e.code,{children:"vnode"}),"为",(0,s.jsx)(e.code,{children:"null"}),"，，并且",(0,s.jsx)(e.code,{children:"container._vnode"}),"不为",(0,s.jsx)(e.code,{children:"null"}),"，即",(0,s.jsx)(e.code,{children:"vnode"}),"从有值变为",(0,s.jsx)(e.code,{children:"null"}),"，调用",(0,s.jsx)(e.code,{children:"unmount"}),"方法。"]}),"\n",(0,s.jsxs)(e.h3,{id:"patch",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#patch",children:"#"}),"patch"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"patch"}),"函数是整个渲染器的核心入口，承载了最重要的渲染逻辑"]}),"\n",(0,s.jsxs)(e.h4,{id:"patch的类型",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#patch的类型",children:"#"}),"patch的类型"]}),"\n",(0,s.jsx)(e.p,{children:"不同类型的元素或组件，有不同的patch策略"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"export const enum PatchFlags {\n  // 表明元素具有动态文本\n  TEXT = 1,\n  // 表明元素具有动态class绑定\n  CLASS = 1 << 1, // 2\n  // 表明元素具有动态样式style，编译器会将静态对象字符串编译为静态对象，并做变量提升优化\n  // 例如：\n  // style=\"color: red\" 或 :style=\"{ color: 'red' }\"\n  // 将被编译为：\n  // const style = { color: 'red' }\n  // render() { return e('div', { style }) }\n  STYLE = 1 << 2, // 4\n  // 表明元素或者组件具有class/style以外的动态属性props\n  // Can also be on a component that has any dynamic props (includes\n  // class/style). when this flag is present, the vnode also has a dynamicProps\n  // array that contains the keys of the props that may change so the runtime\n  // can diff them faster (without having to worry about removed props)\n  PROPS = 1 << 3, // 8\n  // Indicates an element with props with dynamic keys. When keys change, a full\n  // diff is always needed to remove the old key. This flag is mutually\n  // exclusive with CLASS, STYLE and PROPS.\n  FULL_PROPS = 1 << 4,\n\n  // Indicates an element with event listeners (which need to be attached\n  // during hydration)\n  HYDRATE_EVENTS = 1 << 5,\n\n  // Indicates a fragment whose children order doesn't change.\n  STABLE_FRAGMENT = 1 << 6,\n\n  // Indicates a fragment with keyed or partially keyed children\n  KEYED_FRAGMENT = 1 << 7,\n\n  // Indicates a fragment with unkeyed children.\n  UNKEYED_FRAGMENT = 1 << 8,\n\n  // Indicates an element that only needs non-props patching, e.g. ref or\n  // directives (onVnodeXXX hooks). since every patched vnode checks for refs\n  // and onVnodeXXX hooks, it simply marks the vnode so that a parent block\n  // will track it.\n  NEED_PATCH = 1 << 9,\n\n  // Indicates a component with dynamic slots (e.g. slot that references a v-for\n  // iterated value, or dynamic slot names).\n  // Components with this flag are always force updated.\n  DYNAMIC_SLOTS = 1 << 10,\n\n  // SPECIAL FLAGS -------------------------------------------------------------\n\n  // Special flags are negative integers. They are never matched against using\n  // bitwise operators (bitwise matching should only happen in branches where\n  // patchFlag > 0), and are mutually exclusive. When checking for a special\n  // flag, simply check patchFlag === FLAG.\n\n  // Indicates a hoisted static vnode. This is a hint for hydration to skip\n  // the entire sub tree since static content never needs to be updated.\n  HOISTED = -1,\n\n  // A special flag that indicates that the diffing algorithm should bail out\n  // of optimized mode. For example, on block fragments created by renderSlot()\n  // when encountering non-compiler generated slots (i.e. manually written\n  // render functions, which should always be fully diffed)\n  // OR manually cloneVNodes\n  BAIL = -2\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"patch"}),"方法位于同文件的452行："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"const patch: PatchFn = (\n  n1, // prev vnode \n  n2, // current vnode \n  container,\n  anchor = null,\n  parentComponent = null,\n  parentSuspense = null,\n  isSVG = false,\n  optimized = false\n) => {\n  // patching & not same type, unmount old tree\n  if (n1 && !isSameVNodeType(n1, n2)) {\n    anchor = getNextHostNode(n1)\n    unmount(n1, parentComponent, parentSuspense, true)\n    n1 = null\n  }\n\n  if (n2.patchFlag === PatchFlags.BAIL) {\n    optimized = false\n    n2.dynamicChildren = null\n  }\n\n  const { type, ref, shapeFlag } = n2\n  switch (type) {\n    case Text:\n      processText(n1, n2, container, anchor) // 纯文本\n      break\n    case Comment:\n      processCommentNode(n1, n2, container, anchor)\n      break\n    case Static:\n      if (n1 == null) {\n        mountStaticNode(n2, container, anchor, isSVG)\n      } else if (__DEV__) {\n        patchStaticNode(n1, n2, container, isSVG)\n      }\n      break\n    case Fragment:\n      processFragment(\n        n1,\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        optimized\n      )\n      break\n    default:\n      if (shapeFlag & ShapeFlags.ELEMENT) { // VNode 是普通标签\n        processElement(\n          n1,\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          optimized\n        )\n      } else if (shapeFlag & ShapeFlags.COMPONENT) { // VNode 是组件\n        processComponent(\n          n1,\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          optimized\n        )\n      } else if (shapeFlag & ShapeFlags.TELEPORT) {   \n        ;(type as typeof TeleportImpl).process(\n          n1 as TeleportVNode,\n          n2 as TeleportVNode,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          optimized,\n          internals\n        )\n      } else if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {\n        ;(type as typeof SuspenseImpl).process(\n          n1,\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          optimized,\n          internals\n        )\n      }\n  }\n\n  // set ref\n  if (ref != null && parentComponent) {\n    setRef(ref, n1 && n1.ref, parentComponent, parentSuspense, n2)\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"patch"}),"方法经过",(0,s.jsx)(e.code,{children:"swtich"}),"语句调用了",(0,s.jsx)(e.code,{children:"processComponent"}),"方法，其代码位于同文件的第1201行："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"const processComponent = (\n  n1: VNode | null,\n  n2: VNode,\n  container: RendererElement,\n  anchor: RendererNode | null,\n  parentComponent: ComponentInternalInstance | null,\n  parentSuspense: SuspenseBoundary | null,\n  isSVG: boolean,\n  optimized: boolean\n) => {\n  if (n1 == null) {\n    if (n2.shapeFlag & ShapeFlags.COMPONENT_KEPT_ALIVE) {\n      (parentComponent!.ctx as KeepAliveContext).activate(\n        n2,\n        container,\n        anchor,\n        isSVG,\n        optimized\n      )\n    } else {\n      mountComponent(\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        optimized\n      )\n    }\n  } else {\n    updateComponent(n1, n2, optimized)\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["其主要有两个逻辑分支：旧的",(0,s.jsx)(e.code,{children:"VNode``n1"}),"不为",(0,s.jsx)(e.code,{children:"null"}),"时，调用更新组件的",(0,s.jsx)(e.code,{children:"updateComponent"}),"方法；当",(0,s.jsx)(e.code,{children:"n1"}),"为",(0,s.jsx)(e.code,{children:"null"}),"时，又有两个子分支：新的",(0,s.jsx)(e.code,{children:"VNode``n1"}),"为",(0,s.jsx)(e.code,{children:"keep-alive"}),"的组件时，调用其",(0,s.jsx)(e.code,{children:"ctx"}),"的",(0,s.jsx)(e.code,{children:"activate"}),"方法，否则调用挂载组件的",(0,s.jsx)(e.code,{children:"mountComponent"}),"方法。"]}),"\n",(0,s.jsxs)(e.p,{children:["我们先看挂载组件的",(0,s.jsx)(e.code,{children:"mountComponent"}),"方法，其位于",(0,s.jsx)(e.code,{children:"processComponent"}),"的下方："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"const mountComponent: MountComponentFn = (\n  initialVNode, // 初始的VNode\n  container,  // 挂载的容器\n  anchor,\n  parentComponent,\n  parentSuspense,\n  isSVG,\n  optimized\n) => {\n  const instance: ComponentInternalInstance = (initialVNode.component = createComponentInstance(\n    initialVNode,\n    parentComponent,\n    parentSuspense\n  ))\n\n  // inject renderer internals for keepAlive\n  if (isKeepAlive(initialVNode)) {\n    (instance.ctx as KeepAliveContext).renderer = internals\n  }\n\n  setupComponent(instance)\n\n  // setup() is async. This component relies on async logic to be resolved\n  // before proceeding\n  if (__FEATURE_SUSPENSE__ && instance.asyncDep) {\n    parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect)\n\n    // Give it a placeholder if this is not hydration\n    // TODO handle self-defined fallback\n    if (!initialVNode.el) {\n      const placeholder = (instance.subTree = createVNode(Comment))\n      processCommentNode(null, placeholder, container!, anchor)\n    }\n    return\n  }\n\n  setupRenderEffect(\n    instance,\n    initialVNode,\n    container,\n    anchor,\n    parentSuspense,\n    isSVG,\n    optimized\n  )\n}\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"create",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#create",children:"#"}),"create"]}),"\n",(0,s.jsxs)(e.p,{children:["首先调用",(0,s.jsx)(e.code,{children:"createComponentInstance"}),"方法生成组件的实例，先看下组件实例的构成："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"const instance: ComponentInternalInstance = {\n  uid: uid++,\n  vnode,\n  type,\n  parent,\n  appContext,\n  root: null!, // to be immediately set\n  next: null,\n  subTree: null!, // will be set synchronously right after creation\n  update: null!, // will be set synchronously right after creation\n  render: null,\n  proxy: null,\n  exposed: null,\n  withProxy: null,\n  effects: null,\n  provides: parent ? parent.provides : Object.create(appContext.provides),\n  accessCache: null!,\n  renderCache: [],\n\n  // local resovled assets\n  components: null,\n  directives: null,\n\n  // resolved props and emits options\n  propsOptions: normalizePropsOptions(type, appContext),\n  emitsOptions: normalizeEmitsOptions(type, appContext),\n\n  // emit\n  emit: null as any, // to be set immediately\n  emitted: null,\n\n  // state\n  ctx: EMPTY_OBJ,\n  data: EMPTY_OBJ,\n  props: EMPTY_OBJ,\n  attrs: EMPTY_OBJ,\n  slots: EMPTY_OBJ,\n  refs: EMPTY_OBJ,\n  setupState: EMPTY_OBJ,\n  setupContext: null,\n\n  // suspense related\n  suspense,\n  suspenseId: suspense ? suspense.pendingId : 0,\n  asyncDep: null,\n  asyncResolved: false,\n\n  // lifecycle hooks\n  // not using enums here because it results in computed properties\n  isMounted: false,\n  isUnmounted: false,\n  isDeactivated: false,\n  bc: null,\n  c: null,\n  bm: null,\n  m: null,\n  bu: null,\n  u: null,\n  um: null,\n  bum: null,\n  da: null,\n  a: null,\n  rtg: null,\n  rtc: null,\n  ec: null\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"createComponentInstance"}),"方法的代码位于",(0,s.jsx)(e.code,{children:"@vue/runtime-core/component.ts"}),"的第401行："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"export function createComponentInstance(\n  vnode: VNode,\n  parent: ComponentInternalInstance | null,\n  suspense: SuspenseBoundary | null\n) {\n  const type = vnode.type as ConcreteComponent\n  // inherit parent app context - or - if root, adopt from root vnode\n  const appContext =\n    (parent ? parent.appContext : vnode.appContext) || emptyAppContext\n\n  const instance: ComponentInternalInstance = {\n    // 省略componentInstance内容\n  }\n\n  if (__DEV__) { // TODO\n    instance.ctx = createRenderContext(instance)\n  } else {\n    instance.ctx = { _: instance }\n  }\n\n  instance.root = parent ? parent.root : instance\n  instance.emit = emit.bind(null, instance)\n\n  return instance\n}\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"setup",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#setup",children:"#"}),"setup"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"setup"}),"主要包括",(0,s.jsx)(e.code,{children:"setupComponent"}),"和",(0,s.jsx)(e.code,{children:"setupRenderEffect"}),"两个过程。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"setupComponent"}),"方法代码位于",(0,s.jsx)(e.code,{children:"@vue/runtime-core/component.ts"}),"的第516行："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"export let isInSSRComponentSetup = false // 表明组件是否服务端渲染的变量\n\nexport function setupComponent(\n  instance: ComponentInternalInstance,\n  isSSR = false\n) {\n  isInSSRComponentSetup = isSSR\n\n  const { props, children, shapeFlag } = instance.vnode\n  const isStateful = shapeFlag & ShapeFlags.STATEFUL_COMPONENT\n  initProps(instance, props, isStateful, isSSR)\n  initSlots(instance, children)\n\n  const setupResult = isStateful\n    ? setupStatefulComponent(instance, isSSR)\n    : undefined\n  isInSSRComponentSetup = false\n  return setupResult\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["内部主要做了初始化属性",(0,s.jsx)(e.code,{children:"initProps"}),"和初始化插槽",(0,s.jsx)(e.code,{children:"initSlots"}),"这两件事儿，并且带状态",(0,s.jsx)(e.code,{children:"isStateful"}),"的组件，会执行",(0,s.jsx)(e.code,{children:"setupStatefulComponent"}),"方法获取",(0,s.jsx)(e.code,{children:"setupResult"}),"。最后将标识组件是否在",(0,s.jsx)(e.code,{children:"SSR"}),"环境下执行",(0,s.jsx)(e.code,{children:"setup"}),"的标识置为",(0,s.jsx)(e.code,{children:"false"}),"，并返回",(0,s.jsx)(e.code,{children:"setupResult"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"initProps"}),"方法位于",(0,s.jsx)(e.code,{children:"@vue/runtime-core/componentProps.ts"}),"的第114行："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"export function initProps(\n  instance: ComponentInternalInstance,\n  rawProps: Data | null,\n  isStateful: number, // result of bitwise flag comparison\n  isSSR = false\n) {\n  const props: Data = {}\n  const attrs: Data = {}\n  def(attrs, InternalObjectKey, 1)\n  setFullProps(instance, rawProps, props, attrs)\n  // validation\n  if (__DEV__) {\n    validateProps(props, instance)\n  }\n\n  if (isStateful) {\n    // stateful\n    instance.props = isSSR ? props : shallowReactive(props)\n  } else {\n    if (!instance.type.props) {\n      // functional w/ optional props, props === attrs\n      instance.props = attrs\n    } else {\n      // functional w/ declared props\n      instance.props = props\n    }\n  }\n  instance.attrs = attrs\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"setFullProps"}),"位于同文件："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"function setFullProps(\n  instance: ComponentInternalInstance,\n  rawProps: Data | null,\n  props: Data,\n  attrs: Data\n) {\n  const [options, needCastKeys] = instance.propsOptions\n  if (rawProps) {\n    for (const key in rawProps) {\n      const value = rawProps[key]\n      // key, ref are reserved and never passed down\n      if (isReservedProp(key)) {\n        continue\n      }\n      // prop option names are camelized during normalization, so to support\n      // kebab -> camel conversion here we need to camelize the key.\n      let camelKey\n      if (options && hasOwn(options, (camelKey = camelize(key)))) {\n        props[camelKey] = value\n      } else if (!isEmitListener(instance.emitsOptions, key)) {\n        // Any non-declared (either as a prop or an emitted event) props are put\n        // into a separate `attrs` object for spreading. Make sure to preserve\n        // original key casing\n        attrs[key] = value\n      }\n    }\n  }\n\n  if (needCastKeys) {\n    const rawCurrentProps = toRaw(props)\n    for (let i = 0; i < needCastKeys.length; i++) {\n      const key = needCastKeys[i]\n      props[key] = resolvePropValue(\n        options!,\n        rawCurrentProps,\n        key,\n        rawCurrentProps[key],\n        instance\n      )\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"shallowReactive"}),"为",(0,s.jsx)(e.code,{children:"Vue3"}),"暴露的响应式核心",(0,s.jsx)(e.code,{children:"API"}),"之一，用于创建一个不会深度嵌套的响应式",(0,s.jsx)(e.code,{children:"proxy"}),"。调用了",(0,s.jsx)(e.code,{children:"Reactivity"}),"部分的核心代码",(0,s.jsx)(e.code,{children:"createReactiveObject"}),"，通过",(0,s.jsx)(e.code,{children:"new Proxy"}),"的方式来响应",(0,s.jsx)(e.code,{children:"data"}),"的变化。"]}),"\n",(0,s.jsxs)(e.h3,{id:"update",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#update",children:"#"}),"update"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"setupRenderEffect"}),"主要设置了实例的",(0,s.jsx)(e.code,{children:"update"}),"方法，此处调用了",(0,s.jsx)(e.code,{children:"reactivity"}),"中的",(0,s.jsx)(e.code,{children:"effect"}),"方法，在定义之后会立即执行，出发",(0,s.jsx)(e.code,{children:"DOM"}),"渲染："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const setupRenderEffect: SetupRenderEffectFn = (\n  instance,\n  initialVNode,\n  container,\n  anchor,\n  parentSuspense,\n  isSVG,\n  optimized\n) => {\n  // create reactive effect for rendering\n  instance.update = effect(function componentEffect() {\n    if (!instance.isMounted) {\n      let vnodeHook: VNodeHook | null | undefined\n      const { el, props } = initialVNode\n      const { bm, m, parent } = instance\n\n      // beforeMount hook\n      if (bm) {\n        invokeArrayFns(bm)\n      }\n      // onVnodeBeforeMount\n      if ((vnodeHook = props && props.onVnodeBeforeMount)) {\n        invokeVNodeHook(vnodeHook, parent, initialVNode)\n      }\n\n      \n      const subTree = (instance.subTree = renderComponentRoot(instance))\n      if (__DEV__) {\n        endMeasure(instance, `render`)\n      }\n\n      if (el && hydrateNode) {\n        if (__DEV__) {\n          startMeasure(instance, `hydrate`)\n        }\n        // vnode has adopted host node - perform hydration instead of mount.\n        hydrateNode(\n          initialVNode.el as Node,\n          subTree,\n          instance,\n          parentSuspense\n        )\n        if (__DEV__) {\n          endMeasure(instance, `hydrate`)\n        }\n      } else {\n        if (__DEV__) {\n          startMeasure(instance, `patch`)\n        }\n        patch(\n          null,\n          subTree,\n          container,\n          anchor,\n          instance,\n          parentSuspense,\n          isSVG\n        )\n        if (__DEV__) {\n          endMeasure(instance, `patch`)\n        }\n        initialVNode.el = subTree.el\n      }\n      // mounted hook\n      if (m) {\n        queuePostRenderEffect(m, parentSuspense)\n      }\n      // onVnodeMounted\n      if ((vnodeHook = props && props.onVnodeMounted)) {\n        queuePostRenderEffect(() => {\n          invokeVNodeHook(vnodeHook!, parent, initialVNode)\n        }, parentSuspense)\n      }\n      // activated hook for keep-alive roots.\n      // #1742 activated hook must be accessed after first render\n      // since the hook may be injected by a child keep-alive\n      const { a } = instance\n      if (\n        a &&\n        initialVNode.shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE\n      ) {\n        queuePostRenderEffect(a, parentSuspense)\n      }\n      instance.isMounted = true\n    } else {\n      // updateComponent\n      // This is triggered by mutation of component's own state (next: null)\n      // OR parent calling processComponent (next: VNode)\n      let { next, bu, u, parent, vnode } = instance\n      let originNext = next\n      let vnodeHook: VNodeHook | null | undefined\n      if (__DEV__) {\n        pushWarningContext(next || instance.vnode)\n      }\n\n      if (next) {\n        updateComponentPreRender(instance, next, optimized)\n      } else {\n        next = vnode\n      }\n      next.el = vnode.el\n\n      // beforeUpdate hook\n      if (bu) {\n        invokeArrayFns(bu)\n      }\n      // onVnodeBeforeUpdate\n      if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {\n        invokeVNodeHook(vnodeHook, parent, next, vnode)\n      }\n\n      \n      const nextTree = renderComponentRoot(instance)\n      if (__DEV__) {\n        endMeasure(instance, `render`)\n      }\n      const prevTree = instance.subTree\n      instance.subTree = nextTree\n\n      // reset refs\n      // only needed if previous patch had refs\n      if (instance.refs !== EMPTY_OBJ) {\n        instance.refs = {}\n      }\n      if (__DEV__) {\n        startMeasure(instance, `patch`)\n      }\n      patch(\n        prevTree,\n        nextTree,\n        // parent may have changed if it's in a teleport\n        hostParentNode(prevTree.el!)!,\n        // anchor may have changed if it's in a fragment\n        getNextHostNode(prevTree),\n        instance,\n        parentSuspense,\n        isSVG\n      )\n      \n      next.el = nextTree.el\n      if (originNext === null) {\n        // self-triggered update. In case of HOC, update parent component\n        // vnode el. HOC is indicated by parent instance's subTree pointing\n        // to child component's vnode\n        updateHOCHostEl(instance, nextTree.el)\n      }\n      // updated hook\n      if (u) {\n        queuePostRenderEffect(u, parentSuspense)\n      }\n      // onVnodeUpdated\n      if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {\n        queuePostRenderEffect(() => {\n          invokeVNodeHook(vnodeHook!, parent, next!, vnode)\n        }, parentSuspense)\n      }\n    }\n  }, prodEffectOptions)\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"diff算法",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#diff算法",children:"#"}),(0,s.jsx)(e.code,{children:"Diff"}),"算法"]})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,o.ah)(),n.components);return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(r,n)})):r(n)}let i=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["framework%2Fvue3%2Frender.md"]={toc:[{id:"vnode",text:"VNode",depth:2},{id:"vnode的类型",text:"VNode的类型",depth:3},{id:"渲染器的基本结构",text:"渲染器的基本结构",depth:2},{id:"mount",text:"mount",depth:2},{id:"patch",text:"patch",depth:3},{id:"patch的类型",text:"patch的类型",depth:4},{id:"create",text:"create",depth:3},{id:"setup",text:"setup",depth:3},{id:"update",text:"update",depth:3},{id:"diff算法",text:"`Diff`算法",depth:2}],title:"渲染器",headingTitle:"渲染器",frontmatter:{}}}}]);