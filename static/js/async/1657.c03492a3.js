"use strict";(self.webpackChunknote=self.webpackChunknote||[]).push([["1657"],{7635:function(e,n,d){d.r(n),d.d(n,{default:()=>t});var r=d(5893),s=d(65);function c(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",h3:"h3",p:"p",code:"code",img:"img",strong:"strong",ul:"ul",li:"li",pre:"pre",ol:"ol"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"vue",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vue",children:"#"}),"Vue"]}),"\n",(0,r.jsxs)(n.h2,{id:"父组件和子组件生命周期钩子执行顺序",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#父组件和子组件生命周期钩子执行顺序",children:"#"}),"父组件和子组件生命周期钩子执行顺序"]}),"\n",(0,r.jsxs)(n.h3,{id:"渲染过程",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#渲染过程",children:"#"}),"渲染过程"]}),"\n",(0,r.jsxs)(n.p,{children:["先创建父组件，然后创建子组件，也就是说父组件的",(0,r.jsx)(n.code,{children:"created"}),"在子组件",(0,r.jsx)(n.code,{children:"created"}),"之前。"]}),"\n",(0,r.jsxs)(n.p,{children:["父组件在子组件之后挂载，故父组件的",(0,r.jsx)(n.code,{children:"mounted"}),"在子组件",(0,r.jsx)(n.code,{children:"mouted"}),"之后。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"http://img.lianteam.cn/blog/vue_com.png",alt:"Vue父子组件渲染过程"})}),"\n",(0,r.jsx)(n.p,{children:"整体渲染过程如下："}),"\n",(0,r.jsxs)(n.p,{children:["父",(0,r.jsx)(n.code,{children:"beforeCreate"})," -> 父",(0,r.jsx)(n.code,{children:"created"})," -> 父",(0,r.jsx)(n.code,{children:"beforeMount"})," -> 子",(0,r.jsx)(n.code,{children:"beforeCreate"})," -> 子",(0,r.jsx)(n.code,{children:"created"})," -> 子",(0,r.jsx)(n.code,{children:"beforeMount"})," -> 子",(0,r.jsx)(n.code,{children:"mounted"})," -> 父",(0,r.jsx)(n.code,{children:"mounted"})]}),"\n",(0,r.jsxs)(n.h3,{id:"更新过程",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更新过程",children:"#"}),"更新过程"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"子组件更新过程"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["影响到父组件: 父",(0,r.jsx)(n.code,{children:"beforeUpdate"})," -> 子",(0,r.jsx)(n.code,{children:"beforeUpdate"})," -> 子",(0,r.jsx)(n.code,{children:"updated"})," -> 父",(0,r.jsx)(n.code,{children:"updted"})]}),"\n",(0,r.jsxs)(n.li,{children:["不影响父组件: 子",(0,r.jsx)(n.code,{children:"beforeUpdate"})," -> 子",(0,r.jsx)(n.code,{children:"updated"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"父组件更新过程"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["影响到子组件: 父",(0,r.jsx)(n.code,{children:"beforeUpdate"})," -> 子",(0,r.jsx)(n.code,{children:"beforeUpdate"})," -> 子",(0,r.jsx)(n.code,{children:"updated"})," -> 父",(0,r.jsx)(n.code,{children:"updted"})]}),"\n",(0,r.jsxs)(n.li,{children:["不影响子组件: 父",(0,r.jsx)(n.code,{children:"beforeUpdate"})," -> 父",(0,r.jsx)(n.code,{children:"updated"})]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"销毁过程",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#销毁过程",children:"#"}),"销毁过程"]}),"\n",(0,r.jsx)(n.p,{children:"与渲染类似的："}),"\n",(0,r.jsxs)(n.p,{children:["父",(0,r.jsx)(n.code,{children:"beforeDestroy"})," -> 子",(0,r.jsx)(n.code,{children:"beforeDestroy"})," -> 子",(0,r.jsx)(n.code,{children:"destroyed"})," -> 父",(0,r.jsx)(n.code,{children:"destroyed"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["综上，可以看出，",(0,r.jsx)(n.code,{children:"Vue"}),"父子组件生命周期钩子的执行顺序遵循：从外到内，然后再从内到外的规律。"]})}),"\n",(0,r.jsxs)(n.h2,{id:"vuex",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vuex",children:"#"}),"Vuex"]}),"\n",(0,r.jsxs)(n.h3,{id:"install",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#install",children:"#"}),"install"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Vuex"}),"的",(0,r.jsx)(n.code,{children:"install"}),"通过",(0,r.jsx)(n.code,{children:"beforeCreacte"}),"钩子中增加处理逻辑，保证了所有组件实例的",(0,r.jsx)(n.code,{children:"$store"}),"都是同一份",(0,r.jsx)(n.code,{children:"Store"}),"实例："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function vuexInit () {\n    const options = this.$options\n    // 注入$store\n    if (options.store) { // 存在store表明为根节点，为根节点设置$store\n        this.$store = typeof options.store === 'function'\n            ? options.store()\n            : options.store\n    } else if (options.parent && options.parent.$store) { // 子节点取父节点的$store\n        this.$store = options.parent.$store\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"数据响应化",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#数据响应化",children:"#"}),"数据响应化"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Vuex"}),"通过",(0,r.jsx)(n.code,{children:"new Vue()"}),"的方式实现",(0,r.jsx)(n.code,{children:"state"}),"和",(0,r.jsx)(n.code,{children:"computed"}),"的响应化，具体通过",(0,r.jsx)(n.code,{children:"resetStoreVM"}),"方法："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function resetStoreVM (store, state, hot) {\n  /* 存放之前的vm对象 */\n  const oldVm = store._vm \n\n  // 通过Object.defineProperty为每一个getter方法设置get代理方法，将getter的属性代理到store._vm上，通过访问其计算属性的方式实现get\n  store.getters = {}\n  const wrappedGetters = store._wrappedGetters\n  const computed = {}\n\n  forEachValue(wrappedGetters, (fn, key) => {\n    computed[key] = () => fn(store)\n    Object.defineProperty(store.getters, key, {\n      get: () => store._vm[key],\n      enumerable: true // for local getters\n    })\n  })\n\n  // Vue.config.silent暂时设置为true的目的是在new一个Vue实例的过程中不会报出一切警告\n  const silent = Vue.config.silent\n\n  Vue.config.silent = true\n\n  /*  这里new了一个Vue对象，运用Vue内部的响应式实现注册state以及computed*/\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed\n  })\n  Vue.config.silent = silent\n\n  // enable strict mode for new vm\n  /* 使能严格模式，保证修改store只能通过mutation */\n  if (store.strict) {\n    enableStrictMode(store)\n  }\n\n  if (oldVm) {\n    /* 解除旧vm的state的引用，以及销毁旧的Vue对象 */\n    if (hot) {\n      store._withCommit(() => {\n        oldVm._data.$$state = null\n      })\n    }\n    Vue.nextTick(() => oldVm.$destroy())\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"严格模式",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#严格模式",children:"#"}),"严格模式"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Vuex"}),"严格模式下，所有修改state的操作必须通过mutation实现，否则会抛出错误。这是通过",(0,r.jsx)(n.code,{children:"watch state"}),"实现的："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function enableStrictMode (store) {\n  store._vm.$watch(function () { return this._data.$$state }, () => {\n    if (process.env.NODE_ENV !== 'production') {\n      /* 检测store中的_committing的值，如果是true代表不是通过mutation的方法修改的 */\n      assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`)\n    }\n  }, { deep: true, sync: true })\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"objectdefineproperty有哪些缺点",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#objectdefineproperty有哪些缺点",children:"#"}),(0,r.jsx)(n.code,{children:"Object.defineProperty"}),"有哪些缺点"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Object.defineProperty"}),"只能劫持对象的属性，而",(0,r.jsx)(n.code,{children:"Proxy "}),"是直接代理对象。由于",(0,r.jsx)(n.code,{children:"Object.defineProperty"})," 只能对属性进行劫持，需要遍历对象的每个属性。而",(0,r.jsx)(n.code,{children:"Proxy"})," 可以直接代理对象。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Object.defineProperty"}),"对新增属性需要手动进行 ",(0,r.jsx)(n.code,{children:"Observe"}),"。由于",(0,r.jsx)(n.code,{children:"Object.defineProperty"})," 劫持的是对象的属性，所以新增属性时，需要重新遍历对象，对其新增属性再使用",(0,r.jsx)(n.code,{children:"Object.defineProperty"}),"进行劫持。 也正是因为这个原因，使用",(0,r.jsx)(n.code,{children:"Vue"}),"给",(0,r.jsx)(n.code,{children:"data"})," 中的数组或对象新增属性时，需要使用",(0,r.jsx)(n.code,{children:"vm.$set"})," 才能保证新增的属性也是响应式的。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Proxy"}),"支持13种拦截操作，这是",(0,r.jsx)(n.code,{children:"defineProperty"}),"所不具有的。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Proxy"}),"作为新标准，长远来看，JS引擎会继续优化",(0,r.jsx)(n.code,{children:"Proxy"})," ，但",(0,r.jsx)(n.code,{children:"getter"}),"和",(0,r.jsx)(n.code,{children:"setter"}),"基本不会再有针对性优化。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Proxy"}),"兼容性差目,前并没有一个完整支持",(0,r.jsx)(n.code,{children:"Proxy"}),"所有拦截方法的",(0,r.jsx)(n.code,{children:"Polyfill"}),"方案"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"vue3新特性",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vue3新特性",children:"#"}),(0,r.jsx)(n.code,{children:"Vue3"}),"新特性"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["基于",(0,r.jsx)(n.code,{children:"Proxy"}),"实现数据变动的监听"]}),"\n",(0,r.jsxs)(n.li,{children:["使用",(0,r.jsx)(n.code,{children:"TypeScript"}),"开发"]}),"\n",(0,r.jsxs)(n.li,{children:["组合式",(0,r.jsx)(n.code,{children:"API"}),"(",(0,r.jsx)(n.code,{children:"Composition API"}),")"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"composition-api",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#composition-api",children:"#"}),(0,r.jsx)(n.code,{children:"Composition API"})]}),"\n",(0,r.jsx)(n.p,{children:"是较低级别的数据驱动视图和组件生命周期API，能够实现一种更自由形式的编写组件逻辑的方式。可以像编写函数一样自由地表达，编写和重用有状态组件逻辑"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Composition API"}),"完全可以和现有的",(0,r.jsx)(n.code,{children:"Options API"}),"配合使用"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Composition API"}),"会在",(0,r.jsx)(n.code,{children:"Options API"}),"之前解析，并且不能提前访问这些选项中定义的 ",(0,r.jsx)(n.code,{children:"property"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"setup()"}),"函数返回的",(0,r.jsx)(n.code,{children:"property"}),"将会被暴露给 ",(0,r.jsx)(n.code,{children:"this"}),"，在 ",(0,r.jsx)(n.code,{children:"Options API"}),"中可以访问到"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"ref",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ref",children:"#"}),(0,r.jsx)(n.code,{children:"Ref"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Ref"}),"是为了以变量形式传递响应式的值而引入的“新”概念。基本类型值需要以",(0,r.jsx)(n.code,{children:"Ref"}),"的形式引用"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { ref, onMounted, onUnmounted } from 'vue'\n\nexport function useMousePosition() {\n  const x = ref(0)\n  const y = ref(0)\n\n  function update(e) {\n    x.value = e.pageX\n    y.value = e.pageY\n  }\n\n  onMounted(() => {\n    window.addEventListener('mousemove', update)\n  })\n\n  onUnmounted(() => {\n    window.removeEventListener('mousemove', update)\n  })\n\n  return { x, y }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Reactive"}),"的应用类型解构赋值时候，会失去可响应性，需要用",(0,r.jsx)(n.code,{children:"toRefs"}),"API"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function useMousePosition() {\n  const pos = reactive({\n    x: 0,\n    y: 0,\n  })\n\n  // ...\n  return toRefs(pos)\n}\n\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"与react-hooks相比",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#与react-hooks相比",children:"#"}),"与",(0,r.jsx)(n.code,{children:"React Hooks"}),"相比"]}),"\n",(0,r.jsxs)(n.p,{children:["基于函数的",(0,r.jsx)(n.code,{children:"Composition API"}),"提供了与",(0,r.jsx)(n.code,{children:"React Hooks"})," 同等级别的逻辑组合能力。但其",(0,r.jsx)(n.code,{children:"setup()"}),"函数只会被调用一次，因此有一下优点："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["一般来说更符合惯用的",(0,r.jsx)(n.code,{children:"JavaScript"}),"代码的直觉"]}),"\n",(0,r.jsx)(n.li,{children:"不需要顾虑调用顺序，可以用在条件语句中"}),"\n",(0,r.jsx)(n.li,{children:"不会在每次渲染时重复执行，可以以降低垃圾回收的压力"}),"\n",(0,r.jsxs)(n.li,{children:["不存在内联处理函数导致子组件永远更新的问题，不需要 ",(0,r.jsx)(n.code,{children:"useCallback"})]}),"\n",(0,r.jsxs)(n.li,{children:["不存在忘记记录依赖的问题，也不需要",(0,r.jsx)(n.code,{children:"useEffect"}),"和",(0,r.jsx)(n.code,{children:"useMemo"}),"并传入依赖数组以捕获过时的变量。",(0,r.jsx)(n.code,{children:"Vue"}),"的自动依赖跟踪可以确保侦听器和计算值总是准确无误"]}),"\n"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,Object.assign({},e,{children:(0,r.jsx)(c,e)})):c(e)}let t=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["framework%2Fvue3%2Fvue.md"]={toc:[{id:"父组件和子组件生命周期钩子执行顺序",text:"父组件和子组件生命周期钩子执行顺序",depth:2},{id:"渲染过程",text:"渲染过程",depth:3},{id:"更新过程",text:"更新过程",depth:3},{id:"销毁过程",text:"销毁过程",depth:3},{id:"vuex",text:"Vuex",depth:2},{id:"install",text:"install",depth:3},{id:"数据响应化",text:"数据响应化",depth:3},{id:"严格模式",text:"严格模式",depth:3},{id:"objectdefineproperty有哪些缺点",text:"`Object.defineProperty`有哪些缺点",depth:2},{id:"vue3新特性",text:"`Vue3`新特性",depth:2},{id:"composition-api",text:"`Composition API`",depth:3},{id:"ref",text:"`Ref`",depth:3},{id:"与react-hooks相比",text:"与`React Hooks`相比",depth:3}],title:"Vue",headingTitle:"Vue",frontmatter:{}}}}]);