"use strict";(self.webpackChunknote=self.webpackChunknote||[]).push([["9899"],{2165:function(e,n,d){d.r(n),d.d(n,{default:()=>h});var c=d(5893),r=d(65);function s(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",ul:"ul",li:"li",strong:"strong",h2:"h2",h3:"h3",blockquote:"blockquote"},(0,r.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"http缓存",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#http缓存",children:"#"}),"HTTP缓存"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Web"}),"缓存通过复用以前获取的资源，减少等待时间和网络流量，减少了显示资源表示形式所需的时间，可以显著提高网站和应用程序的性能。通过使用",(0,c.jsx)(n.code,{children:"HTTP"}),"缓存，可以使网站的响应更加敏捷。"]}),"\n",(0,c.jsx)(n.p,{children:"但是，缓存也需要合理配置，因为并不是所有资源都是永久不变的。重要的是，对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。"}),"\n",(0,c.jsx)(n.p,{children:"缓存可分为私有与共享缓存两类："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"共享缓存"}),"存储的响应能够被多个用户使用，例如网关缓存、",(0,c.jsx)(n.code,{children:"CDN"}),"、反向代理缓存和负载均衡器等。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"私有缓存"}),"只能用于单个用户，例如浏览器缓存(",(0,c.jsx)(n.code,{children:"Brower Caching"}),")。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsxs)(n.strong,{children:[(0,c.jsx)(n.code,{children:"HTTP"}),"缓存只应该缓存",(0,c.jsx)(n.code,{children:"GET"}),"请求，因为其是幂等的。"]})}),"\n",(0,c.jsxs)(n.h2,{id:"缓存规则",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#缓存规则",children:"#"}),"缓存规则"]}),"\n",(0,c.jsxs)(n.p,{children:["按照缓存规则，缓存可以分为",(0,c.jsx)(n.strong,{children:"强制缓存"}),"和",(0,c.jsx)(n.strong,{children:"协商缓存"}),"两类："]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"强制缓存"}),"是指当缓存数据库中已有所请求的数据时，直接从缓存数据库中获取数据。只有缓存数据库中没有所请求的数据时，才会从服务端获取数据。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"协商缓存"}),"又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，然后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回",(0,c.jsx)(n.code,{children:"304"}),"，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。"]}),"\n",(0,c.jsx)(n.p,{children:"两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。"}),"\n",(0,c.jsxs)(n.h2,{id:"缓存控制",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#缓存控制",children:"#"}),"缓存控制"]}),"\n",(0,c.jsxs)(n.p,{children:["缓存相关的规则信息包含在",(0,c.jsx)(n.code,{children:"header"}),"中，具体如下："]}),"\n",(0,c.jsxs)(n.h3,{id:"强制缓存",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#强制缓存",children:"#"}),"强制缓存"]}),"\n",(0,c.jsxs)(n.p,{children:["对于强制缓存，服务器响应的",(0,c.jsx)(n.code,{children:"header"}),"中可以用以下两种方式表明过期时间："]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.code,{children:"Expires"})}),"：服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。",(0,c.jsx)(n.code,{children:"Expires"}),"属于",(0,c.jsx)(n.code,{children:"HTTP 1.0"}),"协议，但由于服务端时间和客户端时间可能有误差，会导致缓存命中的误差，现在大多数使用",(0,c.jsx)(n.code,{children:"Cache-Control"}),"替代。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.code,{children:"Cache-Control"})}),"：",(0,c.jsx)(n.code,{children:"Cache-Control"}),"有很多属性，不同的属性代表的意义也不同。",(0,c.jsx)(n.code,{children:"max-age=t"}),"可用来指定时间，表示t秒之后缓存内容将失效。"]}),"\n",(0,c.jsxs)(n.p,{children:["当在",(0,c.jsx)(n.code,{children:"Cache-Control"}),"中设置了",(0,c.jsx)(n.code,{children:"max-age"}),"时，",(0,c.jsx)(n.code,{children:"Expires"}),"将会被忽略。"]}),"\n",(0,c.jsxs)(n.h3,{id:"协商缓存",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#协商缓存",children:"#"}),"协商缓存"]}),"\n",(0,c.jsx)(n.p,{children:"协商缓存需要进行对比判断是否可以使用缓存。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"Last-Modified"})}),"\n",(0,c.jsxs)(n.p,{children:["浏览器第一次请求数据时，服务器会将最后修改时间以",(0,c.jsx)(n.code,{children:"Last-Modified: <date>"}),"响应首部的形与数据一起发送给客户端。"]}),"\n",(0,c.jsxs)(n.p,{children:["当需要对缓存进行在验证时，浏览器会将该最后修改时间放到",(0,c.jsx)(n.code,{children:"If-Modified-Since"}),"请求首部中，发送给服务器。服务器会将此时间与服务器上请求资源的最后修改时间进行对比，如果一致则返回一个",(0,c.jsx)(n.code,{children:"304 Not Modified"}),"响应。",(0,c.jsx)(n.code,{children:"304"}),"的响应头也可以同时更新缓存文档的过期时间。否则返回带有新数据的状态为",(0,c.jsx)(n.code,{children:"200"}),"的响应。"]}),"\n",(0,c.jsxs)(n.p,{children:["另外还有一个",(0,c.jsx)(n.code,{children:"If-Unmodified-Since"}),"请求首部，意思为，当数据没有被修改时，返回数据。否则返回一个",(0,c.jsx)(n.code,{children:"412 Precondition failed"}),"的响应。"]}),"\n",(0,c.jsxs)(n.p,{children:["对于",(0,c.jsx)(n.code,{children:"Last-Modified"}),"而言，如果一个资源被修改的，但是实际内容根本没发生改变，会因为",(0,c.jsx)(n.code,{children:"Last-Modified"}),"时间匹配不上而返回了整个实体给客户端。因此，",(0,c.jsx)(n.code,{children:"Last-Modified"}),"又被称为",(0,c.jsx)(n.strong,{children:"弱校验"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"ETag"})}),"\n",(0,c.jsxs)(n.p,{children:["为了解决",(0,c.jsx)(n.code,{children:"Last-Modified"}),"问题，",(0,c.jsx)(n.code,{children:"HTTP 1.1"}),"推出了被称为",(0,c.jsx)(n.strong,{children:"实体标签"}),(0,c.jsx)(n.code,{children:"ETag"}),"强校验。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"ETag"}),"是附加到文档上的任意标签（引用字符串），可能包含了文档的序列号或者版本名，或者是文档内容的校验及其他指纹信息。"]}),"\n",(0,c.jsxs)(n.p,{children:["与",(0,c.jsx)(n.code,{children:"Last-Modified"}),"类似，服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）。"]}),"\n",(0,c.jsxs)(n.p,{children:["再次请求服务器时，浏览器会将",(0,c.jsx)(n.code,{children:"ETag"}),"的值放到",(0,c.jsx)(n.code,{children:"If-None-Match"}),"请求首部中。服务器会将此值与被请求资源的唯一标识进行对比。相同返回",(0,c.jsx)(n.code,{children:"304 Not Modified"}),"，不同返回带有新的资源内容的",(0,c.jsx)(n.code,{children:"200"}),"的响应。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"ETag"}),"的缺点就是其值是使用算法得出的，会占用服务端计算的资源。"]}),"\n",(0,c.jsxs)(n.h3,{id:"cache-control",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#cache-control",children:"#"}),"Cache-Control"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"HTTP/1.1"}),"定义了",(0,c.jsx)(n.code,{children:"Cache-Control"}),"请求首部来区分不同的缓存策略，请求首部和响应首部都支持。"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Cache-Control: no-store"}),"，禁止缓存。缓存中不会存储任何关于客户端请求和服务端响应的内容"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Cache-Control: no-cache"}),"，缓存但重新验证。每次有请求发出时，缓存会将此请求发到服务器，以验证请求中所描述的缓存是否过期，若未过期才使用本地缓存副本。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Cache-Control: public"}),"公共缓存或",(0,c.jsx)(n.code,{children:"Cache-Control: private"}),"私有缓存。公共缓存可以被任何中间人（比如中间代理、CDN等）缓存。私有缓存表示该响应是专用于某单个用户的，中间人不能缓存此响应，只能应用于浏览器私有缓存中。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Cache-Control: max-age=<seconds>"}),"。表示资源能够被缓存（保持新鲜）的最大时间"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Cache-Control: must-revalidate"}),"。在事先没有跟原始服务器再验证的情况下，不能提供这个对象的陈旧副本，但缓存可以提供新鲜副本。如果在进行",(0,c.jsx)(n.code,{children:"must-revalidate"}),"新鲜度检查时，原始服务器不可用时要返回",(0,c.jsx)(n.code,{children:"504 Gateway Timeout"}),"错误"]}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"不同刷新的请求执行过程",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#不同刷新的请求执行过程",children:"#"}),"不同刷新的请求执行过程"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"浏览器地址栏中写入URL，回车浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）"}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"F5"}),"，就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上",(0,c.jsx)(n.code,{children:"If-Modify-Since"}),"。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Ctrl+F5"}),"告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作."]}),"\n"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"参考资料："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ",rel:"noopener noreferrer",target:"_blank",children:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://juejin.cn/post/6844903517702848526#heading-1",rel:"noopener noreferrer",target:"_blank",children:"https://juejin.cn/post/6844903517702848526#heading-1"})}),"\n"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,c.jsx)(n,Object.assign({},e,{children:(0,c.jsx)(s,e)})):s(e)}let h=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["network%2Fcaching.md"]={toc:[{id:"缓存规则",text:"缓存规则",depth:2},{id:"缓存控制",text:"缓存控制",depth:2},{id:"强制缓存",text:"强制缓存",depth:3},{id:"协商缓存",text:"协商缓存",depth:3},{id:"cache-control",text:"Cache-Control",depth:3},{id:"不同刷新的请求执行过程",text:"不同刷新的请求执行过程",depth:3}],title:"HTTP缓存",headingTitle:"HTTP缓存",frontmatter:{}}}}]);