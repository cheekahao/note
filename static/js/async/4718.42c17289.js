"use strict";(self.webpackChunknote=self.webpackChunknote||[]).push([["4718"],{3749:function(n,e,r){r.r(e),r.d(e,{default:()=>t});var i=r(5893),d=r(65);function h(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",pre:"pre",h3:"h3",ol:"ol",li:"li",strong:"strong",ul:"ul",img:"img",h4:"h4"},(0,d.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"数据结构与算法",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数据结构与算法",children:"#"}),"数据结构与算法"]}),"\n",(0,i.jsxs)(e.h2,{id:"内存中的栈和堆",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#内存中的栈和堆",children:"#"}),"内存中的栈和堆"]}),"\n",(0,i.jsx)(e.p,{children:"栈由操作系统自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。"}),"\n",(0,i.jsxs)(e.p,{children:["堆由程序员分配释放，若程序员不释放，程序结束时可能由",(0,i.jsx)(e.code,{children:"OS"}),"回收，分配方式类似于链表。"]}),"\n",(0,i.jsx)(e.p,{children:"栈使用的是一级缓存，在被调用时处于存储空间中，调用完毕立即释放。"}),"\n",(0,i.jsx)(e.p,{children:"堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。"}),"\n",(0,i.jsxs)(e.p,{children:["与堆相比，栈存取速度比堆要快，仅次于直接位于",(0,i.jsx)(e.code,{children:"CPU"}),"中的寄存器。缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。"]}),"\n",(0,i.jsxs)(e.h2,{id:"二分查找",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#二分查找",children:"#"}),"二分查找"]}),"\n",(0,i.jsx)(e.p,{children:"输入一个有序元素列表，从1/2处开始查找，通过比较大小排除一半元素，再从剩下的元素的1/2处开始查找，不断递归，直到查找到结果为止。"}),"\n",(0,i.jsx)(e.p,{children:"复杂度为O(log n)"}),"\n",(0,i.jsxs)(e.h2,{id:"数组和链表",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数组和链表",children:"#"}),"数组和链表"]}),"\n",(0,i.jsx)(e.p,{children:"链表的每一个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串联起来。"}),"\n",(0,i.jsx)(e.p,{children:"在链表中添加元素只需将其放入内存，并将其地址存储到前一个元素中。"}),"\n",(0,i.jsx)(e.p,{children:"从链表中读取元素时，需要从第一个元素开始，依次往下访问，直到找到对应元素为止，所以读取元素效率较低。"}),"\n",(0,i.jsx)(e.p,{children:"数组中的元素在内存中紧连在一起，所以从数组中随机的读取元素，只需要根据其索引值和起始地址做简单的算术运算即可。但是在数组中插入元素，就需要将要插入位置之后的元素依次后移，然后再讲元素插入，所以其插入效率较低。"}),"\n",(0,i.jsx)(e.p,{children:"数组和链表的操作运行时间对比如下："}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"操作"}),(0,i.jsx)(e.th,{children:"数组"}),(0,i.jsx)(e.th,{children:"链表"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"读取"}),(0,i.jsx)(e.td,{children:"O(1)"}),(0,i.jsx)(e.td,{children:"O(n)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"插入"}),(0,i.jsx)(e.td,{children:"O(n)"}),(0,i.jsx)(e.td,{children:"O(1)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"删除"}),(0,i.jsx)(e.td,{children:"O(n)"}),(0,i.jsx)(e.td,{children:"O(1)"})]})]})]}),"\n",(0,i.jsxs)(e.h2,{id:"选择排序",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#选择排序",children:"#"}),"选择排序"]}),"\n",(0,i.jsx)(e.p,{children:"依次找到最小值，并将最小值与对应位置的元素交换"}),"\n",(0,i.jsx)(e.p,{children:"复杂度为O(n2)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"function selectionSort(arr) {\n    let length = arr.length,\n        minIndex, temp;\n        \n    for (var i = 0; i < length - 1; i++) {\n        minIndex = i;\n        for (var j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {     // 寻找最小的数\n                minIndex = j;                 // 将最小数的索引保存\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    return arr;\n} \n"})}),"\n",(0,i.jsxs)(e.h2,{id:"栈",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#栈",children:"#"}),"栈"]}),"\n",(0,i.jsx)(e.p,{children:"栈是一种后进先出的列表，只有压入(push)和弹出(pop)两种操作。"}),"\n",(0,i.jsxs)(e.h2,{id:"递归",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#递归",children:"#"}),"递归"]}),"\n",(0,i.jsx)(e.p,{children:"递归是一种函数自己调用自己解决方案，能用递归解决的问题都能用循环解决，递归并不是性能上的提升，而是更清晰，更容易理解。"}),"\n",(0,i.jsx)(e.p,{children:"递归都有基线条件和递归条件。"}),"\n",(0,i.jsxs)(e.h2,{id:"分治",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#分治",children:"#"}),"分治"]}),"\n",(0,i.jsxs)(e.p,{children:["分治算法",(0,i.jsx)(e.code,{children:"divide and conquer"}),"，",(0,i.jsx)(e.code,{children:"D & C"}),"，是一种著名的递归式问题解决方法。"]}),"\n",(0,i.jsxs)(e.h3,{id:"归并排序",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#归并排序",children:"#"}),"归并排序"]}),"\n",(0,i.jsx)(e.p,{children:"归并排序是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。复杂度为O(nlog(n))"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function mergeSort(array){\n    const {length} = array\n    if(length < 2) return array\n\n    const middle = Math.floor( length / 2 )\n    const left = mergeSort(array.slice(0, middle))\n    const right = mergeSort(array.slice(middle, length))\n\n    return merge(left, right)\n}\n\nfunction merge(left, right){\n    let i = 0;\n    let j = 0;\n    const result = []\n\n    while(i < left.length && j < right.length){\n        const leftItem = left[i]\n        const rightItem = right[j]\n        let item\n\n        if(leftItem < rightItem){\n            item = leftItem;\n            i++;\n        }else{\n            item = rightItem;\n            j++;\n        }\n        result.push(item)\n    }\n\n    return result.concat(i < left.length ? left.slice(i) : right.slice(j))\n}\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"快速排序",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#快速排序",children:"#"}),"快速排序"]}),"\n",(0,i.jsx)(e.p,{children:"快速排序是一种常用的排序算法，复杂度为O(nlog n)，且性能比其他复杂度为O(nlog n)的排序算法好。"}),"\n",(0,i.jsx)(e.p,{children:"具体步骤如下："}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"从数组中选择中间一项作为基准值"}),"\n",(0,i.jsx)(e.li,{children:"划分，将数组分为大于基准值和小于基准值的两个数组"}),"\n",(0,i.jsx)(e.li,{children:"递归，递归上面划分的两个数组，知道所有都只有一个元素"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"根据划分的过程是否需要额外的内存，又可将其分为in-place(原地算法)和out-place两种"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"out-place"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"function quickSort(arr) {\n    //如果为空数组或者只有一个元素的数组，直接返回，递归的基线条件\n    if(arr.length < 2) return arr;\n\n    let pivotIndex = Math.floor( arr.length / 2 ),\n        pivot = arr.splice(pivotIndex, 1)[0],\n        left = [],\n        right = [];\n\n    for (let index = 0; index < arr.length; index++) {\n        const item = arr[index];\n        \n        if (item < pivot){\n            left.push(item)\n        }else{\n            right.push(item)\n        }\n    }\n\n    console.log('quickSort', 'pivot', pivot, 'pivotIndex', pivotIndex, 'left', left, 'right', right);\n    \n    left = quickSort(left);\n    right = quickSort(right);\n\n    return [...left, pivot, ...right]\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"in-place"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"function quickSort(arr) {\n    sortByIndex(arr, 0, arr.length - 1);\n\n    return arr\n}\n\nfunction sortByIndex(arr, left, right) {\n    if(arr.length < 2) return;\n\n    var pivotIndex = partition(arr, left, right); //基准值的索引值\n\n    console.log('pivotIndex', pivotIndex);\n\n    left < pivotIndex - 1 && sortByIndex(arr, left, pivotIndex - 1); //对索引值左边的元素进行排序\n    pivotIndex < right && sortByIndex(arr, pivotIndex, right); //对索引值右边的元素进行排序\n}\n\nfunction partition(arr, left, right){\n    let pivotIndex = Math.floor((left + right) / 2), //基准值的索引值为两者中间的元素\n        pivot = arr[pivotIndex],\n        i = left,\n        j = right; //基准值\n\n    let tmp = arr.slice(left, right - left + 1);\n\n    while (i <= j) {\n        while (arr[i] < pivot) {\n            i ++;\n        }\n        while (arr[j] > pivot) {\n            j --;\n        }\n        if(i <= j){\n            swop(arr, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    console.log('sub arr', tmp, 'after', arr.slice(left, right - left + 1), 'pivotIndex', i, 'init pivotIndex', pivotIndex);\n    \n    return i\n}\n\nfunction swop(arr, a, b){\n    let tmp = arr[a];\n\n    console.log('swop', a, b);\n    \n    arr[a] = arr[b];\n    arr[b] = tmp;\n    // console.log(arr);\n}\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"散列表",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#散列表",children:"#"}),"散列表"]}),"\n",(0,i.jsxs)(e.h2,{id:"树",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#树",children:"#"}),"树"]}),"\n",(0,i.jsxs)(e.p,{children:["树是一种分层数据的抽象模型。一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点。位于树顶部的节点叫作",(0,i.jsx)(e.strong,{children:"根节点"}),"。树中的每个元素都叫作",(0,i.jsx)(e.strong,{children:"节点"}),"，节点分为",(0,i.jsx)(e.strong,{children:"内部节点"}),"和",(0,i.jsx)(e.strong,{children:"外部节点"}),"。至少有一个子节点的节点称为",(0,i.jsx)(e.strong,{children:"内部节点"}),"。没有子元素的节点称为",(0,i.jsx)(e.strong,{children:"外部节点"}),"或",(0,i.jsx)(e.strong,{children:"叶节点"}),"。"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"子树"}),"由节点和它的后代构成。节点的一个属性是",(0,i.jsx)(e.strong,{children:"深度"}),"，取决于它的祖先节点的数量。树的",(0,i.jsx)(e.strong,{children:"高度"}),"取决于所有节点深度的最大值。"]}),"\n",(0,i.jsxs)(e.h3,{id:"二叉树",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#二叉树",children:"#"}),"二叉树"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"二叉树"}),"中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"二叉搜索树"}),"（BST）是二叉树的一种，它只允许在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。"]}),"\n",(0,i.jsx)(e.p,{children:"遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。访问树的所有节点有三种方式：中序、先序和后序。"}),"\n",(0,i.jsxs)(e.h3,{id:"自平衡树",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#自平衡树",children:"#"}),"自平衡树"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"AVL"}),"(",(0,i.jsx)(e.code,{children:"Adelson-Velskii-Landi"}),")树是一种",(0,i.jsx)(e.strong,{children:"自平衡二叉搜索树"}),"，任何一个节点左右两侧子树的高度之差最多为1。添加或移除节点时，会尝试保持自平衡。"]}),"\n",(0,i.jsxs)(e.h3,{id:"红黑树",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#红黑树",children:"#"}),"红黑树"]}),"\n",(0,i.jsxs)(e.p,{children:["红黑树(",(0,i.jsx)(e.code,{children:"Red-Black Tree"}),", ",(0,i.jsx)(e.code,{children:"RBT"}),")也是一个自平衡二叉搜索树。每个节点都遵循以下规则："]}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"每个节点不是红的就是黑的"}),"\n",(0,i.jsx)(e.li,{children:"树的根节点是黑的"}),"\n",(0,i.jsxs)(e.li,{children:["所有叶节点都是黑的（用",(0,i.jsx)(e.code,{children:"NULL"}),"引用表示的节点）"]}),"\n",(0,i.jsx)(e.li,{children:"如果一个节点是红的，那么它的两个子节点都是黑的"}),"\n",(0,i.jsx)(e.li,{children:"不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点"}),"\n",(0,i.jsxs)(e.li,{children:["从给定的节点到它的后代节点（",(0,i.jsx)(e.code,{children:"NULL"}),"叶节点）的所有路径包含相同数量的黑色节点"]}),"\n"]}),"\n",(0,i.jsxs)(e.h2,{id:"图",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#图",children:"#"}),"图"]}),"\n",(0,i.jsxs)(e.h3,{id:"图的相关概念",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#图的相关概念",children:"#"}),"图的相关概念"]}),"\n",(0,i.jsxs)(e.p,{children:["一个",(0,i.jsx)(e.strong,{children:"图"}),(0,i.jsx)(e.code,{children:"G=(V, E)"}),"由以下元素组成："]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"V"}),": 一组顶点"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"E"}),": 一组边，连接",(0,i.jsx)(e.code,{children:"V"}),"中的顶点"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:"http://img.haozhenjia.com/blog/graph.jpg",alt:"图"})}),"\n",(0,i.jsxs)(e.p,{children:["由一条边连接在一起的顶点称为",(0,i.jsx)(e.strong,{children:"相邻顶点"}),"。例如",(0,i.jsx)(e.code,{children:"C"}),"和",(0,i.jsx)(e.code,{children:"D"}),"是相邻的。"]}),"\n",(0,i.jsxs)(e.p,{children:["一个顶点的",(0,i.jsx)(e.strong,{children:"度"}),"是其相邻顶点的数量。例如",(0,i.jsx)(e.code,{children:"A"}),"的度是3。"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"路径"}),"是顶点v1, v2, …, vk的一个连续序列，其中",(0,i.jsx)(e.code,{children:"vi"}),"和",(0,i.jsx)(e.code,{children:"vi+1"}),"是相邻的。例如路径",(0,i.jsx)(e.code,{children:"ABEI"}),"。简单路径要求不包含重复的顶点。除去最后一个顶点，环(",(0,i.jsx)(e.code,{children:"ADCA"}),")也是一个简单路径。"]}),"\n",(0,i.jsxs)(e.p,{children:["如果图中不存在环，则称该图是",(0,i.jsx)(e.strong,{children:"无环"}),"的。如果图中每两个顶点间都存在路径，则该图是",(0,i.jsx)(e.strong,{children:"连通"}),"的。"]}),"\n",(0,i.jsxs)(e.p,{children:["图可以是无向的（边没有方向，",(0,i.jsx)(e.strong,{children:"无向图"}),"）或是有向的（",(0,i.jsx)(e.strong,{children:"有向图"}),"）。有向图如下图所示："]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:"http://img.haozhenjia.com/blog/oriented_graph.jpg",alt:"有向图"})}),"\n",(0,i.jsxs)(e.p,{children:["如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，",(0,i.jsx)(e.code,{children:"C"}),"和",(0,i.jsx)(e.code,{children:"D"}),"是强连通的。"]}),"\n",(0,i.jsxs)(e.p,{children:["图还可以是未加权的或是加权的。",(0,i.jsx)(e.strong,{children:"加权图"}),"的边被赋予了权值，如下图所示："]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:"http://img.haozhenjia.com/blog/weighted_graph.jpg",alt:"加权图"})}),"\n",(0,i.jsxs)(e.h3,{id:"图的表示",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#图的表示",children:"#"}),"图的表示"]}),"\n",(0,i.jsxs)(e.h4,{id:"邻接矩阵",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#邻接矩阵",children:"#"}),"邻接矩阵"]}),"\n",(0,i.jsxs)(e.p,{children:["图最常见的实现是",(0,i.jsx)(e.strong,{children:"邻接矩阵"}),"。每个节点都和一个整数相关联，该整数将作为数组的索引，用一个二维数组来表示顶点之间的连接。如果索引为i的节点和索引为j的节点相邻，则",(0,i.jsx)(e.code,{children:"array[i][j] === 1"}),"，否则",(0,i.jsx)(e.code,{children:"array[i][j] === 0"}),"。"]}),"\n",(0,i.jsxs)(e.p,{children:["不是强连通的图（",(0,i.jsx)(e.strong,{children:"稀疏图"}),"）用邻接矩阵来表示，矩阵中将会有很多0，会对存储空间造成一定的浪费。"]}),"\n",(0,i.jsxs)(e.h4,{id:"邻接表",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#邻接表",children:"#"}),"邻接表"]}),"\n",(0,i.jsxs)(e.p,{children:["还可以用一种叫作",(0,i.jsx)(e.strong,{children:"邻接表"}),"的动态数据结构来表示图。邻接表由图中每个顶点的相邻顶点列表所组成。可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。邻接表对大多数问题来说都是更好的选择。"]}),"\n",(0,i.jsxs)(e.h4,{id:"关联矩阵",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#关联矩阵",children:"#"}),"关联矩阵"]}),"\n",(0,i.jsxs)(e.p,{children:["还可以用",(0,i.jsx)(e.strong,{children:"关联矩阵"}),"来表示图。在关联矩阵中，矩阵的行表示顶点，列表示边。使用二维数组来表示两者之间的连通性，如果顶点v是边e的入射点，则",(0,i.jsx)(e.code,{children:"array[v][e] === 1"}),"；否则，",(0,i.jsx)(e.code,{children:"array[v][e] === 0"}),"。关联矩阵通常用于边的数量比顶点多的情况。"]}),"\n",(0,i.jsxs)(e.h2,{id:"广度优先搜索",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#广度优先搜索",children:"#"}),"广度优先搜索"]}),"\n",(0,i.jsxs)(e.h2,{id:"加权图与狄克斯特拉算法",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#加权图与狄克斯特拉算法",children:"#"}),"加权图与狄克斯特拉算法"]}),"\n",(0,i.jsxs)(e.h2,{id:"贪心算法",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#贪心算法",children:"#"}),"贪心算法"]}),"\n",(0,i.jsxs)(e.h3,{id:"贪心算法基础概念",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#贪心算法基础概念",children:"#"}),"贪心算法基础概念"]}),"\n",(0,i.jsx)(e.p,{children:"狭义的贪心算法指的是解最优化问题的一种特殊方法，解决过程中总是做出当下最好的选择，因为具有最优子结构的特点，局部最优解可以得到全局最优解；这种贪心算法是动态规划的一种特例。能用贪心解决的问题，也可以用动态规划解决。"}),"\n",(0,i.jsx)(e.p,{children:"而广义的贪心指的是一种通用的贪心策略，基于当前局面而进行贪心决策。"}),"\n",(0,i.jsxs)(e.h3,{id:"贪心算法的思考过程",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#贪心算法的思考过程",children:"#"}),"贪心算法的思考过程"]}),"\n",(0,i.jsx)(e.p,{children:"贪心的思考过程类似动态规划，依旧是两步：大事化小，小事化了。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"大事化小："})}),"\n",(0,i.jsx)(e.p,{children:"一个较大的问题，通过找到与子问题的重叠，把复杂的问题划分为多个小问题；"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"小事化了："})}),"\n",(0,i.jsx)(e.p,{children:"从小问题找到决策的核心，确定一种得到最优解的策略。"}),"\n",(0,i.jsxs)(e.h2,{id:"斐波那契数列计算",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#斐波那契数列计算",children:"#"}),"斐波那契数列计算"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"递归"})}),"\n",(0,i.jsx)(e.p,{children:"缺点，随着n的变大，执行次数大量增长"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"function getFibonacci(n){\n    if(n < 3){\n        return 1\n    }else{\n        return getFibonacci(n - 1) + getFibonacci(n - 2)\n    }\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"动态规划"})}),"\n",(0,i.jsx)(e.p,{children:"通过一个数组保存中间结果，通过循环计算斐波那契数列，并将最后的值返回。\n动态规划算法需要将中间结果保存起来。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"//方案一\nfunction getFibonacci(n){\n    if (n === 1 || n === 2){\n        return 1\n    }else{\n        let tmp = [1, 1];\n\n        for(let i = 2; i <= n; i ++){\n            tmp[i] = tmp[i - 1] + tmp[i - 2]\n        }\n\n        return tmp[n - 1]\n    }\n}\n\n//方案二\nfunction getFibonacci(n){\n    if (n === 1 || n === 2){\n        return 1\n    }else{\n        let last = 1,\n            second = 1,\n            tmp;\n\n        for(let i = 2; i <= n; i ++){\n            tmp = last;\n            last = last + second;\n            second = tmp;\n        }\n\n        return last\n    }\n}\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"算法复杂度",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#算法复杂度",children:"#"}),"算法复杂度"]}),"\n",(0,i.jsxs)(e.h3,{id:"大o表示法",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#大o表示法",children:"#"}),"大O表示法"]}),"\n",(0,i.jsxs)(e.p,{children:["大",(0,i.jsx)(e.code,{children:"O"}),"表示法用于描述算法的性能和复杂程度。将算法按照消耗的时间进行分类，依据随输入增大所需要的空间/内存。"]}),"\n",(0,i.jsx)(e.p,{children:"常用的函数有："}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"符号"}),(0,i.jsx)(e.th,{children:"名称"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"O(1)"})}),(0,i.jsx)(e.td,{children:"常数的"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"O(log(n))"})}),(0,i.jsx)(e.td,{children:"对数的"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"O(log(n))c"})}),(0,i.jsx)(e.td,{children:"对数多项式的"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"O(n)"})}),(0,i.jsx)(e.td,{children:"线性的"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsxs)(e.td,{children:["O(n","2",")"]}),(0,i.jsx)(e.td,{children:"二次的"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsxs)(e.td,{children:["O(n","c",")"]}),(0,i.jsx)(e.td,{children:"多项式的"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsxs)(e.td,{children:["O(c","n",")"]}),(0,i.jsx)(e.td,{children:"指数的"})]})]})]})]})}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,d.ah)(),n.components);return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(h,n)})):h(n)}let t=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["advance%2Falgorithm.md"]={toc:[{id:"内存中的栈和堆",text:"内存中的栈和堆",depth:2},{id:"二分查找",text:"二分查找",depth:2},{id:"数组和链表",text:"数组和链表",depth:2},{id:"选择排序",text:"选择排序",depth:2},{id:"栈",text:"栈",depth:2},{id:"递归",text:"递归",depth:2},{id:"分治",text:"分治",depth:2},{id:"归并排序",text:"归并排序",depth:3},{id:"快速排序",text:"快速排序",depth:3},{id:"散列表",text:"散列表",depth:2},{id:"树",text:"树",depth:2},{id:"二叉树",text:"二叉树",depth:3},{id:"自平衡树",text:"自平衡树",depth:3},{id:"红黑树",text:"红黑树",depth:3},{id:"图",text:"图",depth:2},{id:"图的相关概念",text:"图的相关概念",depth:3},{id:"图的表示",text:"图的表示",depth:3},{id:"邻接矩阵",text:"邻接矩阵",depth:4},{id:"邻接表",text:"邻接表",depth:4},{id:"关联矩阵",text:"关联矩阵",depth:4},{id:"广度优先搜索",text:"广度优先搜索",depth:2},{id:"加权图与狄克斯特拉算法",text:"加权图与狄克斯特拉算法",depth:2},{id:"贪心算法",text:"贪心算法",depth:2},{id:"贪心算法基础概念",text:"贪心算法基础概念",depth:3},{id:"贪心算法的思考过程",text:"贪心算法的思考过程",depth:3},{id:"斐波那契数列计算",text:"斐波那契数列计算",depth:2},{id:"算法复杂度",text:"算法复杂度",depth:2},{id:"大o表示法",text:"大O表示法",depth:3}],title:"数据结构与算法",headingTitle:"数据结构与算法",frontmatter:{}}}}]);