"use strict";(self.webpackChunknote=self.webpackChunknote||[]).push([["7943"],{6813:function(e,n,d){d.r(n),d.d(n,{default:()=>l});var c=d(5893),r=d(65);function s(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",h3:"h3",ul:"ul",li:"li",code:"code",p:"p",ol:"ol",pre:"pre",strong:"strong",h4:"h4",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,r.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"webpack",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#webpack",children:"#"}),"webpack"]}),"\n",(0,c.jsxs)(n.h2,{id:"工作原理",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#工作原理",children:"#"}),"工作原理"]}),"\n",(0,c.jsxs)(n.h3,{id:"基本概念",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基本概念",children:"#"}),"基本概念"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Entry"}),": 入口，执行构建的输入"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Module"}),": 模块，在",(0,c.jsx)(n.code,{children:"Webpack"}),"里一切皆模块，",(0,c.jsx)(n.code,{children:"Webpack"}),"会从",(0,c.jsx)(n.code,{children:"Entry"}),"开始，递归找出所有依赖的模块"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Chunk"}),": 代码块，一个",(0,c.jsx)(n.code,{children:"Chunk"}),"由多个模块合成，用于代码合并和分割"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Loader"}),": 模块转换器，用于将模块的源内容按照需求转换成新内容"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Plugin"}),": 扩展插件，在构建流程中的特定时机会广播对应的事件，插件可以监听这些事件，做出对应的事情"]}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"流程",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#流程",children:"#"}),"流程"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Webpack"}),"的运行流程是一个串行的过程，从启动开始依次是："]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["初始化参数：从配置文件和",(0,c.jsx)(n.code,{children:"Shell"}),"语句中读取与合并参数，得出最终参数"]}),"\n",(0,c.jsxs)(n.li,{children:["开始编译：基于最终的参数初始化",(0,c.jsx)(n.code,{children:"Compiler"}),"对象，加载所有配置的插件，通过执行对象的",(0,c.jsx)(n.code,{children:"run"}),"方法开始编译"]}),"\n",(0,c.jsxs)(n.li,{children:["确定入口：根据配置中的",(0,c.jsx)(n.code,{children:"Entry"}),"找出所有入口文件"]}),"\n",(0,c.jsxs)(n.li,{children:["编译模块：从入口文件出发，调用所有配置的",(0,c.jsx)(n.code,{children:"Loader"}),"对模块递归的进行编译"]}),"\n",(0,c.jsx)(n.li,{children:"完成模块编译：得到每个模块编译后的内容及之间的依赖关系"}),"\n",(0,c.jsxs)(n.li,{children:["输出资源：根据入口及模块之前的依赖关系，组装成一个个包含多个模块的",(0,c.jsx)(n.code,{children:"Chunk"}),"，再将每个",(0,c.jsx)(n.code,{children:"Chunk"}),"转换成一个单独的文件加入输出列表，这是修改输出内容的最后机会"]}),"\n",(0,c.jsx)(n.li,{children:"输出完成：根据配置的输出路径和文件名，将文件内容写入文件系统中"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["在以上过程中，",(0,c.jsx)(n.code,{children:"Webpack"}),"会在特定的时间广播特定的事件，插件在监听到特定事件后可以执行对应的逻辑，并且可以调用",(0,c.jsx)(n.code,{children:"Webpack"}),"提供的",(0,c.jsx)(n.code,{children:"API"}),"改变",(0,c.jsx)(n.code,{children:"Webpack"}),"的运行结果。"]}),"\n",(0,c.jsx)(n.p,{children:"整体构建流程可以分为以下三大阶段："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["初始化，启动构建，处理配置参数，加载",(0,c.jsx)(n.code,{children:"Plugin"}),"，实例化",(0,c.jsx)(n.code,{children:"Compiler"})]}),"\n",(0,c.jsxs)(n.li,{children:["编译，从",(0,c.jsx)(n.code,{children:"Entry"}),"开始，针对每个",(0,c.jsx)(n.code,{children:"Module"}),"串行调用对应",(0,c.jsx)(n.code,{children:"Loader"}),"去编译内容，并依据",(0,c.jsx)(n.code,{children:"Module"}),"之间的依赖关系，递归的进行编译处理"]}),"\n",(0,c.jsxs)(n.li,{children:["输出，将编译后的",(0,c.jsx)(n.code,{children:"Module"}),"组合成",(0,c.jsx)(n.code,{children:"Chunk"}),"，然后转换成文件，输出到文件系统"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"build"}),"时，只执行上述阶段一次。监听模式下，将不断的执行编译，输出阶段"]}),"\n",(0,c.jsxs)(n.h2,{id:"模块module",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模块module",children:"#"}),"模块Module"]}),"\n",(0,c.jsx)(n.p,{children:"在模块化编程中，开发者将程序分解成离散功能块(discrete chunks of functionality)，并称之为模块。"}),"\n",(0,c.jsx)(n.p,{children:"Webpack模块能够以各种方式表达他们的依赖关系，例如："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"ES6``import"}),"语句"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"CommonJS``require()"}),"语句"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"AMD``define"}),"和",(0,c.jsx)(n.code,{children:"require"}),"语句"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"css/sass/less"}),"文件中的",(0,c.jsx)(n.code,{children:"@import"}),"语句"]}),"\n",(0,c.jsxs)(n.li,{children:["样式(",(0,c.jsx)(n.code,{children:"url(...)"}),")或",(0,c.jsx)(n.code,{children:"HTML"}),"文件(",(0,c.jsx)(n.code,{children:"<img src=...>"}),")中的图片链接(image url)"]}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"loader",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#loader",children:"#"}),"Loader"]}),"\n",(0,c.jsxs)(n.p,{children:["以处理",(0,c.jsx)(n.code,{children:"SCSS"}),"文件为例："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"module.exports = {\n    module: {\n        rules: [{\n            test: /\\.scss/,\n            use: [\n                'style-loader',\n                {\n                    loader: 'css-loader',\n                    options: {\n                        minimize: true,\n                    }\n                },\n                'sass-loader',\n            ]\n        }]\n    },\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["一个",(0,c.jsx)(n.code,{children:"Loader"}),"的职责是单一的，只负责一种转换。一个源文件需要多次转换，需要配置多个",(0,c.jsx)(n.code,{children:"Loader"}),"。在调用多个",(0,c.jsx)(n.code,{children:"Loader"}),"时，执行顺序是",(0,c.jsx)(n.strong,{children:"从后往前"}),"依次执行"]}),"\n",(0,c.jsxs)(n.h3,{id:"基本写法",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基本写法",children:"#"}),"基本写法"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Loader"}),"就是一个函数，获取处理前的内容，返回处理后的内容"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"module.exports = function(source){\n    // 转换逻辑省略\n\n    return source\n}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"可调用的webpack-api",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#可调用的webpack-api",children:"#"}),"可调用的Webpack API"]}),"\n",(0,c.jsxs)(n.h4,{id:"获取loader的options",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#获取loader的options",children:"#"}),"获取",(0,c.jsx)(n.code,{children:"Loader"}),"的",(0,c.jsx)(n.code,{children:"options"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const loaderUtils = require('loader-utils')\n\nmodule.exports = function(source){\n    const options = loaderUtils.getOptions(this)\n\n    // 转换逻辑省略\n\n    return source\n}\n"})}),"\n",(0,c.jsxs)(n.h4,{id:"返回其他结果",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#返回其他结果",children:"#"}),"返回其他结果"]}),"\n",(0,c.jsxs)(n.p,{children:["直接",(0,c.jsx)(n.code,{children:"return"}),"可以返回原内容转换后的内容，返回其他内容需要用到this.callback函数："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"this.callback(\n    // 当无法转换原内容时，为Webpack返回一个Error\n    error: Error | null,\n    // 原内容转换后的内容\n    content: String | Buffer,\n    // 用于通过转换后的内容得出原内容的Source Map，以方便测试\n    sourceMap?: SourceMap,\n    // 如果本次转换为原内容生产了AST语法树，则可以将这个AST返回，以方便之后需要AST的Loader复用\n    abstractSyntaxTree?: AST\n)\n"})}),"\n",(0,c.jsxs)(n.p,{children:["此外，由于",(0,c.jsx)(n.code,{children:"Source Map"}),"生产很耗时，通常在开发环境下才生成。因此可以通过",(0,c.jsx)(n.code,{children:"this.sourceMap"}),"API来配置是否生成",(0,c.jsx)(n.code,{children:"Source Map"}),"。"]}),"\n",(0,c.jsxs)(n.h4,{id:"同步与异步",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#同步与异步",children:"#"}),"同步与异步"]}),"\n",(0,c.jsx)(n.p,{children:"异步转换流程如下："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"module.exports = function(source){\n    const callback = this.async()\n\n    // 转换逻辑省略\n    someAsyncOperation(source).then( (err, result, sourceMap, ast) => {\n        callback(err, result, sourceMap, ast)\n    })\n\n    return source\n}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"处理二进制数据",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#处理二进制数据",children:"#"}),"处理二进制数据"]}),"\n",(0,c.jsxs)(n.p,{children:["对于二进制数据，需要将",(0,c.jsx)(n.code,{children:"exports.raw = ture"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"module.exports = function(source){\n    return source\n}\n\n// 通过exports.raw属性告诉Webpack该Loader是否需要二进制数据\nmodule.exports.raw = true\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"缓存加速",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#缓存加速",children:"#"}),"缓存加速"]}),"\n",(0,c.jsxs)(n.p,{children:["可以通过",(0,c.jsx)(n.code,{children:"this.cacheable()"}),"方法设置是否缓存计算结果，默认是开启的"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"module.exports = function(source){\n\n    // 关闭缓存\n    this.cacheable(false)\n\n    return source\n}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"其他loader-api",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#其他loader-api",children:"#"}),"其他Loader API"]}),"\n",(0,c.jsxs)(n.table,{children:[(0,c.jsx)(n.thead,{children:(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.th,{children:(0,c.jsx)(n.code,{children:"API"})}),(0,c.jsx)(n.th,{children:"简介"})]})}),(0,c.jsxs)(n.tbody,{children:[(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"this.context"})}),(0,c.jsxs)(n.td,{children:["当前处理的文件所在目录，以",(0,c.jsx)(n.code,{children:"/src/main.js"}),"为例，为",(0,c.jsx)(n.code,{children:"/src"})]})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"this.resoure"})}),(0,c.jsxs)(n.td,{children:["当前处理的完整请求路径，包括",(0,c.jsx)(n.code,{children:"query string"}),"，例如",(0,c.jsx)(n.code,{children:"/src/main.js?name=1"})]})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"this.resourePath"})}),(0,c.jsxs)(n.td,{children:["当前处理文件的路径，例如",(0,c.jsx)(n.code,{children:"/src/main.js"})]})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"this.resoureQuery"})}),(0,c.jsxs)(n.td,{children:["当前处理文件的",(0,c.jsx)(n.code,{children:"query string"})]})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"this.target"})}),(0,c.jsxs)(n.td,{children:[(0,c.jsx)(n.code,{children:"Webpack"}),"中配置的",(0,c.jsx)(n.code,{children:"Target"})]})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"this.loadModule(request: string, callback: function(err, source, sourceMap, ast))"})}),(0,c.jsxs)(n.td,{children:[(0,c.jsx)(n.code,{children:"Loader"}),"在处理一个文件时，需要加入依赖时，用于获取对应文件的处理结果"]})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"this.addDependency(file: string)"})}),(0,c.jsx)(n.td,{children:"为当前处理的文件添加依赖。其依赖文件发生变化时，会重新调用loader处理该文件"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"this.addContextDependency(directory: string)"})}),(0,c.jsx)(n.td,{children:"将整个目录加入到正在处理的文件依赖中"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"this.clearDependencies()"})}),(0,c.jsx)(n.td,{children:"清除当前处理文件的多有依赖"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"`this.emitFile(name: string, content: Buffer"}),(0,c.jsx)(n.td,{children:"string, sourceMap)`"})]})]})]}),"\n",(0,c.jsxs)(n.h2,{id:"plugin",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#plugin",children:"#"}),"Plugin"]}),"\n",(0,c.jsxs)(n.h3,{id:"compiler和compilation",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#compiler和compilation",children:"#"}),"Compiler和Compilation"]}),"\n",(0,c.jsxs)(n.p,{children:["开发",(0,c.jsx)(n.code,{children:"Plugin"}),"最常用的两个对象就是",(0,c.jsx)(n.code,{children:"Compiler"}),"和",(0,c.jsx)(n.code,{children:"Compilation"}),"，他们是",(0,c.jsx)(n.code,{children:"Plugin"}),"和",(0,c.jsx)(n.code,{children:"Webpack"}),"之间的桥梁。"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Compiler"}),"包含所有配置信息(",(0,c.jsx)(n.code,{children:"options"}),"、",(0,c.jsx)(n.code,{children:"loaders"}),"和",(0,c.jsx)(n.code,{children:"plugins"}),"等)，在",(0,c.jsx)(n.code,{children:"Webpack"}),"启动时被实例化，全局唯一。代表了整个",(0,c.jsx)(n.code,{children:"Webpack"}),"从启动到关闭的生命周期"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Compilation"}),"包含当前的模块资源、编译生成资源和变化的文件等。在开发模式下，每当有文件变化时，就有一次新的",(0,c.jsx)(n.code,{children:"Compilation"}),"被创建。代表了一次编译过程"]}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"tapable",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#tapable",children:"#"}),"Tapable"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Webpack"}),"通过",(0,c.jsx)(n.code,{children:"Tapable"}),"来组织构建的事件流。",(0,c.jsx)(n.code,{children:"Webpack"}),"中许多对象(包括",(0,c.jsx)(n.code,{children:"Compiler"}),"和",(0,c.jsx)(n.code,{children:"Compilation"}),")都继承自",(0,c.jsx)(n.code,{children:"Tapable"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Tapable"}),"暴露了",(0,c.jsx)(n.code,{children:"tap"}),", ",(0,c.jsx)(n.code,{children:"tapAsync"}),"和",(0,c.jsx)(n.code,{children:"tapPromise"}),"方法。可以使用这些方法，注入自定义的构建步骤，这些步骤将在整个编译过程中不同时机触发。"]}),"\n",(0,c.jsxs)(n.p,{children:["都自",(0,c.jsx)(n.code,{children:"Tapable"}),"，可以广播和监听事件："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"/**\n * eventName 事件名，不要跟现有事件重名\n * params    附带参数\n */\ncompiler.apply(eventName, params)\n\n// 监听事件\ncompiler.plugin(eventName, callback)\n"})}),"\n",(0,c.jsxs)(n.p,{children:["每个插件的",(0,c.jsx)(n.code,{children:"Compiler"}),"和",(0,c.jsx)(n.code,{children:"Compilation"}),"对象都是同一个引用。修改",(0,c.jsx)(n.code,{children:"Compiler"}),"和",(0,c.jsx)(n.code,{children:"Compilation"}),"对象上的属性就会影响后面的插件。有些事件是异步的，插件处理完成时调用回调函数通知",(0,c.jsx)(n.code,{children:"Webpack"}),"，才能进入下一个流程。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"compiler.plugin('emit', function handle(compilation, callback) {\n    // 处理逻辑省略\n\n    // 调用callback通知Webpack进入下一个流程\n    callback()\n})\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"基本写法-1",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基本写法-1",children:"#"}),"基本写法"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Plugin"}),"主要通过监听",(0,c.jsx)(n.code,{children:"Webpack"}),"在运行的生命周期中广播的特定事件，在合适的时机通过",(0,c.jsx)(n.code,{children:"Webpack"}),"提供的",(0,c.jsx)(n.code,{children:"API"}),"做出对应的处理，改变输出结果"]}),"\n",(0,c.jsxs)(n.p,{children:["一个",(0,c.jsx)(n.code,{children:"Plugin"}),"就是一个类，具体写法如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"class TestPlugin{\n\n    // 在构造函数中可以获取用户对Plugin的配置\n    constructor(options){\n\n    }\n\n    // Webpack会调用实例的apply方法，并传入compiler对象\n    apply(compiler){\n        compiler.plugin('compilation', function handle(compilation) {\n            \n        })\n    }\n}\n\nmodule.exports = TestPlugin\n\n// 配置代码如下：\n\nconst TestPlugin = require('./TestPlugin.js')\n\nmodule.exports = {\n    plugins: [\n        new TestPlugin(options)\n    ]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Webpack"}),"启动后，读取配置过程中会初始化插件实例。在初始化",(0,c.jsx)(n.code,{children:"compiler"}),"对象之后，在调用插件的",(0,c.jsx)(n.code,{children:"apply"}),"方法，为实例传入",(0,c.jsx)(n.code,{children:"compiler"}),"对象。插件实例在获取到",(0,c.jsx)(n.code,{children:"compiler"}),"对象后，通过\n",(0,c.jsx)(n.code,{children:"compiler.plugin(event: string, callback: function(compilation))"}),"监听",(0,c.jsx)(n.code,{children:"Webpack"}),"广播的事件，通过",(0,c.jsx)(n.code,{children:"compiler"}),"对象去操作",(0,c.jsx)(n.code,{children:"Webpack"})]}),"\n",(0,c.jsxs)(n.h3,{id:"常用api",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常用api",children:"#"}),"常用API"]}),"\n",(0,c.jsxs)(n.p,{children:["插件可以用来修改输出文件和增加输出文件，甚至提升",(0,c.jsx)(n.code,{children:"Webpack"}),"性能"]}),"\n",(0,c.jsxs)(n.h4,{id:"读取输出资源代码块模块及依赖",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#读取输出资源代码块模块及依赖",children:"#"}),"读取输出资源、代码块、模块及依赖"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"emit"}),"事件发生时，代表源文件的转换和组装已经完成，可以读取到最终输出的资源、代码块、模块及其依赖，并修改输出资源的内容"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{})}),"\n",(0,c.jsxs)(n.h3,{id:"热更新原理",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#热更新原理",children:"#"}),"热更新原理"]}),"\n",(0,c.jsx)(n.p,{children:"SSE"})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,c.jsx)(n,Object.assign({},e,{children:(0,c.jsx)(s,e)})):s(e)}let l=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["engineering%2Fwebpack.md"]={toc:[{id:"工作原理",text:"工作原理",depth:2},{id:"基本概念",text:"基本概念",depth:3},{id:"流程",text:"流程",depth:3},{id:"模块module",text:"模块Module",depth:2},{id:"loader",text:"Loader",depth:2},{id:"基本写法",text:"基本写法",depth:3},{id:"可调用的webpack-api",text:"可调用的Webpack API",depth:3},{id:"获取loader的options",text:"获取`Loader`的`options`",depth:4},{id:"返回其他结果",text:"返回其他结果",depth:4},{id:"同步与异步",text:"同步与异步",depth:4},{id:"处理二进制数据",text:"处理二进制数据",depth:3},{id:"缓存加速",text:"缓存加速",depth:3},{id:"其他loader-api",text:"其他Loader API",depth:3},{id:"plugin",text:"Plugin",depth:2},{id:"compiler和compilation",text:"Compiler和Compilation",depth:3},{id:"tapable",text:"Tapable",depth:3},{id:"基本写法-1",text:"基本写法",depth:3},{id:"常用api",text:"常用API",depth:3},{id:"读取输出资源代码块模块及依赖",text:"读取输出资源、代码块、模块及依赖",depth:4},{id:"热更新原理",text:"热更新原理",depth:3}],title:"webpack",headingTitle:"webpack",frontmatter:{}}}}]);