"use strict";(self.webpackChunknote=self.webpackChunknote||[]).push([["7294"],{1576:function(e,n,r){r.r(n),r.d(n,{default:()=>t});var c=r(5893),d=r(65);function s(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",code:"code",h3:"h3",p:"p",ul:"ul",li:"li",pre:"pre",strong:"strong",em:"em"},(0,d.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"js拾遗",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#js拾遗",children:"#"}),"JS拾遗"]}),"\n",(0,c.jsxs)(n.h2,{id:"objectcreate详解",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#objectcreate详解",children:"#"}),(0,c.jsx)(n.code,{children:"Object.create"}),"详解"]}),"\n",(0,c.jsxs)(n.h3,{id:"objectcreate是什么",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#objectcreate是什么",children:"#"}),(0,c.jsx)(n.code,{children:"Object.create"}),"是什么"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Object.create"}),"的作用是使用指定的原型和属性来创建一个对象。有两个形参："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["指定的原型",(0,c.jsx)(n.code,{children:"proto"})]}),"\n",(0,c.jsxs)(n.li,{children:["一个可选参数",(0,c.jsx)(n.code,{children:"descriptors"}),"，属性描述符"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"Object.create(null) // {}\nObject.create({x: 0}, {\n    y: {value: 1, enumerable: true}\n}) // 相当于Object.defineProperties(Object.create(proto), descriptors)\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"objectcreatenull与的区别",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#objectcreatenull与的区别",children:"#"}),(0,c.jsx)(n.code,{children:"Object.create(null)"}),"与",(0,c.jsx)(n.code,{children:"{}"}),"的区别"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Object.create(null)"}),"不继承任何原型方法，",(0,c.jsx)(n.code,{children:"Object.create"}),"用于创建一个新对象，其中第一个参数为这个对象的原型，而由于",(0,c.jsx)(n.code,{children:"null"}),"没有原型，所以该方法不继承",(0,c.jsx)(n.code,{children:"Object.prototype"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["因此，",(0,c.jsx)(n.code,{children:"{}"}),"等同于",(0,c.jsx)(n.code,{children:"Object.create(Object.prototype)"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["可以用以下代码模拟",(0,c.jsx)(n.code,{children:"Object.create"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"Object.prototype.create = function(proto){\n    var fn = function(){};\n    \n    fn.prototype = proto;\n    \n    return new fn();\n}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"objectsetprototypeof",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#objectsetprototypeof",children:"#"}),(0,c.jsx)(n.code,{children:"Object.setPrototypeOf"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"ES6"}),"新增了",(0,c.jsx)(n.code,{children:"Object.setPrototypeOf"}),"，用于设置一个指定的对象的原型 ( 即内部",(0,c.jsx)(n.code,{children:"[[Prototype]]"}),"属性）到另一个对象或 ",(0,c.jsx)(n.code,{children:"null"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.code,{children:"Object.setPrototypeOf(obj, prototype)"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"`ployfill`\n// 仅适用于Chrome和FireFox，在IE中不工作：\nObject.setPrototypeOf = Object.setPrototypeOf || function (obj, proto) {\n  obj.__proto__ = proto;\n  return obj; \n}\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"new操作符模拟实现",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#new操作符模拟实现",children:"#"}),(0,c.jsx)(n.code,{children:"new"}),"操作符模拟实现"]}),"\n",(0,c.jsxs)(n.h3,{id:"new操作符都做了什么",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#new操作符都做了什么",children:"#"}),(0,c.jsx)(n.code,{children:"new"}),"操作符都做了什么："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"创建了一个全新的对象"}),"\n",(0,c.jsxs)(n.li,{children:["这个对象会被执行",(0,c.jsx)(n.code,{children:"[[Prototype]]"}),"（也就是",(0,c.jsx)(n.code,{children:"__proto__"}),"）链接"]}),"\n",(0,c.jsxs)(n.li,{children:["生成的新对象会绑定到函数调用的",(0,c.jsx)(n.code,{children:"this"})]}),"\n",(0,c.jsxs)(n.li,{children:["通过new创建的每个对象将最终被",(0,c.jsx)(n.code,{children:"[[Prototype]]"}),"链接到这个函数的",(0,c.jsx)(n.code,{children:"prototype"}),"对象上"]}),"\n",(0,c.jsxs)(n.li,{children:["如果函数没有返回对象类型",(0,c.jsx)(n.code,{children:"Object"}),"(包含",(0,c.jsx)(n.code,{children:"Functoin"}),", ",(0,c.jsx)(n.code,{children:"Array"}),", ",(0,c.jsx)(n.code,{children:"Date"}),", ",(0,c.jsx)(n.code,{children:"RegExg"}),", ",(0,c.jsx)(n.code,{children:"Error"}),")，那么",(0,c.jsx)(n.code,{children:"new"}),"表达式中的函数调用会自动返回这个新的对象"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function _new(ctor, ...arguments){\n    // ES6 new.target 是指向构造函数\n    _new.target = ctor;\n    \n    const instance = Object.create(ctor.prototype);\n    const ctorReturnResult = ctor.apply(instance, arguments);\n    \n    const isObject = typeof ctorReturnResult === 'object' && ctorReturnResult !== null\n    const isFunction = typeof ctorReturnResult === 'function'\n    \n    if(isObject || isFunction) return ctorReturnResult\n    \n    return instance\n}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"new操作符和objectcreate的区别",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#new操作符和objectcreate的区别",children:"#"}),(0,c.jsx)(n.code,{children:"new"}),"操作符和",(0,c.jsx)(n.code,{children:"Object.create"}),"的区别"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"new"}),"操作符将父类的属性和方法全都赋给子类"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Object.create"}),"只修改原型"]}),"\n",(0,c.jsxs)(n.h2,{id:"js继承",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#js继承",children:"#"}),(0,c.jsx)(n.code,{children:"JS"}),"继承"]}),"\n",(0,c.jsxs)(n.h3,{id:"原型链继承",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原型链继承",children:"#"}),"原型链继承"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"特点："})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"父类新增原型方法/原型属性，子类都能访问到"}),"\n",(0,c.jsx)(n.li,{children:"简单，易于实现"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"缺点："})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"无法实现多继承"}),"\n",(0,c.jsx)(n.li,{children:"来自原型对象的所有属性被所有实例共享"}),"\n",(0,c.jsx)(n.li,{children:"创建子类实例时，无法向父类构造函数传参"}),"\n",(0,c.jsxs)(n.li,{children:["要想为子类新增属性和方法，必须要在",(0,c.jsx)(n.code,{children:"inherits"}),"之后执行，不能放到构造器中"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function _inherits(Child, Parent){\n    Child.prototype = new Parent()\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"问题"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.em,{children:"父类的私有属性中有引用类型的属性，那它被子类继承的时候会作为公有属性，这样子类1操作这个属性的时候，就会影响到子类2。"})}),"\n",(0,c.jsxs)(n.h3,{id:"借用构造函数继承",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#借用构造函数继承",children:"#"}),"借用构造函数继承"]}),"\n",(0,c.jsxs)(n.p,{children:["在子类型构造函数中通用",(0,c.jsx)(n.code,{children:"call()"}),"调用父类型构造函数"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function Person(name, age) {\n    this.name = name,\n    this.age = age,\n    this.setName = function () {}\n}\n\nPerson.prototype.setAge = function () {}\nfunction Student(name, age, price) {\n    Person.call(this, name, age)  // 相当于: this.Person(name, age)\n    /*this.name = name\n    this.age = age*/\n    this.price = price\n}\nvar s1 = new Student('Tom', 20, 15000)\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"特点："})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"解决了原型链继承中子类实例共享父类引用属性的问题"}),"\n",(0,c.jsx)(n.li,{children:"创建子类实例时，可以向父类传递参数"}),"\n",(0,c.jsx)(n.li,{children:"可以实现多继承(call多个父类对象)"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"缺点："})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"实例并不是父类的实例，只是子类的实例"}),"\n",(0,c.jsx)(n.li,{children:"只能继承父类的实例属性和方法，不能继承原型属性和方法"}),"\n",(0,c.jsx)(n.li,{children:"无法实现函数复用，每个子类都有父类实例函数的副本，影响性能"}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"原型链借用构造函数的组合继承",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原型链借用构造函数的组合继承",children:"#"}),"原型链+借用构造函数的组合继承"]}),"\n",(0,c.jsx)(n.p,{children:"通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function Person (name, age) {\n  this.name = name,\n  this.age = age,\n  this.setAge = function () { }\n}\nPerson.prototype.setAge = function () {\n}\nfunction Student (name, age, price) {\n  Person.call(this, name, age)\n  this.price = price\n  this.setScore = function () { }\n}\nStudent.prototype = new Person()\nStudent.prototype.constructor = Student//组合继承也是需要修复构造函数指向的\nStudent.prototype.sayHello = function () { }\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"优点："})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"可以继承实例属性/方法，也可以继承原型属性/方法"}),"\n",(0,c.jsx)(n.li,{children:"不存在引用属性共享问题"}),"\n",(0,c.jsx)(n.li,{children:"可传参"}),"\n",(0,c.jsxs)(n.li,{children:["函数可复用\n",(0,c.jsx)(n.strong,{children:"缺点："}),"\n调用了两次父类构造函数，生成了两份实例"]}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"组合继承优化",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#组合继承优化",children:"#"}),"组合继承优化"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function Person (name, age) {\n  this.name = name,\n  this.age = age,\n  this.setAge = function () { }\n}\nPerson.prototype.setAge = function () {}\nfunction Student (name, age, price) {\n  Person.call(this, name, age)\n  this.price = price\n  this.setScore = function () { }\n}\nStudent.prototype = Person.prototype\nStudent.prototype.sayHello = function () { }\nvar s1 = new Student('Tom', 20, 15000)\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"优点："})}),"\n",(0,c.jsx)(n.p,{children:"不会初始化两次实例方法/属性，避免的组合继承的缺点"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"缺点："})}),"\n",(0,c.jsx)(n.p,{children:"没办法辨别是实例是子类还是父类创造的，子类和父类的构造函数指向是同一个。"}),"\n",(0,c.jsxs)(n.h3,{id:"组合继承优化2",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#组合继承优化2",children:"#"}),"组合继承优化2"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function Person (name, age) {\n  this.name = name,\n  this.age = age\n}\nPerson.prototype.setAge = function () {}\nfunction Student (name, age, price) {\n  Person.call(this, name, age)\n  this.price = price\n  this.setScore = function () { }\n}\nStudent.prototype = Object.create(Person.prototype)//核心代码\nStudent.prototype.constructor = Student//核心代码\nvar s1 = new Student('Tom', 20, 15000)\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"es6-extends",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#es6-extends",children:"#"}),(0,c.jsx)(n.code,{children:"ES6 extends"})]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"组合式继承"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function _inherits(Child, Parent){\n    // Object.create\n    Child.prototype = Object.create(Parent.prototype);\n    // __proto__\n    // Child.prototype.__proto__ = Parent.prototype;\n    Child.prototype.constructor = Child;\n    // ES6\n    // Object.setPrototypeOf(Child, Parent);\n    // __proto__\n    Child.__proto__ = Parent;\n}\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"null和undfined",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#null和undfined",children:"#"}),(0,c.jsx)(n.code,{children:"null"}),"和",(0,c.jsx)(n.code,{children:"undfined"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"null"}),"是",(0,c.jsx)(n.code,{children:"JavaScript"}),"的关键字，用来描述空值。因为",(0,c.jsx)(n.code,{children:'typeof null == "object"'}),"，可将",(0,c.jsx)(n.code,{children:"null"}),"不严谨的认为成一种特殊的对象，即非对象。这是是一个历史悠久的 ",(0,c.jsx)(n.code,{children:"bug"}),"，就是在",(0,c.jsx)(n.code,{children:"JS"}),"的最初版本中",(0,c.jsx)(n.code,{children:"null"}),"的内存存储信息是",(0,c.jsx)(n.code,{children:"000"}),"开头的，而",(0,c.jsx)(n.code,{children:"000"}),"开头的会被判断为",(0,c.jsx)(n.code,{children:"Object"}),"类型。"]}),"\n",(0,c.jsxs)(n.p,{children:["实际上，",(0,c.jsx)(n.code,{children:"null"}),"是",(0,c.jsx)(n.code,{children:"JavaScript"}),"的基本类型之一，表示数字、字符串、对象等是无值的。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"undefined"}),"用以表示更深层次的空值，即未定义。是变量的一种取值，表明变量未被初始化。若查询对象的属性，数组元素等返回",(0,c.jsx)(n.code,{children:"undefined"}),"，也说明属性或元素不存在。",(0,c.jsx)(n.code,{children:"undefined"}),"是预定义的全局变量，但不是",(0,c.jsx)(n.code,{children:"JavaScript"}),"关键字。在",(0,c.jsx)(n.code,{children:"ECMAScript 3"}),"中是可读写的，可以被赋予任何值，在",(0,c.jsx)(n.code,{children:"ECMAScript 5"}),"中是只读的。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"null == undefined"}),"为真，要严格判断需要用",(0,c.jsx)(n.code,{children:"==="}),"。另外，",(0,c.jsx)(n.code,{children:"null"}),"和",(0,c.jsx)(n.code,{children:"undefined"}),"都不包含任何属性和方法，也没有包装对象。"]}),"\n",(0,c.jsxs)(n.h2,{id:"不可变的原始值和可变的对象引用",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#不可变的原始值和可变的对象引用",children:"#"}),"不可变的原始值和可变的对象引用"]}),"\n",(0,c.jsxs)(n.p,{children:["JavaScript中的原始值（",(0,c.jsx)(n.code,{children:"undefined"}),"、",(0,c.jsx)(n.code,{children:"null"}),"、布尔值、数字和字符串）是不可更改的：任何方法都无法更改（或“突变”）一个原始值。",(0,c.jsx)(n.strong,{children:"字符串中所有的方法都会返回一个新的字符串值。"})]}),"\n",(0,c.jsxs)(n.p,{children:["原始值的比较是值的比较：只有在它们的值相等时它们才相等。比较两个字符串，当且仅当它们的长度相等且每个索引的字符都相等时，",(0,c.jsx)(n.code,{children:"JavaScript"}),"才认为它们相等。"]}),"\n",(0,c.jsxs)(n.p,{children:["对象的比较并非值的比较：即使两个对象包含同样的属性及相同的值，它们也是不相等的。同样，各个索引元素完全相等的两个数组也不相等。对象值都是引用（reference），对象的比较是引用的比较：",(0,c.jsx)(n.strong,{children:"当且仅当引用同一个基对象时才相等"}),"。因此，对象又被称为引用类型（referencetype），以此与基本类型做区分。"]}),"\n",(0,c.jsxs)(n.h2,{id:"javascript类型转换",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript类型转换",children:"#"}),(0,c.jsx)(n.code,{children:"JavaScript"}),"类型转换"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"转为布尔值"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"null"}),"、",(0,c.jsx)(n.code,{children:"undfined"}),"、",(0,c.jsx)(n.code,{children:'""'}),"、",(0,c.jsx)(n.code,{children:"0"}),"、",(0,c.jsx)(n.code,{children:"-0"}),"、",(0,c.jsx)(n.code,{children:"NaN"}),"这6个转为",(0,c.jsx)(n.code,{children:"false"}),"，其他的都会转为",(0,c.jsx)(n.code,{children:"true"}),"。",(0,c.jsx)(n.code,{children:"false"}),"又和这6个值被称为“假值”（falsy value），其他值称做“真值”（truthy value）。"]}),"\n",(0,c.jsxs)(n.p,{children:["包装对象也会被转换成",(0,c.jsx)(n.code,{children:"true"}),"，所以",(0,c.jsx)(n.code,{children:"new Boolean(false) == true"})]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"转为数字"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["以数字表示的字符串可以直接转换为数字，也允许在开始和结尾处带有空格，但有任意非空格字符的字符串都会转为",(0,c.jsx)(n.code,{children:"NaN"}),"。"]}),"\n",(0,c.jsxs)(n.li,{children:["空字符串",(0,c.jsx)(n.code,{children:'""'}),"会被转换为0"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"null"}),"转为0，",(0,c.jsx)(n.code,{children:"undefined"}),"转为",(0,c.jsx)(n.code,{children:"NaN"})]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"true"}),"转换为1，",(0,c.jsx)(n.code,{children:"false"}),"也会被转换为0"]}),"\n",(0,c.jsx)(n.li,{children:"空数组会被转换为0，只有一个数字元素的数组例如[2]或者其他唯一一个可以被会被转成数字的字符串，会被转换成对应的数字。而唯一的布尔值元素数组不会被转换为数字。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["通过",(0,c.jsx)(n.code,{children:"Number()"}),"将字符串转为数字时，只能基于十进制数进行转换，并且不能出现非法的尾随字符。",(0,c.jsx)(n.code,{children:"parseInt()"}),"和",(0,c.jsx)(n.code,{children:"parseFloat()"}),"都会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容，如果第一个非空格字符是非法的数字直接量，将返回NaN。另外，",(0,c.jsx)(n.code,{children:"parseInt()"}),"可以接收第二个可选参数，这个参数指定数字转换的基数，合法的取值范围是2～36。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"转为对象"})}),"\n",(0,c.jsxs)(n.p,{children:["如果试图把",(0,c.jsx)(n.code,{children:"null"}),"或",(0,c.jsx)(n.code,{children:"undefined"}),"转换为对象会抛出一个类型错误（TypeError）。Object()函数在这种情况下不会抛出异常：仅简单地返回一个新创建的空对象。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"转为字符串"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Number"}),"类的",(0,c.jsx)(n.code,{children:"toString()"}),"方法可以接收表示转换基数（radix）的可选参数，如果不指定，默认转换成十进制。进制基数范围应该在2～36之间。"]}),"\n",(0,c.jsxs)(n.p,{children:["数字转字符串需要控制小数点的有效数字位数时，可用以下三个方法。",(0,c.jsx)(n.code,{children:"toFixed()"}),"任何时候都不会使用指数记数法；",(0,c.jsx)(n.code,{children:"toExponential()"}),"则将数字转换为指数形式的字符串，其中小数点前只有一位，小数点后的位数则由参数指定；",(0,c.jsx)(n.code,{children:"toPrecision()"}),"根据指定的有效数字位数将数字转换成字符串。这三个方法都会适当地进行四舍五入或者填充0。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"对象转换为原始值"})}),"\n",(0,c.jsxs)(n.p,{children:["对象到字符串（object-to-string）和对象到数字（object-to-number）的转换是通过调用待转换对象的",(0,c.jsx)(n.code,{children:"toString"}),"方法或valueOf方法来完成的。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.em,{children:(0,c.jsx)(n.code,{children:"toString"})})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["对象默认的toString方法返回一个反映这个对象的字符串",(0,c.jsx)(n.code,{children:' "[object Object]"'}),"。"]}),"\n",(0,c.jsxs)(n.li,{children:["数组的",(0,c.jsx)(n.code,{children:"toString"}),"方法将每个数组元素转换为一个字符串，其接受一个参数定义分隔符，默认值是逗号",(0,c.jsx)(n.code,{children:","}),"。具体实现就是由数组中的每个元素的",(0,c.jsx)(n.code,{children:"toString"}),"返回值经调用",(0,c.jsx)(n.code,{children:"join"})," 方法连接（由逗号隔开）组成。"]}),"\n",(0,c.jsxs)(n.li,{children:["函数",(0,c.jsx)(n.code,{children:"toString"}),"方法返回函数的",(0,c.jsx)(n.code,{children:"JavaScript"}),"源代码字符串。"]}),"\n",(0,c.jsxs)(n.li,{children:["日期的",(0,c.jsx)(n.code,{children:"toString"}),"方法返回一个可读的（可被",(0,c.jsx)(n.code,{children:"JavaScript"}),"解析的）日期和时间字符串。"]}),"\n",(0,c.jsxs)(n.li,{children:["RegExp类的",(0,c.jsx)(n.code,{children:"toString"}),"方法返回表示正则表达式直接量的字符串。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.em,{children:(0,c.jsx)(n.code,{children:"valueOf"})})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"valueOf"}),"方法主要作用是，如果存在任意原始值，就将其转换为表示它的原始值。对象默认的",(0,c.jsx)(n.code,{children:"valueOf"}),"方法简单地返回对象本身。数组、函数和正则表达式等与之相同。只有日期类不同，",(0,c.jsx)(n.code,{children:"valueOf"}),"方法会返回一个内部表示：1970年1月1日以来的毫秒数。"]}),"\n",(0,c.jsxs)(n.p,{children:["鉴于日期类的特殊性，运算符",(0,c.jsx)(n.code,{children:"+"}),"、==、!=和比较运算符，需要同类型，所以在需要转化成数字的情况下，会调用日期类的",(0,c.jsx)(n.code,{children:"toString"}),"方法，需要数字的情况下调用",(0,c.jsx)(n.code,{children:"valueOf"}),"方法。其他运算符的类型转换都是决定的"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"1 + new Date() //调用toString\nnew Date() + 1  //调用toString\n+ new Date() //调用valueOf\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"作为属性的变量",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#作为属性的变量",children:"#"}),"作为属性的变量"]}),"\n",(0,c.jsx)(n.p,{children:"当声明一个JavaScript全局变量时，实际上是定义了全局对象的一个属性"}),"\n",(0,c.jsx)(n.p,{children:"命名函数的函数名在该函数内部是一个常量，不能被再次赋值，再次赋值时，严格模式下会报错，非严格模式下会静默失败。"}),"\n",(0,c.jsxs)(n.h2,{id:"严格判断数组",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#严格判断数组",children:"#"}),"严格判断数组"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Array.isArray()"}),"是ES5的方法，可以用",(0,c.jsx)(n.code,{children:"Object.prototype.toString.call(arr) === '[object Array]'"}),"来进行polyfill。"]}),"\n",(0,c.jsxs)(n.h2,{id:"instanceof",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#instanceof",children:"#"}),(0,c.jsx)(n.code,{children:"instanceof"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"instanceof"}),"通过判断对象的原型链中是不是能找到类型的 ",(0,c.jsx)(n.code,{children:"prototype"}),"。",(0,c.jsx)(n.code,{children:"instanceof"}),"的右侧必须为一个对象，否则会报错"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"'' instanceof String; // false 检查原型链会找到 undefined\n[]  instanceof Array; // true\n[]  instanceof Object; //true\n\nvar myString  = new String();\nvar newStr    = new String(\"String created with constructor\");\nvar myDate    = new Date();\nvar myObj     = {};\nvar myNonObj  = Object.create(null);\n\nmyDate instanceof Object;   // 返回 true\nmyNonObj instanceof Object; // 返回 false, 一种创建非 Object 实例的对象的方法\n"})}),"\n",(0,c.jsx)(n.p,{children:"怪异的是："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"Function instanceof Object // true\nObject instanceof Function // true\n"})}),"\n",(0,c.jsxs)(n.p,{children:["并且",(0,c.jsx)(n.code,{children:"instanceof"}),"无法跨",(0,c.jsx)(n.code,{children:"iframes"}),"判断数组："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"var iframe = document.createElement('iframe');\ndocument.body.appendChild(iframe);\nxArray = window.frames[window.frames.length-1].Array;\nvar arr = new xArray(1,2,3); // [1,2,3]\n\n// Correctly checking for Array\nArray.isArray(arr);  // true\nObject.prototype.toString.call(arr); // true\n// Considered harmful, because doesn't work though iframes\narr instanceof Array; // false\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"存取器属性",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#存取器属性",children:"#"}),"存取器属性"]}),"\n",(0,c.jsx)(n.p,{children:"对象的属性有数据属性和存取器属性两种："}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"数据属性"}),"，包含的一个数据值的位置，可以对数据值进行读写。包含四个特性："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"configurable"}),": 表示属性是否可配置，即能否通过",(0,c.jsx)(n.code,{children:"delete"}),"删除属性从而重新定义属性，能否修改属性的特性，或能否把属性修改为访问器属性，默认为true"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"enumerable"}),": 可枚举性，表示能否通过",(0,c.jsx)(n.code,{children:"for-in"}),"循环返回属性"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"writable"}),"：可写性，表示能否修改属性的值"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"value"}),": 包含该属性的数据值。默认为undefined"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"存取器属性"}),"，",(0,c.jsx)(n.code,{children:"accessor property"}),"，又称访问器属性，不同于数据属性，包含的是一对",(0,c.jsx)(n.code,{children:"get"}),"和",(0,c.jsx)(n.code,{children:"set"}),"方法。在读取属性时调用",(0,c.jsx)(n.code,{children:"get"}),"函数，在写入属性时调用",(0,c.jsx)(n.code,{children:"set"}),"函数，因此",(0,c.jsx)(n.code,{children:"get"}),"和",(0,c.jsx)(n.code,{children:"set"}),"方法分别代替了数据属性的",(0,c.jsx)(n.code,{children:"value"}),"和",(0,c.jsx)(n.code,{children:"writable"}),"特性"]}),"\n",(0,c.jsxs)(n.h2,{id:"函数的length属性与argumentslength",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#函数的length属性与argumentslength",children:"#"}),"函数的length属性与arguments.length"]}),"\n",(0,c.jsxs)(n.p,{children:["函数的",(0,c.jsx)(n.code,{children:"length"}),"属性指函数定义时所声明的形参的个数，而",(0,c.jsx)(n.code,{children:"arguments.length"}),"表示的是函数调用时，实参的个数。"]}),"\n",(0,c.jsx)(n.p,{children:"实际调用函数时，传入的参数的个数可以比形参的个数少，也可以比它多。"})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,c.jsx)(n,Object.assign({},e,{children:(0,c.jsx)(s,e)})):s(e)}let t=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["javascript%2Fomission.md"]={toc:[{id:"objectcreate详解",text:"`Object.create`详解",depth:2},{id:"objectcreate是什么",text:"`Object.create`是什么",depth:3},{id:"objectcreatenull与的区别",text:"`Object.create(null)`与`{}`的区别",depth:3},{id:"objectsetprototypeof",text:"`Object.setPrototypeOf`",depth:3},{id:"new操作符模拟实现",text:"`new`操作符模拟实现",depth:2},{id:"new操作符都做了什么",text:"`new`操作符都做了什么：",depth:3},{id:"new操作符和objectcreate的区别",text:"`new`操作符和`Object.create`的区别",depth:3},{id:"js继承",text:"`JS`继承",depth:2},{id:"原型链继承",text:"原型链继承",depth:3},{id:"借用构造函数继承",text:"借用构造函数继承",depth:3},{id:"原型链借用构造函数的组合继承",text:"原型链+借用构造函数的组合继承",depth:3},{id:"组合继承优化",text:"组合继承优化",depth:3},{id:"组合继承优化2",text:"组合继承优化2",depth:3},{id:"es6-extends",text:"`ES6 extends`",depth:3},{id:"null和undfined",text:"`null`和`undfined`",depth:2},{id:"不可变的原始值和可变的对象引用",text:"不可变的原始值和可变的对象引用",depth:2},{id:"javascript类型转换",text:"`JavaScript`类型转换",depth:2},{id:"作为属性的变量",text:"作为属性的变量",depth:2},{id:"严格判断数组",text:"严格判断数组",depth:2},{id:"instanceof",text:"`instanceof`",depth:2},{id:"存取器属性",text:"存取器属性",depth:2},{id:"函数的length属性与argumentslength",text:"函数的length属性与arguments.length",depth:2}],title:"JS拾遗",headingTitle:"JS拾遗",frontmatter:{}}}}]);