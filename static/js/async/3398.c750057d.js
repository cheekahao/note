"use strict";(self.webpackChunknote=self.webpackChunknote||[]).push([["3398"],{3904:function(e,n,r){r.r(n),r.d(n,{default:()=>a});var c=r(5893),i=r(65);function s(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",ul:"ul",li:"li",h3:"h3",pre:"pre",ol:"ol",strong:"strong"},(0,i.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"react原理",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react原理",children:"#"}),"React原理"]}),"\n",(0,c.jsxs)(n.h2,{id:"前端框架原理概览",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前端框架原理概览",children:"#"}),"前端框架原理概览"]}),"\n",(0,c.jsxs)(n.p,{children:["现代前端框架的实现原理：",(0,c.jsx)(n.code,{children:"UI=f(state)"}),"，框架内部运行机制根据当前状态渲染视图。"]}),"\n",(0,c.jsx)(n.p,{children:"其中："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"state"}),"代表当前视图状态"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"f"}),"代表框架内部运行机制"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"UI"}),"代表宿主环境的视图"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["为了实现",(0,c.jsx)(n.code,{children:"UI"}),"与逻辑的关注点分离，需要一种存放 ",(0,c.jsx)(n.code,{children:"UI"}),"与逻辑的松散耦合单元，这就是组件。\n组件通过是那种方式组织逻辑与 ",(0,c.jsx)(n.code,{children:"UI"}),"："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["逻辑中的自变量变化，导致",(0,c.jsx)(n.code,{children:"UI"}),"变化"]}),"\n",(0,c.jsxs)(n.li,{children:["逻辑中的自变量变化，导致“无副作用因变量”变化，导致 ",(0,c.jsx)(n.code,{children:"UI"}),"变化，例如",(0,c.jsx)(n.code,{children:"useMemo"}),"，",(0,c.jsx)(n.code,{children:"computed"}),"等"]}),"\n",(0,c.jsxs)(n.li,{children:["逻辑中的自变量变化，导致“有副作用因变量”变化，导致副作用，例如",(0,c.jsx)(n.code,{children:"useEffect"}),"，",(0,c.jsx)(n.code,{children:"watchEffect"}),"，",(0,c.jsx)(n.code,{children:"autorun"}),"等"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["在前端框架中，组件内部定义的自变量被称为",(0,c.jsx)(n.code,{children:"state"}),"(状态)，其他组件传递而来的自变量成为",(0,c.jsx)(n.code,{children:"props"}),"(属性)。当自变量需要跨层级传递时，可以通过",(0,c.jsx)(n.code,{children:"store"}),"实现。React 主要通过",(0,c.jsx)(n.code,{children:"Context"}),"实现。"]}),"\n",(0,c.jsx)(n.p,{children:"前端框架可以根据与自变量建立对应关系的抽象层级分为以下三类："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["应用级框架，如",(0,c.jsx)(n.code,{children:"React"})]}),"\n",(0,c.jsxs)(n.li,{children:["组件级框架，如",(0,c.jsx)(n.code,{children:"Vue"})]}),"\n",(0,c.jsxs)(n.li,{children:["元素级框架，如",(0,c.jsx)(n.code,{children:"Svelte"})]}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"react16-架构",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react16-架构",children:"#"}),"React16 架构"]}),"\n",(0,c.jsx)(n.p,{children:"相较于 React15，React16 中新增了Scheduler（调度器），分为以下三层："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler"}),"\n",(0,c.jsx)(n.li,{children:"Reconciler（协调器）—— 负责找出变化的组件"}),"\n",(0,c.jsx)(n.li,{children:"Renderer（渲染器）—— 负责将变化的组件渲染到页面上"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"在 React 工作流程中："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Reconciler工作的阶段被称为render阶段。因为在该阶段会调用组件的render方法"}),"\n",(0,c.jsx)(n.li,{children:"Renderer工作的阶段被称为commit阶段。就像你完成一个需求的编码后执行git commit提交代码。commit阶段会把render阶段提交的信息渲染在页面上"}),"\n",(0,c.jsx)(n.li,{children:"render与commit阶段统称为work，即React在工作中。相对应的，如果任务正在Scheduler内调度，就不属于work"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"react理念",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react理念",children:"#"}),"React理念"]}),"\n",(0,c.jsx)(n.p,{children:"React使用JavaScript构建快速响应的大型 Web应用程序的首选方式。"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"CPU瓶颈，当执行大计算量的操作或者设备性能不足时，页面掉帧，导致卡顿"}),"\n",(0,c.jsx)(n.li,{children:"I/O 瓶颈，进行I/O操作后需要等待数据返回才能继续操作，等待的过程导致不能快速响应"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"React的发展阶段："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Sync同步模式"}),"\n",(0,c.jsx)(n.li,{children:"Async Mode异步模式"}),"\n",(0,c.jsx)(n.li,{children:"Concurrent Mode并发模式"}),"\n",(0,c.jsx)(n.li,{children:"Concurrent Feature并发特性"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"React各版本重要更新点"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"React 16将同步的不可中断的递归渲染重构为异步的、可中断的链表遍历，为后续的并发特性打下基础"}),"\n",(0,c.jsx)(n.li,{children:"Reat 17通过重构事件系统等底层，为React 18的并发更新以及大型应用的渐进式升级铺平道路，确保生态的平稳过渡"}),"\n",(0,c.jsx)(n.li,{children:"React 18引入并发渲染（Concurrent Rendering），允许React同时准备多个版本的UI，并能根据优先级中断或继续渲染。新增了startTransition（保持UI响应）和Suspense SSR（流式页面加载）等强大功能"}),"\n",(0,c.jsx)(n.li,{children:"React 19专注于提升开发体验。通过Actions等特性，将数据变更、表单处理、乐观更新等常见场景进行抽象和简化，支持更声明式、更少的代码来完成更多工作"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"react-reconciler的-render阶段",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react-reconciler的-render阶段",children:"#"}),"React Reconciler的 render阶段"]}),"\n",(0,c.jsx)(n.p,{children:"Reconciler的工作流程主要是采用 DFS(深度优先遍历)的顺序构建 Wip Fiber Tree，主要分为“递”beginWork和“归”completeWork 两个阶段："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"beginWork根据当前 fiberNode 创建下一级fiberNode，在 update时标记 Placement(新增、移动)、ChildDeletion(删除)。"}),"\n",(0,c.jsx)(n.li,{children:"completeWork在 mount时构建 DOM Tree, 初始化属性，在 update时标记 Update(属性更新)，最终执行 flags冒泡。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"最终 HostRootFiber完成completeWork后，Reconciler的工作流程结束，可以得到："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"代表本次更新的Wip Fiber Tree"}),"\n",(0,c.jsx)(n.li,{children:"被标记的 flags"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"HostRootFiber对应的 FiberRootNode传递给 Renderer进行 commit阶段的工作"}),"\n",(0,c.jsxs)(n.h2,{id:"react--renderer的commit阶段",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react--renderer的commit阶段",children:"#"}),"React  Renderer的commit阶段"]}),"\n",(0,c.jsx)(n.p,{children:"commit阶段始于React Reconciler的commitRoot方法，是同步执行，不可打断的。有三个子阶段："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"BeforeMutation 阶段"}),"\n",(0,c.jsx)(n.li,{children:"Mutation 阶段"}),"\n",(0,c.jsx)(n.li,{children:"Layout 阶段"}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"beforemutation-阶段",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#beforemutation-阶段",children:"#"}),"BeforeMutation 阶段"]}),"\n",(0,c.jsx)(n.p,{children:"主要处理以下两种类型的 FiberNode:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"ClassComponent，执行 getSnapshowBeforeUpdate方法"}),"\n",(0,c.jsx)(n.li,{children:"HostRoot，清空挂载内容，方便Mutation阶段渲染"}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"mutation-阶段",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mutation-阶段",children:"#"}),"Mutation 阶段"]}),"\n",(0,c.jsx)(n.p,{children:"在 react-dom 中，对于HostComponent，主要进行 DOM 元素的增、删、改操作。其他类型的Component处理与组件相关的副作用和生命周期。"}),"\n",(0,c.jsx)(n.p,{children:"主要包括："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"副作用处理：\n○ 处理函数组件的useEffect和useLayoutEffect的清理函数\n○ 处理类组件的componentWillUnmount 生命周期"}),"\n",(0,c.jsx)(n.li,{children:"Ref 处理\n○ 从 DOM 中移除 ref\n○ 从组件实例中移除 ref"}),"\n",(0,c.jsx)(n.li,{children:"子组件遍历\n○ 递归处理子组件的变更\n另外，当Mutation阶段的主要工作完成之后，会进行 Fiber Tree的切换"}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"layout-阶段",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#layout-阶段",children:"#"}),"Layout 阶段"]}),"\n",(0,c.jsx)(n.p,{children:"Layout 阶段在DOM已经被修改之后，在浏览器绘制之前。所有Layout的副作用都是同步调用的，不会被延迟或打断。"}),"\n",(0,c.jsx)(n.p,{children:"目的是为了允许开发者在 DOM 变更后、用户看到更新前、读取 DOM布局信息或执行必须同步完成的操作。"}),"\n",(0,c.jsx)(n.p,{children:"Layout阶段向下遍历过程中，会执行 OffscreenComponent的显隐逻辑。"}),"\n",(0,c.jsx)(n.p,{children:"向上遍历过程中，会根据 fiberNode.tag 不同执行不同操作："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"对于 ClassComponent，执行 componentDidMount/Update 方法"}),"\n",(0,c.jsx)(n.li,{children:"对于 FC，执行 useLayoutEffect callback"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"react-scheduler",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react-scheduler",children:"#"}),"React Scheduler"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Scheduler"}),"预置了五种优先级："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"ImmediatePriority"}),"立即执行, 优先级最高，同步执行"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"UserBlockingPriority"}),"用户阻塞"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"NormalPriority"}),"正常执行"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"LowPriority"}),"低优先级"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"IdlePriority"}),"空闲时执行"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Scheduler"}),"调度的主要数据结构为",(0,c.jsx)(n.code,{children:"Task"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:"type Callback = boolean => ?Callback\n\ntype Task = {\n  id: number;\n  callback: Callback;\n  priority: PriorityLevel;\n  startTime: number;\n  expirationTime: number;\n};\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"scheduler的执行流程",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#scheduler的执行流程",children:"#"}),(0,c.jsx)(n.code,{children:"Scheduler"}),"的执行流程"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Scheduler"}),"的执行流程如下："]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["根据是否传递",(0,c.jsx)(n.code,{children:"delay"}),"参数，执行",(0,c.jsx)(n.code,{children:"scheduleCallback"}),"方法后生产的",(0,c.jsx)(n.code,{children:"task"}),"会进入",(0,c.jsx)(n.code,{children:"timerQueue"}),"或",(0,c.jsx)(n.code,{children:"taskQueue"}),", 其中"]}),"\n"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"timerQueue"}),"中的",(0,c.jsx)(n.code,{children:"task"}),"以",(0,c.jsx)(n.code,{children:"currentTime + delay"}),"为排序依据"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"taskQueue"}),"中的",(0,c.jsx)(n.code,{children:"task"}),"以",(0,c.jsx)(n.code,{children:"expirationTime"}),"为排序依据"]}),"\n"]}),"\n",(0,c.jsxs)(n.ol,{start:"2",children:["\n",(0,c.jsxs)(n.li,{children:["当",(0,c.jsx)(n.code,{children:"timerQueue"}),"中第一个",(0,c.jsx)(n.code,{children:"task"}),"延时时间到期后，执行",(0,c.jsx)(n.code,{children:"advanceTimers"}),"将其移动到",(0,c.jsx)(n.code,{children:"taskQueue"}),"中"]}),"\n",(0,c.jsxs)(n.li,{children:["执行",(0,c.jsx)(n.code,{children:"requestHostCallback"}),"在新的宏任务中执行",(0,c.jsx)(n.code,{children:"workLoop"}),"方法"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"workLoop"}),"方法循环消费",(0,c.jsx)(n.code,{children:"taskQueue"}),"中的",(0,c.jsx)(n.code,{children:"task"}),"（即执行",(0,c.jsx)(n.code,{children:"task.callback"}),"）, 直到",(0,c.jsx)(n.code,{children:"taskQueue"}),"为空或",(0,c.jsx)(n.code,{children:"Time Slice"}),"时间用尽且当前",(0,c.jsx)(n.code,{children:"task"}),"未过期(",(0,c.jsx)(n.code,{children:"currentTask.expirationTime > currentTime"}),")时中断循环"]}),"\n",(0,c.jsxs)(n.li,{children:["如果",(0,c.jsx)(n.code,{children:"taskQueue"}),"不为空，则进入步骤3，如果",(0,c.jsx)(n.code,{children:"timerQueue"}),"不为空，则进入步骤2"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"workLoop"}),"执行的时机选择，在支持",(0,c.jsx)(n.code,{children:"setImmediate"}),"的环境下使用",(0,c.jsx)(n.code,{children:"setImmediate"}),"，在支持",(0,c.jsx)(n.code,{children:"MessageChannel"}),"的环境下使用",(0,c.jsx)(n.code,{children:"MessageChannel"}),"，在不支持以上两种环境下使用",(0,c.jsx)(n.code,{children:"setTimeout"}),"。"]}),"\n",(0,c.jsxs)(n.h3,{id:"优先级队列",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#优先级队列",children:"#"}),"优先级队列"]}),"\n",(0,c.jsx)(n.p,{children:"优先级队列使用的数据结构为小顶堆，其特点是："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"是一个完全二叉树（除最后一层外，其他层的节点个数都是满的，且最后一层的节点都靠左填充）"}),"\n",(0,c.jsx)(n.li,{children:"堆中每个节点的值都小于等于其子树的每一个节点的值"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"完全二叉树适合用数组保存，用数组下标代替指向左右节点的指针。"}),"\n",(0,c.jsx)(n.p,{children:"堆包含以下三个方法："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"push"}),"向堆中推入元素"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"pop"}),"从堆顶取出元素"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"peek"}),"获取排序依据最小的对应节点"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"push"}),"和",(0,c.jsx)(n.code,{children:"pop"}),"方法都涉及堆化操作，即在插入、取出节点时对堆重新排序。堆化操作的时间复杂度与二叉树的高度正相关，为",(0,c.jsx)(n.code,{children:"O(log n)"}),"。"]}),"\n",(0,c.jsxs)(n.h2,{id:"react-lane模型",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react-lane模型",children:"#"}),"React Lane模型"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"React"}),"的",(0,c.jsx)(n.strong,{children:"Lane模型"}),"是并发调度系统",(0,c.jsx)(n.code,{children:"Concurrent Mode"}),"的核心组成部分，借鉴了操作系统中常见的优先级调度思想，通过将更新任务抽象为",(0,c.jsx)(n.strong,{children:"车道"}),(0,c.jsx)(n.code,{children:"Lane"}),"，实现了对不同优先级任务的灵活调度与中断恢复机制。"]}),"\n",(0,c.jsxs)(n.h3,{id:"lane优先级",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#lane优先级",children:"#"}),"Lane优先级"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Lane"}),"是一个",(0,c.jsx)(n.code,{children:"32bit Integer"}),"，最高位为符号位，总共有31个不同的优先级，越低的位优先级越高。具体如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:"export const SyncHydrationLane: Lane = /*               */ 0b0000000000000000000000000000001;\nexport const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000010;\nexport const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000100;\nexport const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000001000;\nexport const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000010000;\nexport const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000100000;\nexport const GestureLane: Lane = /*                     */ 0b0000000000000000000000001000000;\nconst TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000010000000;\n// 总共 14 个TransitionLane\nconst TransitionLane1: Lane = /*                        */ 0b0000000000000000000000100000000;\nconst TransitionLane2: Lane = /*                        */ 0b0000000000000000000001000000000;\nconst TransitionLane3: Lane = /*                        */ 0b0000000000000000000010000000000;\nconst TransitionLane4: Lane = /*                        */ 0b0000000000000000000100000000000;\nconst TransitionLane5: Lane = /*                        */ 0b0000000000000000001000000000000;\nconst TransitionLane6: Lane = /*                        */ 0b0000000000000000010000000000000;\nconst TransitionLane7: Lane = /*                        */ 0b0000000000000000100000000000000;\nconst TransitionLane8: Lane = /*                        */ 0b0000000000000001000000000000000;\nconst TransitionLane9: Lane = /*                        */ 0b0000000000000010000000000000000;\nconst TransitionLane10: Lane = /*                       */ 0b0000000000000100000000000000000;\nconst TransitionLane11: Lane = /*                       */ 0b0000000000001000000000000000000;\nconst TransitionLane12: Lane = /*                       */ 0b0000000000010000000000000000000;\nconst TransitionLane13: Lane = /*                       */ 0b0000000000100000000000000000000;\nconst TransitionLane14: Lane = /*                       */ 0b0000000001000000000000000000000;\n// 总共 4 个RetryLane\nconst RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000;\nconst RetryLane2: Lane = /*                             */ 0b0000000100000000000000000000000;\nconst RetryLane3: Lane = /*                             */ 0b0000001000000000000000000000000;\nconst RetryLane4: Lane = /*                             */ 0b0000010000000000000000000000000;\nexport const SelectiveHydrationLane: Lane = /*          */ 0b0000100000000000000000000000000;\nexport const IdleHydrationLane: Lane = /*               */ 0b0001000000000000000000000000000;\nexport const IdleLane: Lane = /*                        */ 0b0010000000000000000000000000000;\nexport const OffscreenLane: Lane = /*                   */ 0b0100000000000000000000000000000;\nexport const DeferredLane: Lane = /*                    */ 0b1000000000000000000000000000000;\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Lanes"}),"代表一个或者多个",(0,c.jsx)(n.code,{children:"Lane"}),"的集合。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"export const SyncUpdateLanes: Lane =\n  SyncLane | InputContinuousLane | DefaultLane;\nconst TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111100000000;\nconst TransitionUpdateLanes =\n  TransitionLane1 |\n  TransitionLane2 |\n  TransitionLane3 |\n  TransitionLane4 |\n  TransitionLane5 |\n  TransitionLane6 |\n  TransitionLane7 |\n  TransitionLane8 |\n  TransitionLane9 |\n  TransitionLane10;\nconst TransitionDeferredLanes =\n  TransitionLane11 | TransitionLane12 | TransitionLane13 | TransitionLane14;\n\nconst RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000;\nconst NonIdleLanes: Lanes = /*                          */ 0b0000111111111111111111111111111;\n"})})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,c.jsx)(n,Object.assign({},e,{children:(0,c.jsx)(s,e)})):s(e)}let a=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["framework%2Freact%2Fsource.md"]={toc:[{id:"前端框架原理概览",text:"前端框架原理概览",depth:2},{id:"react16-架构",text:"React16 架构",depth:2},{id:"react理念",text:"React理念",depth:2},{id:"react-reconciler的-render阶段",text:"React Reconciler的 render阶段",depth:2},{id:"react--renderer的commit阶段",text:"React  Renderer的commit阶段",depth:2},{id:"beforemutation-阶段",text:"BeforeMutation 阶段",depth:3},{id:"mutation-阶段",text:"Mutation 阶段",depth:3},{id:"layout-阶段",text:"Layout 阶段",depth:3},{id:"react-scheduler",text:"React Scheduler",depth:2},{id:"scheduler的执行流程",text:"`Scheduler`的执行流程",depth:3},{id:"优先级队列",text:"优先级队列",depth:3},{id:"react-lane模型",text:"React Lane模型",depth:2},{id:"lane优先级",text:"Lane优先级",depth:3}],title:"React原理",headingTitle:"React原理",frontmatter:{}}}}]);