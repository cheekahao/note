"use strict";(self.webpackChunknote=self.webpackChunknote||[]).push([["1120"],{1130:function(e,n,c){c.r(n),c.d(n,{default:()=>o});var d=c(5893),s=c(65);function r(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",ul:"ul",li:"li",h3:"h3",pre:"pre",strong:"strong"},(0,s.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.h1,{id:"react",children:[(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react",children:"#"}),"React"]}),"\n",(0,d.jsxs)(n.h2,{id:"组件",children:[(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#组件",children:"#"}),"组件"]}),"\n",(0,d.jsxs)(n.p,{children:["组件允许你将",(0,d.jsx)(n.code,{children:"UI"}),"拆分为独立可复用的代码片段，并对每个片段进行独立构思。"]}),"\n",(0,d.jsxs)(n.p,{children:["组件，从概念上类似于",(0,d.jsx)(n.code,{children:"JavaScript"}),"函数。它接受任意的入参",(0,d.jsx)(n.code,{children:"props"}),"，并返回用于描述页面展示内容的",(0,d.jsx)(n.code,{children:"React"}),"元素。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"React"}),"组件分为函数组件与",(0,d.jsx)(n.code,{children:"class"}),"组件。"]}),"\n",(0,d.jsxs)(n.h2,{id:"hook",children:[(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#hook",children:"#"}),"Hook"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"Hook"}),"是",(0,d.jsx)(n.code,{children:"React"}),"16.8 的新增特性。可以在不编写",(0,d.jsx)(n.code,{children:"class"}),"的情况下使用",(0,d.jsx)(n.code,{children:"state"}),"以及其他的",(0,d.jsx)(n.code,{children:"React"}),"特性。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"Hook"}),"为已知的",(0,d.jsx)(n.code,{children:"React"}),"概念提供了更直接的",(0,d.jsx)(n.code,{children:"API"}),"：",(0,d.jsx)(n.code,{children:"props"}),"， ",(0,d.jsx)(n.code,{children:"state"}),"，",(0,d.jsx)(n.code,{children:"context"}),"，",(0,d.jsx)(n.code,{children:"refs"}),"以及生命周期。"]}),"\n",(0,d.jsxs)(n.p,{children:["可以使用",(0,d.jsx)(n.code,{children:"Hook"}),"从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。",(0,d.jsx)(n.code,{children:"Hook"}),"可以在无需修改组件结构的情况下复用状态逻辑。这使得在组件间或社区内共享",(0,d.jsx)(n.code,{children:"Hook"}),"变得更便捷。"]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"利于组件预编译，更易于优化"}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"class"}),"组件会无意中鼓励开发者使用一些让优化措施无效的方案"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"class"}),"不能很好的压缩，并且会使热重载出现不稳定的情况"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"Hook"}),"是一些可以让你在函数组件里“钩入”",(0,d.jsx)(n.code,{children:"React state"}),"及生命周期等特性的函数。"]}),"\n",(0,d.jsxs)(n.h3,{id:"state-hook",children:[(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#state-hook",children:"#"}),(0,d.jsx)(n.code,{children:"State Hook"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"useState"}),"通过在函数组件里调用它来给组件添加一些内部 ",(0,d.jsx)(n.code,{children:"state"}),"。",(0,d.jsx)(n.code,{children:"React"}),"会在重复渲染时保留这个",(0,d.jsx)(n.code,{children:"state"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:["不同于 class 组件",(0,d.jsx)(n.code,{children:"state"}),"必须为一个对象，",(0,d.jsx)(n.code,{children:"useState"}),"可以接受一个基本类型，也可以接受引用类型。"]}),"\n",(0,d.jsxs)(n.p,{children:["返回一对值：当前状态",(0,d.jsx)(n.code,{children:"state"}),"和一个可以更新它的函数",(0,d.jsx)(n.code,{children:"setState"}),"，可以在事件处理函数中或其他一些地方调用这个函数。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"useState"}),"类似于",(0,d.jsx)(n.code,{children:"class"}),"组件的",(0,d.jsx)(n.code,{children:"this.setState"}),"，但是它不会把新的",(0,d.jsx)(n.code,{children:"state"}),"和旧的",(0,d.jsx)(n.code,{children:"state"}),"进行合并。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"state"}),"不一定要是一个对象，且这个初始",(0,d.jsx)(n.code,{children:"state"}),"参数只有在第一次渲染时会被用到"]}),"\n",(0,d.jsx)(n.p,{children:"具体示例如下："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-jsx",children:'import React, { useState } from "react";\n\nfunction Example() {\n  // 声明一个叫 “count” 的 state 变量。\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}\n'})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"React"}),"假设当你多次调用",(0,d.jsx)(n.code,{children:"useState"}),"的时候，你能保证每次渲染时它们的调用顺序是不变的"]}),"\n",(0,d.jsxs)(n.h3,{id:"effect-hook",children:[(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#effect-hook",children:"#"}),(0,d.jsx)(n.code,{children:"Effect Hook"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"Effect Hook"}),"可以让你在函数组件中执行副作用操作，类似于",(0,d.jsx)(n.code,{children:"componentDidMount"}),"、",(0,d.jsx)(n.code,{children:"componentDidUpdate"}),"、",(0,d.jsx)(n.code,{children:"componentWillUnmount"}),"这三个生命周期。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"Effect Hook"}),"会在每次渲染后都执行。但是与",(0,d.jsx)(n.code,{children:"componentDidMount"}),"或",(0,d.jsx)(n.code,{children:"componentDidUpdate"}),"不同，使用",(0,d.jsx)(n.code,{children:"useEffect"}),"调度的",(0,d.jsx)(n.code,{children:"effect"}),"不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。如果需要阻塞视图更新，可以使用",(0,d.jsx)(n.code,{children:"useLayoutEffect"})," Hook"]}),"\n",(0,d.jsxs)(n.p,{children:["在",(0,d.jsx)(n.code,{children:"React"}),"组件中有两种常见副作用操作：需要清除的和不需要清除的。需要清除的",(0,d.jsx)(n.code,{children:"effect"}),"可以在",(0,d.jsx)(n.code,{children:"useEffect"}),"中返回一个函数，",(0,d.jsx)(n.code,{children:"React"}),"将会在执行清除操作时调用它。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"React"}),"会在执行当前",(0,d.jsx)(n.code,{children:"effect"}),"之前对上一个",(0,d.jsx)(n.code,{children:"effect"}),"进行清除。"]}),"\n",(0,d.jsxs)(n.p,{children:["如果某些特定值在两次重渲染之间没有发生变化，可以通过传递数组作为",(0,d.jsx)(n.code,{children:"useEffect"}),"的第二个可选参数，通知 React 跳过对 effect 的调用。"]}),"\n",(0,d.jsxs)(n.p,{children:["如果想执行只运行一次的",(0,d.jsx)(n.code,{children:"effect"}),"（仅在组件挂载和卸载时执行），可以传递一个空数组",(0,d.jsx)(n.code,{children:"[]"}),"作为第二个参数。"]}),"\n",(0,d.jsx)(n.p,{children:"具体见下例："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:'import React, { useState, useEffect } from "react";\n\nfunction FriendStatus(props) {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  }, [count]);\n  const [isOnline, setIsOnline] = useState(null);\n\n  useEffect(() => {\n    function handleStatusChange(status) {\n      setIsOnline(status.isOnline);\n    }\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    // 清除副作用\n    return function cleanup() {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  }, [props.friend.id]); // 仅在 props.friend.id 发生变化时，重新订阅\n\n  if (isOnline === null) {\n    return "Loading...";\n  }\n  return isOnline ? "Online" : "Offline";\n}\n'})}),"\n",(0,d.jsxs)(n.h3,{id:"hook规则",children:[(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#hook规则",children:"#"}),(0,d.jsx)(n.code,{children:"Hook"}),"规则"]}),"\n",(0,d.jsxs)(n.p,{children:["Hook 就是",(0,d.jsx)(n.code,{children:"JavaScript"}),"函数，但是要注意两点规则："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsxs)(n.strong,{children:["只能在函数最外层调用",(0,d.jsx)(n.code,{children:"Hook"})]}),"，不能在循环、条件判断或者子函数中调用。这样能确保",(0,d.jsx)(n.code,{children:"Hook"}),"在每一次渲染中都按照同样的顺序被调用。让",(0,d.jsx)(n.code,{children:"React"}),"能够在多次的",(0,d.jsx)(n.code,{children:"useState"}),"和",(0,d.jsx)(n.code,{children:"useEffect"}),"调用之间保持",(0,d.jsx)(n.code,{children:"hook"}),"状态的正确"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsxs)(n.strong,{children:["只能在",(0,d.jsx)(n.code,{children:"React"}),"的函数组件中调用",(0,d.jsx)(n.code,{children:"Hook"})]}),"，不要在其他 ",(0,d.jsx)(n.code,{children:"JavaScript"}),"函数中调用。另外自定义的",(0,d.jsx)(n.code,{children:"Hook"}),"中也可以调用"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"React"}),"靠的是",(0,d.jsx)(n.code,{children:"Hook"}),"调用的顺序来确定哪个",(0,d.jsx)(n.code,{children:"state"}),"对应哪个",(0,d.jsx)(n.code,{children:"useState"})]}),"\n",(0,d.jsxs)(n.h3,{id:"其他hook",children:[(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#其他hook",children:"#"}),"其他",(0,d.jsx)(n.code,{children:"Hook"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"useContext"}),"接收一个",(0,d.jsx)(n.code,{children:"context"}),"对象（",(0,d.jsx)(n.code,{children:"React.createContext"}),"的返回值）并返回该",(0,d.jsx)(n.code,{children:"context"}),"的当前值。"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const value = useContext(MyContext);\n"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"useReducer"}),"，",(0,d.jsx)(n.code,{children:"useState"}),"的替代方案。接收一个形如",(0,d.jsx)(n.code,{children:"(state, action) => newState"}),"的",(0,d.jsx)(n.code,{children:"reducer"}),"，并返回当前的",(0,d.jsx)(n.code,{children:"state"})," 以及与其配套的",(0,d.jsx)(n.code,{children:"dispatch"}),"方法。"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const [state, dispatch] = useReducer(reducer, initialArg, init);\n"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"useLayoutEffect"}),"其函数签名与",(0,d.jsx)(n.code,{children:"useEffect"}),"相同，但它会在所有的",(0,d.jsx)(n.code,{children:"DOM"}),"变更之后同步调用",(0,d.jsx)(n.code,{children:"effect"}),"，会阻塞视图更新"]}),"\n",(0,d.jsxs)(n.h3,{id:"自定义hook",children:[(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#自定义hook",children:"#"}),"自定义",(0,d.jsx)(n.code,{children:"Hook"})]}),"\n",(0,d.jsxs)(n.p,{children:["自定义",(0,d.jsx)(n.code,{children:"Hook"}),"是一个函数，其名称以",(0,d.jsx)(n.code,{children:"use"}),"开头，函数内部可以调用其他的",(0,d.jsx)(n.code,{children:"Hook"}),"。"]}),"\n",(0,d.jsxs)(n.h2,{id:"react的生命周期",children:[(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react的生命周期",children:"#"}),(0,d.jsx)(n.code,{children:"React"}),"的生命周期"]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"componentDidMount"}),"，组件第一次被渲染到",(0,d.jsx)(n.code,{children:"DOM"}),"中的时候"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"componentWillUnmount"}),"，组件被删除的时候"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["当组件实例被创建并插入",(0,d.jsx)(n.code,{children:"DOM"}),"中时(挂载)，其生命周期调用顺序如下："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.code,{children:"constructor()"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.code,{children:"static getDerivedStateFromProps()"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.code,{children:"render()"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.code,{children:"componentDidMount()"})}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["当组件的",(0,d.jsx)(n.code,{children:"props"}),"或",(0,d.jsx)(n.code,{children:"state"}),"发生变化时会触发更新。组件更新的生命周期调用顺序如下："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.code,{children:"static getDerivedStateFromProps()"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.code,{children:"shouldComponentUpdate()"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.code,{children:"render()"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.code,{children:"getSnapshotBeforeUpdate()"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.code,{children:"componentDidUpdate()"})}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["当组件从",(0,d.jsx)(n.code,{children:"DOM"}),"中移除(卸载)时会调用如下方法："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.code,{children:"componentWillUnmount()"})}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"错误处理，当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法："}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.code,{children:"static getDerivedStateFromError()"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.code,{children:"componentDidCatch()"})}),"\n"]}),"\n",(0,d.jsxs)(n.h2,{id:"fiber",children:[(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#fiber",children:"#"}),"Fiber"]}),"\n",(0,d.jsxs)(n.h3,{id:"react架构",children:[(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react架构",children:"#"}),(0,d.jsx)(n.code,{children:"React"}),"架构"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"React 15"}),"架构可以分为两层："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"Reconciler"}),(0,d.jsx)(n.strong,{children:"协调器"}),"：负责找出变化的组件"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"Renderer"}),(0,d.jsx)(n.strong,{children:"渲染器"}),"：负责将变化的组件渲染到页面上"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"React 16"}),"架构可以分为三层："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"Scheduler"}),(0,d.jsx)(n.strong,{children:"调度器"}),"：调度任务的优先级，高优任务优先进入",(0,d.jsx)(n.code,{children:"Reconciler"})]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"Reconciler"}),(0,d.jsx)(n.strong,{children:"协调器"}),"：负责找出变化的组件"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"Renderer"}),(0,d.jsx)(n.strong,{children:"渲染器"}),"：负责将变化的组件渲染到页面上"]}),"\n"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,d.jsx)(n,Object.assign({},e,{children:(0,d.jsx)(r,e)})):r(e)}let o=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["framework%2Freact%2Findex.md"]={toc:[{id:"组件",text:"组件",depth:2},{id:"hook",text:"Hook",depth:2},{id:"state-hook",text:"`State Hook`",depth:3},{id:"effect-hook",text:"`Effect Hook`",depth:3},{id:"hook规则",text:"`Hook`规则",depth:3},{id:"其他hook",text:"其他`Hook`",depth:3},{id:"自定义hook",text:"自定义`Hook`",depth:3},{id:"react的生命周期",text:"`React`的生命周期",depth:2},{id:"fiber",text:"Fiber",depth:2},{id:"react架构",text:"`React`架构",depth:3}],title:"React",headingTitle:"React",frontmatter:{}}}}]);