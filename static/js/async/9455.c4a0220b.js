"use strict";(self.webpackChunknote=self.webpackChunknote||[]).push([["9455"],{587:function(e,n,t){t.r(n),t.d(n,{default:()=>d});var r=t(5893),c=t(65);function a(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",pre:"pre",h3:"h3"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"数据响应式系统",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#数据响应式系统",children:"#"}),"数据响应式系统"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Vue3"}),"的数据响应式系统主要由",(0,r.jsx)(n.code,{children:"@vue/reactivity"}),"承担，主要包括副作用函数",(0,r.jsx)(n.code,{children:"effect"}),"，依赖收集",(0,r.jsx)(n.code,{children:"track"}),"和触发更新",(0,r.jsx)(n.code,{children:"trigger"}),"这三部分。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Composition API"}),"实现响应式的关键",(0,r.jsx)(n.code,{children:"API"}),"为包装基本类型的",(0,r.jsx)(n.code,{children:"ref"}),"和引用类型的",(0,r.jsx)(n.code,{children:"reactive"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"reactive",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reactive",children:"#"}),"reactive"]}),"\n",(0,r.jsxs)(n.p,{children:["仅对简单的对象的",(0,r.jsx)(n.code,{children:"reactive"}),"过程做考虑的话，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const proxyMap = new WeakMap<Target, any>()\n\nexport function reactive(target: object) {\n    const proxy = new Proxy(target, handlers)\n\n    proxyMap.set(target, proxy)\n\n    return proxy\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["逻辑很简单，就是通过",(0,r.jsx)(n.code,{children:"Proxy"}),"返回目标的对象的代理，并将目标的对象和代理的映射关系缓存到一个",(0,r.jsx)(n.code,{children:"proxyMap"}),"中，其代理的",(0,r.jsx)(n.code,{children:"handlers"}),"内容如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const handlers = {\n    get(target: Target, key: string | symbol, receiver: object){\n        const res = Reflect.get(target, key, receiver)\n\n        track(target, TrackOpTypes.GET, key)\n\n        return res\n    },\n    set(target: object, key: string | symbol, value: unknown, receiver: object): boolean{\n        const oldValue = (target as any)[key]\n        const hadKey = hasOwn(target, key)\n        const result = Reflect.set(target, key, value, receiver)\n        \n        if (target === toRaw(receiver)) {\n            if (!hadKey) {\n                trigger(target, TriggerOpTypes.ADD, key, value)\n            } else if (hasChanged(value, oldValue)) {\n                trigger(target, TriggerOpTypes.SET, key, value)\n            }\n        }\n\n        return result\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我们先只关注基本的",(0,r.jsx)(n.code,{children:"get"}),"和",(0,r.jsx)(n.code,{children:"set"})," ",(0,r.jsx)(n.code,{children:"ProxyHandler"}),"，其逻辑也比较简单。其中",(0,r.jsx)(n.code,{children:"get"})," ",(0,r.jsx)(n.code,{children:"ProxyHandler"}),"除了调用默认的",(0,r.jsx)(n.code,{children:"Reflect API"}),"，就是调用了",(0,r.jsx)(n.code,{children:"track"}),"方法。类似的，",(0,r.jsx)(n.code,{children:"set"})," ",(0,r.jsx)(n.code,{children:"ProxyHandler"}),"除了调用默认的",(0,r.jsx)(n.code,{children:"Reflect API"}),"以外，根据目标对象",(0,r.jsx)(n.code,{children:"target"}),"中是否有要",(0,r.jsx)(n.code,{children:"set"}),"的",(0,r.jsx)(n.code,{children:"key"}),"，没有时调用了",(0,r.jsx)(n.code,{children:"TriggerOpTypes.ADD"}),"类型的",(0,r.jsx)(n.code,{children:"trigger"}),"方法，已经有",(0,r.jsx)(n.code,{children:"key"}),"，并且值发生了改变时，调用了",(0,r.jsx)(n.code,{children:"TriggerOpTypes.SET"}),"类型的",(0,r.jsx)(n.code,{children:"trigger"}),"方法。"]}),"\n",(0,r.jsxs)(n.h2,{id:"依赖收集与触发",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#依赖收集与触发",children:"#"}),"依赖收集与触发"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Vue3"}),"中的依赖以副作用函数",(0,r.jsx)(n.code,{children:"effect"}),"的方式体现。副作用函数就是指会产生副作用的函数，就是该函数的执行会直接或者间接影响其他的函数的执行，例如更新",(0,r.jsx)(n.code,{children:"DOM"}),"，修改作用域以外的变量等。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"track"}),"和",(0,r.jsx)(n.code,{children:"trigger"}),"主要负责依赖的收集(追踪)和触发，类似于",(0,r.jsx)(n.code,{children:"Vue2"}),"中的",(0,r.jsx)(n.code,{children:"Dep"}),"，分别在响应式数据",(0,r.jsx)(n.code,{children:"get"}),"和",(0,r.jsx)(n.code,{children:"set"}),"操作中被执行。用于将响应式数据和",(0,r.jsx)(n.code,{children:"effect"}),"关联起来。"]}),"\n",(0,r.jsxs)(n.p,{children:["这两个方法位于",(0,r.jsx)(n.code,{children:"@vue/reactivity/src/effect.ts"}),"文件中，在解析这两个方法之前，需要先对这两个方法依赖的几个局部变量做下说明："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type Dep = Set<ReactiveEffect>\ntype KeyToDepMap = Map<any, Dep>\n\nconst targetMap = new WeakMap<any, KeyToDepMap>()\nlet activeEffect: ReactiveEffect | undefined\nlet shouldTrack = true\nconst trackStack: boolean[] = []\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"targetMap"}),"是一个",(0,r.jsx)(n.code,{children:"WeakMap"}),"，其",(0,r.jsx)(n.code,{children:"key"}),"目标对象",(0,r.jsx)(n.code,{children:"target"}),"，其",(0,r.jsx)(n.code,{children:"value"}),"是一个以目标对象",(0,r.jsx)(n.code,{children:"target"}),"的",(0,r.jsx)(n.code,{children:"key"}),"为",(0,r.jsx)(n.code,{children:"key"}),"、其依赖的集合为",(0,r.jsx)(n.code,{children:"value"}),"的",(0,r.jsx)(n.code,{children:"Map"}),"，所以",(0,r.jsx)(n.code,{children:"targetMap"}),"是一个所有目标对象",(0,r.jsx)(n.code,{children:"target"}),"的依赖集合的映射总集合。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"activeEffect"}),"为当前激活状态的",(0,r.jsx)(n.code,{children:"effect"}),"，具体在",(0,r.jsx)(n.a,{href:"#effect",children:"effect"}),"分析"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"shouldTrack"}),"用于表示是否需要开始依赖收集，",(0,r.jsx)(n.code,{children:"trackStack"}),"用于标识当前依赖收集的深度。主要用于",(0,r.jsx)(n.code,{children:"effect"}),"方法中。"]}),"\n",(0,r.jsxs)(n.h3,{id:"track",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#track",children:"#"}),"track"]}),"\n",(0,r.jsx)(n.p,{children:"精简后代码如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"export function track(target: Target, type: TrackOpTypes, key: unknown) {\n    if (!shouldTrack || activeEffect === undefined) {\n        return\n    }\n    let depsMap = targetMap.get(target)\n    if (!depsMap) {\n        targetMap.set(target, (depsMap = new Map()))\n    }\n    let dep = depsMap.get(key)\n    if (!dep) {\n        depsMap.set(key, (dep = new Set()))\n    }\n    if (!dep.has(activeEffect)) {\n        dep.add(activeEffect)\n        activeEffect.deps.push(dep)\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["从上面代码可以知道，",(0,r.jsx)(n.code,{children:"track"}),"的逻辑非常简单，就是向",(0,r.jsx)(n.code,{children:"targetMap"}),"的具体",(0,r.jsx)(n.code,{children:"dep"}),"中加入当前",(0,r.jsx)(n.code,{children:"activeEffect"}),"，并像",(0,r.jsx)(n.code,{children:"activeEffect"}),"的",(0,r.jsx)(n.code,{children:"deps"}),"中加入对于的",(0,r.jsx)(n.code,{children:"dep"}),"。"]}),"\n",(0,r.jsxs)(n.h3,{id:"trigger",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#trigger",children:"#"}),"trigger"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"export function trigger(\n    target: object,\n    type: TriggerOpTypes,\n    key?: unknown,\n    newValue?: unknown\n) {\n    const depsMap = targetMap.get(target)\n    if (!depsMap) {\n        // never been tracked\n        return\n    }\n\n    // 需要触发的effect集合，通过add向其中添加内容\n    const effects = new Set<ReactiveEffect>()\n    const add = (effectsToAdd: Set<ReactiveEffect> | undefined) => {\n        if (effectsToAdd) {\n            effectsToAdd.forEach(effect => {\n                if (effect !== activeEffect || effect.allowRecurse) {\n                    effects.add(effect)\n                }\n            })\n        }\n    }\n\n    // 不同的情况下，出发depsMap里的不同内容\n    if (type === TriggerOpTypes.CLEAR) {\n        depsMap.forEach(add)\n    } else if (key === 'length' && isArray(target)) {\n        depsMap.forEach((dep, key) => {\n            if (key === 'length' || key >= (newValue as number)) {\n                add(dep)\n            }\n        })\n    } else {\n        if (key !== void 0) {\n            add(depsMap.get(key))\n        }\n\n        switch (type) {\n            case TriggerOpTypes.ADD:\n                if (!isArray(target)) {\n                    add(depsMap.get(ITERATE_KEY))\n                    if (isMap(target)) {\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY))\n                    }\n                } else if (isIntegerKey(key)) {\n                    add(depsMap.get('length'))\n                }\n                break\n            case TriggerOpTypes.DELETE:\n                if (!isArray(target)) {\n                    add(depsMap.get(ITERATE_KEY))\n                    if (isMap(target)) {\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY))\n                    }\n                }\n                break\n            case TriggerOpTypes.SET:\n                if (isMap(target)) {\n                    add(depsMap.get(ITERATE_KEY))\n                }\n                break\n        }\n    }\n\n    // 触发effect\n    const run = (effect: ReactiveEffect) => {\n        // 异步更新队列\n        if (effect.options.scheduler) {\n            effect.options.scheduler(effect)\n        } else { // 立即更新\n            effect()\n        }\n    }\n\n    effects.forEach(run)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"trigger"}),"的主要逻辑为在",(0,r.jsx)(n.code,{children:"targetMap"}),"中去除对应的",(0,r.jsx)(n.code,{children:"depsMap"}),"，然后根据不同的数据类型，不同的",(0,r.jsx)(n.code,{children:"TriggerOpTypes"}),"，触发对应的",(0,r.jsx)(n.code,{children:"effect"}),"。更新方式有异步更新队列和立即更新两种。"]}),"\n",(0,r.jsxs)(n.h3,{id:"effect",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#effect",children:"#"}),"effect"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"effect"}),"方法返回",(0,r.jsx)(n.code,{children:"ReactiveEffect"}),"函数，作用相当于",(0,r.jsx)(n.code,{children:"vue2"}),"中的观察者",(0,r.jsx)(n.code,{children:"Watcher"}),"。简化后代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"export function pauseTracking() {\n    trackStack.push(shouldTrack)\n    shouldTrack = false\n}\n\nexport function enableTracking() {\n    trackStack.push(shouldTrack)\n    shouldTrack = true\n}\n\nexport function resetTracking() {\n    const last = trackStack.pop()\n    shouldTrack = last === undefined ? true : last\n}\n\nconst effectStack: ReactiveEffect[] = []\nlet uid = 0\n\nfunction createReactiveEffect<T = any>(\n    fn: () => T,\n    options: ReactiveEffectOptions\n): ReactiveEffect<T> {\n    const effect = function reactiveEffect(): unknown {\n        if (!effect.active) {\n            return options.scheduler ? undefined : fn()\n        }\n        if (!effectStack.includes(effect)) {\n            cleanup(effect)\n            try {\n                enableTracking()\n                effectStack.push(effect)\n                activeEffect = effect\n                return fn()\n            } finally {\n                effectStack.pop()\n                resetTracking()\n                activeEffect = effectStack[effectStack.length - 1]\n            }\n        }\n    } as ReactiveEffect\n    effect.id = uid++\n    effect.allowRecurse = !!options.allowRecurse\n    effect._isEffect = true\n    effect.active = true\n    effect.raw = fn\n    effect.deps = [] // 与该副作用函数存在联系的依赖的集合，在该effect执行时，会先将对应的deps清空，即cleanup函数的作用，以便effect执行后，在track过程中重新建立联系，从而避免副作用函数产生遗留\n    effect.options = options\n    return effect\n}\n\nfunction cleanup(effect: ReactiveEffect) {\n    const { deps } = effect\n    if (deps.length) {\n        for (let i = 0; i < deps.length; i++) {\n            deps[i].delete(effect)\n        }\n        deps.length = 0\n    }\n}\n\nexport function isEffect(fn: any): fn is ReactiveEffect {\n    return fn && fn._isEffect === true\n}\n\nexport function effect<T = any>(\n    fn: () => T,\n    options: ReactiveEffectOptions = EMPTY_OBJ\n): ReactiveEffect<T> {\n    if (isEffect(fn)) {\n        fn = fn.raw\n    }\n    const effect = createReactiveEffect(fn, options)\n    if (!options.lazy) {\n        effect()\n    }\n    return effect\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"异步更新队列",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#异步更新队列",children:"#"}),"异步更新队列"]}),"\n",(0,r.jsxs)(n.h2,{id:"原来的分析",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原来的分析",children:"#"}),"原来的分析"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"reactive"}),"方法源码位于",(0,r.jsx)(n.code,{children:"@vue/reactivity/src/reactive.ts"}),"的第63行，其逻辑很简单，先判断是否为",(0,r.jsx)(n.code,{children:"readonly"}),"，如果是，直接返回",(0,r.jsx)(n.code,{children:"target"}),"，否则调用",(0,r.jsx)(n.code,{children:"createReactiveObject"}),"方法："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export function reactive(target: object) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  if (target && (target as Target)[ReactiveFlags.IS_READONLY]) {\n    return target\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers\n  )\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"createReactiveObject"}),"方法位于同文件的第136行："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function createReactiveObject(\n  target: Target,\n  isReadonly: boolean,\n  baseHandlers: ProxyHandler<any>,\n  collectionHandlers: ProxyHandler<any>\n) {\n  // 非对象，直接返回\n  if (!isObject(target)) return target\n\n  // 已经是一个Reactive Proxy，但不是Reactive Readonly Proxy直接返回\n  if (\n    target[ReactiveFlags.RAW] &&\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\n  ) return target\n  \n  // 已经在proxyMap中有对应的Reactive Proxy，直接返回existingProxy\n  const proxyMap = isReadonly ? readonlyMap : reactiveMap\n  const existingProxy = proxyMap.get(target)\n  if (existingProxy) {\n    return existingProxy\n  }\n\n  // 不是禁止Reactive的类型\n  const targetType = getTargetType(target)\n\n  if (targetType === TargetType.INVALID) {\n    return target\n  }\n\n  // 创建Reactive Proxy\n  const proxy = new Proxy(\n    target,\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\n  )\n\n  // 在proxyMap中设置缓存\n  proxyMap.set(target, proxy)\n\n  return proxy\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在",(0,r.jsx)(n.code,{children:"new Proxy"}),"，根据",(0,r.jsx)(n.code,{children:"TargetType"}),"分别使用了",(0,r.jsx)(n.code,{children:"collectionHandlers"}),"和",(0,r.jsx)(n.code,{children:"baseHandlers"}),"，先看下",(0,r.jsx)(n.code,{children:"baseHandlers"}),"其值由",(0,r.jsx)(n.code,{children:"reactive"}),"调用时传入的实参",(0,r.jsx)(n.code,{children:"mutableHandlers"}),"，其定义位于",(0,r.jsx)(n.code,{children:"@vue/reactivity/src/baseHandlers.ts"}),"的第187行："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export const mutableHandlers: ProxyHandler<object> = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["接下来我们一次看下对应的",(0,r.jsx)(n.code,{children:"ProxyHandler"}),":"]}),"\n",(0,r.jsxs)(n.h3,{id:"get",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#get",children:"#"}),"get"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"mutableHandlers"}),"的",(0,r.jsx)(n.code,{children:"get``ProxyHandler"}),"定义位于同文件的第35行，调用了同文件的第72行的",(0,r.jsx)(n.code,{children:"createGetter"}),"。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const get = /*#__PURE__*/ createGetter()\n\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target: Target, key: string | symbol, receiver: object) {\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly\n    } else if (\n      key === ReactiveFlags.RAW &&\n      receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)\n    ) {\n      return target\n    }\n\n    const targetIsArray = isArray(target)\n    if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver)\n    }\n\n    const res = Reflect.get(target, key, receiver)\n\n    const keyIsSymbol = isSymbol(key)\n    if (\n      keyIsSymbol\n        ? builtInSymbols.has(key as symbol)\n        : key === `__proto__` || key === `__v_isRef`\n    ) {\n      return res\n    }\n\n    if (!isReadonly) {\n      track(target, TrackOpTypes.GET, key)\n    }\n\n    if (shallow) {\n      return res\n    }\n\n    if (isRef(res)) {\n      // ref unwrapping - does not apply for Array + integer key.\n      const shouldUnwrap = !targetIsArray || !isIntegerKey(key)\n      return shouldUnwrap ? res.value : res\n    }\n\n    if (isObject(res)) {\n      // Convert returned value into a proxy as well. we do the isObject check\n      // here to avoid invalid value warning. Also need to lazy access readonly\n      // and reactive here to avoid circular dependency.\n      return isReadonly ? readonly(res) : reactive(res)\n    }\n\n    return res\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["其主要逻辑为调用",(0,r.jsx)(n.code,{children:"@vue/reactivity/src/effect.ts"}),"的第141行的",(0,r.jsx)(n.code,{children:"track"}),"方法，并且根据类型对值进行如下的特殊处理：将",(0,r.jsx)(n.code,{children:"ref"}),"执行",(0,r.jsx)(n.code,{children:"unwrap"}),"，引用类型递归转为",(0,r.jsx)(n.code,{children:"proxy"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"track"}),"方法主要作用是追踪响应，将需要被追踪的对象作为键更新到全局的",(0,r.jsx)(n.code,{children:"depsMap"}),"里，并与",(0,r.jsx)(n.code,{children:"activeEffect"}),"关联起来，相当于",(0,r.jsx)(n.code,{children:"Vue2"}),"中的",(0,r.jsx)(n.code,{children:"Dep"}),"。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const targetMap = new WeakMap<any, KeyToDepMap>()\nlet activeEffect: ReactiveEffect | undefined\nlet shouldTrack = true\n\nexport function track(target: object, type: TrackOpTypes, key: unknown) {\n  if (!shouldTrack || activeEffect === undefined) {\n    return\n  }\n  let depsMap = targetMap.get(target)\n  if (!depsMap) {\n    targetMap.set(target, (depsMap = new Map()))\n  }\n  let dep = depsMap.get(key)\n  if (!dep) {\n    depsMap.set(key, (dep = new Set()))\n  }\n  if (!dep.has(activeEffect)) {\n    dep.add(activeEffect)\n    activeEffect.deps.push(dep)\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"set",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#set",children:"#"}),"set"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"mutableHandlers"}),"的",(0,r.jsx)(n.code,{children:"set"})," ",(0,r.jsx)(n.code,{children:"ProxyHandler"}),"定义位于同文件的第125行，调用了同文件的第128行的",(0,r.jsx)(n.code,{children:"createGetter"}),"。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const set = /*#__PURE__*/ createSetter()\n\nfunction createSetter(shallow = false) {\n  return function set(\n    target: object,\n    key: string | symbol,\n    value: unknown,\n    receiver: object\n  ): boolean {\n    const oldValue = (target as any)[key]\n    if (!shallow) {\n      value = toRaw(value)\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value\n        return true\n      }\n    } else {\n      // in shallow mode, objects are set as-is regardless of reactive or not\n    }\n\n    const hadKey =\n      isArray(target) && isIntegerKey(key)\n        ? Number(key) < target.length\n        : hasOwn(target, key)\n    const result = Reflect.set(target, key, value, receiver)\n    // don't trigger if target is something up in the prototype chain of original\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, TriggerOpTypes.ADD, key, value)\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\n      }\n    }\n    return result\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["当",(0,r.jsx)(n.code,{children:"target"}),"为引用类型是",(0,r.jsx)(n.code,{children:"set"})," ",(0,r.jsx)(n.code,{children:"ProxyHandler"}),"会根据是否",(0,r.jsx)(n.code,{children:"hadKey"}),"分别调用",(0,r.jsx)(n.code,{children:"TriggerOpTypes"}),"类型为",(0,r.jsx)(n.code,{children:"SET"}),"/",(0,r.jsx)(n.code,{children:"ADD"}),"类型的",(0,r.jsx)(n.code,{children:"trigger"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"trigger"}),"代码位于",(0,r.jsx)(n.code,{children:"@vue/reactivity/src/effect.ts"}),"的第167行，是响应的触发器，"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export function trigger(\n  target: object,\n  type: TriggerOpTypes,\n  key?: unknown,\n  newValue?: unknown,\n  oldValue?: unknown,\n  oldTarget?: Map<unknown, unknown> | Set<unknown>\n) {\n  const depsMap = targetMap.get(target)\n  if (!depsMap) {\n    // never been tracked\n    return\n  }\n\n  const effects = new Set<ReactiveEffect>()\n  const add = (effectsToAdd: Set<ReactiveEffect> | undefined) => {\n    if (effectsToAdd) {\n      effectsToAdd.forEach(effect => {\n        if (effect !== activeEffect || effect.allowRecurse) {\n          effects.add(effect)\n        }\n      })\n    }\n  }\n\n  if (type === TriggerOpTypes.CLEAR) {\n    // collection being cleared\n    // trigger all effects for target\n    depsMap.forEach(add)\n  } else if (key === 'length' && isArray(target)) {\n    depsMap.forEach((dep, key) => {\n      if (key === 'length' || key >= (newValue as number)) {\n        add(dep)\n      }\n    })\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    if (key !== void 0) {\n      add(depsMap.get(key))\n    }\n\n    // also run for iteration key on ADD | DELETE | Map.SET\n    switch (type) {\n      case TriggerOpTypes.ADD:\n        if (!isArray(target)) {\n          add(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            add(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        } else if (isIntegerKey(key)) {\n          // new index added to array -> length changes\n          add(depsMap.get('length'))\n        }\n        break\n      case TriggerOpTypes.DELETE:\n        if (!isArray(target)) {\n          add(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            add(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        }\n        break\n      case TriggerOpTypes.SET:\n        if (isMap(target)) {\n          add(depsMap.get(ITERATE_KEY))\n        }\n        break\n    }\n  }\n\n  const run = (effect: ReactiveEffect) => {\n    if (effect.options.scheduler) {\n      effect.options.scheduler(effect)\n    } else {\n      effect()\n    }\n  }\n\n  effects.forEach(run)\n}\n"})})]})}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,Object.assign({},e,{children:(0,r.jsx)(a,e)})):a(e)}let d=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["framework%2Fvue3%2Freactivity.md"]={toc:[{id:"reactive",text:"reactive",depth:2},{id:"依赖收集与触发",text:"依赖收集与触发",depth:2},{id:"track",text:"track",depth:3},{id:"trigger",text:"trigger",depth:3},{id:"effect",text:"effect",depth:3},{id:"异步更新队列",text:"异步更新队列",depth:3},{id:"原来的分析",text:"原来的分析",depth:2},{id:"get",text:"get",depth:3},{id:"set",text:"set",depth:3}],title:"数据响应式系统",headingTitle:"数据响应式系统",frontmatter:{}}}}]);