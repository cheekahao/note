"use strict";(self.webpackChunknote=self.webpackChunknote||[]).push([["8114"],{630:function(e,d,n){n.r(d),n.d(d,{default:()=>h});var c=n(5893),s=n(65);function r(e){let d=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",pre:"pre",code:"code",h3:"h3",img:"img",strong:"strong",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(d.h1,{id:"编译原理",children:[(0,c.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#编译原理",children:"#"}),"编译原理"]}),"\n",(0,c.jsxs)(d.blockquote,{children:["\n",(0,c.jsx)(d.p,{children:"《编译系统透视：图解编译原理》读书笔记"}),"\n"]}),"\n",(0,c.jsxs)(d.h2,{id:"c程序的运行式结构",children:[(0,c.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#c程序的运行式结构",children:"#"}),"C程序的运行式结构"]}),"\n",(0,c.jsx)(d.p,{children:"C程序运行的核心是函数的执行和调用，它构成了整个C程序运行时结构的基础框架。这一运行过程主要是在程序指令的驱动以及数据压栈、清栈的支持下实现的。"}),"\n",(0,c.jsx)(d.p,{children:"以下面的程序为例："}),"\n",(0,c.jsx)(d.pre,{children:(0,c.jsx)(d.code,{className:"language-c",children:"int fun(int a, int b);\nint m = 10;\nint main() {\n    int i = 4;\n    int j = 5;\n    m = fun(i, j);\n    return 0;\n}\nint fun(int a,int b) {\n    int c=0;\n    c=a+b;\n    return c;\n}\n"})}),"\n",(0,c.jsxs)(d.h3,{id:"程序加载时的内存概况",children:[(0,c.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#程序加载时的内存概况",children:"#"}),"程序加载时的内存概况"]}),"\n",(0,c.jsx)(d.p,{children:"运行时，在内存中，共有代码区、静态数据区和动态数据区三个区域。"}),"\n",(0,c.jsx)(d.p,{children:(0,c.jsx)(d.img,{src:"//img.haozhenjia.com/blog/code_memory.jpg",alt:"内存区域"})}),"\n",(0,c.jsxs)(d.p,{children:["其中，",(0,c.jsx)(d.strong,{children:"代码区"}),"装载了程序所对应的机器指令；全局变量",(0,c.jsx)(d.code,{children:"m"}),"的数值装载在",(0,c.jsx)(d.strong,{children:"静态数据区"}),"中；",(0,c.jsx)(d.strong,{children:"动态数据区"}),"加载程序运行过程中产生的数据。"]}),"\n",(0,c.jsx)(d.p,{children:"程序执行的本质就是代码区的指令不断执行，驱使动态数据区和静态数据区产生数据变化。"}),"\n",(0,c.jsxs)(d.p,{children:[(0,c.jsx)(d.code,{children:"CPU"}),"中有三个寄存器，分别是",(0,c.jsx)(d.code,{children:"eip"}),"、",(0,c.jsx)(d.code,{children:"ebp"}),"和",(0,c.jsx)(d.code,{children:"esp"}),"。"]}),"\n",(0,c.jsxs)(d.p,{children:[(0,c.jsx)(d.code,{children:"eip"}),"永远指向代码区将要执行的下一条指令，它的管控方式有两种，一种是“顺序执行”，即程序执行完一条指令后自动指向下一条执行；另一种是跳转，也就是执行完一条跳转指令后跳转到指定的位置。"]}),"\n",(0,c.jsxs)(d.p,{children:[(0,c.jsx)(d.code,{children:"ebp"}),"和",(0,c.jsx)(d.code,{children:"esp"}),"用来管控栈空间，",(0,c.jsx)(d.code,{children:"ebp"}),"指向栈底，",(0,c.jsx)(d.code,{children:"esp"}),"指向栈顶。在代码区中，函数调用、返回和执行伴随着不断压栈和清栈，栈中数据存储和释放的原则是后进先出。"]}),"\n",(0,c.jsxs)(d.p,{children:[(0,c.jsx)(d.code,{children:"eip"}),"指向",(0,c.jsx)(d.code,{children:"main"}),"函数的第一条指令，此时程序还没有运行，栈空间里还没有数据，ebp和esp指向的位置是程序加载时内核设置的。"]}),"\n",(0,c.jsxs)(d.h3,{id:"程序运行过程中的内存变化",children:[(0,c.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#程序运行过程中的内存变化",children:"#"}),"程序运行过程中的内存变化"]}),"\n",(0,c.jsxs)(d.p,{children:["程序开始执行",(0,c.jsx)(d.code,{children:"main"}),"函数第一条指令(",(0,c.jsx)(d.code,{children:"call"}),"指令)，",(0,c.jsx)(d.code,{children:"eip"}),"自动指向下一条指令。第一条指令的执行，致使",(0,c.jsx)(d.code,{children:"ebp"}),"的地址值被保存在栈中，保存的目的是本程序执行完毕后，",(0,c.jsx)(d.code,{children:"ebp"}),"还能返回现在的位置，复原现在的栈。"]}),"\n",(0,c.jsxs)(d.p,{children:["随着",(0,c.jsx)(d.code,{children:"ebp"}),"地址值的压栈，",(0,c.jsx)(d.code,{children:"esp"}),"自动向栈顶方向移动，它将永远指向栈顶。"]}),"\n",(0,c.jsxs)(d.p,{children:["接下来，开始构建",(0,c.jsx)(d.code,{children:"main"}),"函数自己的栈，",(0,c.jsx)(d.code,{children:"ebp"}),"原来指向的地址值已经被保存了，此时和",(0,c.jsx)(d.code,{children:"esp"}),"是重叠的，用来看管main函数的栈底。"]}),"\n",(0,c.jsxs)(d.h2,{id:"汇编中的寄存器",children:[(0,c.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#汇编中的寄存器",children:"#"}),"汇编中的寄存器"]}),"\n",(0,c.jsxs)(d.p,{children:[(0,c.jsx)(d.code,{children:"eax"}),", ",(0,c.jsx)(d.code,{children:"ebx"}),", ",(0,c.jsx)(d.code,{children:"ecx"}),", ",(0,c.jsx)(d.code,{children:"edx"}),", ",(0,c.jsx)(d.code,{children:"esi"}),", ",(0,c.jsx)(d.code,{children:"edi"}),", ",(0,c.jsx)(d.code,{children:"ebp"}),", ",(0,c.jsx)(d.code,{children:"esp"}),"等都是",(0,c.jsx)(d.code,{children:"X86"}),"汇编语言中",(0,c.jsx)(d.code,{children:"CPU"}),"上的通用寄存器的名称，是32位的寄存器。"]}),"\n",(0,c.jsx)(d.p,{children:"如果用C语言来解释，可以把这些寄存器当作变量看待。"}),"\n",(0,c.jsxs)(d.table,{children:[(0,c.jsx)(d.thead,{children:(0,c.jsxs)(d.tr,{children:[(0,c.jsx)(d.th,{children:"汇编名称"}),(0,c.jsx)(d.th,{children:"寄存器类型"}),(0,c.jsx)(d.th,{children:"作用"})]})}),(0,c.jsxs)(d.tbody,{children:[(0,c.jsxs)(d.tr,{children:[(0,c.jsx)(d.td,{children:(0,c.jsx)(d.code,{children:"EAX"})}),(0,c.jsxs)(d.td,{children:["累加寄存器",(0,c.jsx)(d.code,{children:"accumulator register"})]}),(0,c.jsx)(d.td,{children:"加法乘法指令的缺省寄存器"})]}),(0,c.jsxs)(d.tr,{children:[(0,c.jsx)(d.td,{children:(0,c.jsx)(d.code,{children:"EBX"})}),(0,c.jsxs)(d.td,{children:["基址寄存器",(0,c.jsx)(d.code,{children:"base register"})]}),(0,c.jsx)(d.td,{children:"内存寻址时存放基地址"})]}),(0,c.jsxs)(d.tr,{children:[(0,c.jsx)(d.td,{children:(0,c.jsx)(d.code,{children:"ECX"})}),(0,c.jsxs)(d.td,{children:["程序计数器",(0,c.jsx)(d.code,{children:"program counter"})]}),(0,c.jsxs)(d.td,{children:["重复",(0,c.jsx)(d.code,{children:"REP"}),"前缀指令和",(0,c.jsx)(d.code,{children:"LOOP"}),"指令的内定计数器"]})]}),(0,c.jsxs)(d.tr,{children:[(0,c.jsx)(d.td,{children:(0,c.jsx)(d.code,{children:"EDX"})}),(0,c.jsx)(d.td,{}),(0,c.jsx)(d.td,{children:"用来存放整数除法产生的余数"})]}),(0,c.jsxs)(d.tr,{children:[(0,c.jsx)(d.td,{children:(0,c.jsx)(d.code,{children:"ESI"})}),(0,c.jsxs)(d.td,{children:["源索引寄存器",(0,c.jsx)(d.code,{children:"source index"})]}),(0,c.jsxs)(d.td,{children:["在很多字符串操作指令中, ",(0,c.jsx)(d.code,{children:"DS:ESI"}),"指向源串"]})]}),(0,c.jsxs)(d.tr,{children:[(0,c.jsx)(d.td,{children:(0,c.jsx)(d.code,{children:"EDI"})}),(0,c.jsxs)(d.td,{children:["目标索引寄存器",(0,c.jsx)(d.code,{children:"destination index"})]}),(0,c.jsxs)(d.td,{children:["在很多字符串操作指令中, ",(0,c.jsx)(d.code,{children:"ES:EDI"}),"指向目标串"]})]}),(0,c.jsxs)(d.tr,{children:[(0,c.jsx)(d.td,{children:(0,c.jsx)(d.code,{children:"EBP"})}),(0,c.jsxs)(d.td,{children:["基址指针",(0,c.jsx)(d.code,{children:"base pointer"})]}),(0,c.jsxs)(d.td,{children:["常被用作高级语言函数调用的",(0,c.jsxs)(d.strong,{children:["框架指针",(0,c.jsx)(d.code,{children:"frame pointer"})]}),"，存放当前线程的栈底指针"]})]}),(0,c.jsxs)(d.tr,{children:[(0,c.jsx)(d.td,{children:(0,c.jsx)(d.code,{children:"ESP"})}),(0,c.jsx)(d.td,{children:"堆栈指针"}),(0,c.jsx)(d.td,{children:"存放当前线程的栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。"})]}),(0,c.jsxs)(d.tr,{children:[(0,c.jsx)(d.td,{children:(0,c.jsx)(d.code,{children:"EIP"})}),(0,c.jsxs)(d.td,{children:["指令寄存器",(0,c.jsx)(d.code,{children:"instrution register"})]}),(0,c.jsxs)(d.td,{children:["存放下一个",(0,c.jsx)(d.code,{children:"CPU"}),"指令存放的内存地址"]})]})]})]}),"\n",(0,c.jsx)(d.p,{children:"因此，在函数的起始部分经常有："}),"\n",(0,c.jsx)(d.pre,{children:(0,c.jsx)(d.code,{children:"push ebp; 保存当前ebp\nmov ebp, esp; EBP设为当前堆栈指针\nsub esp, xxx; 预留xxx字节给函数临时变量.\n"})}),"\n",(0,c.jsxs)(d.h2,{id:"编译过程概述",children:[(0,c.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#编译过程概述",children:"#"}),"编译过程概述"]}),"\n",(0,c.jsxs)(d.p,{children:["源程序是给人看的，本质上就是文本文件。需要通过",(0,c.jsx)(d.strong,{children:"编译器"}),(0,c.jsx)(d.code,{children:"Compiler"}),"将源程序编译为计算机可执行的程序。"]}),"\n",(0,c.jsx)(d.p,{children:"编译过程主要分为词法分析、语法分析、中间代码生成、目标代码生成四个过程。"}),"\n",(0,c.jsxs)(d.h3,{id:"词法分析",children:[(0,c.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#词法分析",children:"#"}),"词法分析"]}),"\n",(0,c.jsxs)(d.p,{children:["词法分析的作用是从连续的字符中识别出标识符、关键字、数字、运算符并存储为符号",(0,c.jsx)(d.code,{children:"token"}),"流。"]}),"\n",(0,c.jsxs)(d.p,{children:["词法分析器",(0,c.jsx)(d.code,{children:"Lexer"}),"，也叫扫描器",(0,c.jsx)(d.code,{children:"Scanner"}),"，重要功能是根据对应语言的语法规则，一个字符一个字符从源程序的字符串中识别出一个个的符号",(0,c.jsx)(d.code,{children:"token"}),"，并按序保存。"]}),"\n",(0,c.jsxs)(d.p,{children:["C语言的语法规则是由一个",(0,c.jsx)(d.strong,{children:"状态转换图"}),"实现的。"]}),"\n",(0,c.jsx)(d.p,{children:"在词法分析阶段，词法分析器能够识别出一些符号的含义，包括关键字、数字、字符串、分隔符、运算符等，但是另外一切符号需要通过前后其他符号才能确定准确含义，仅能初步判断是一个标识符，更多详细信息在语法分析阶段完成。"}),"\n",(0,c.jsxs)(d.h3,{id:"语法分析",children:[(0,c.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#语法分析",children:"#"}),"语法分析"]}),"\n",(0,c.jsxs)(d.p,{children:["语法分析的作用是从词法分析识别出的",(0,c.jsx)(d.strong,{children:"token流"}),"中识别出符合对应语言语法的语句。"]}),"\n",(0,c.jsxs)(d.p,{children:["语法分析器",(0,c.jsx)(d.code,{children:"Parser"}),"依据用计算机表示的语法，一个符号一个符号地识别出符合C语言语法的语句。"]}),"\n",(0,c.jsxs)(d.p,{children:["在语法分析器中把通过产生式产生的对应语言语法映射成一套模板，并把这套模板融汇在语法分析器的程序中。语法分析器的作用就是将词法分析器识别出的符号",(0,c.jsx)(d.code,{children:"token"}),"一个一个地与这套模板进行匹配，匹配上这套模板中的某个语法，就可以识别出一句完整的语句，并确定这条语句的语法。"]}),"\n",(0,c.jsx)(d.p,{children:"语法的计算机表示就是产生式。"}),"\n",(0,c.jsxs)(d.p,{children:["语法分析器的最终输出是语法树",(0,c.jsx)(d.code,{children:"AST"}),"，是一个二维结构。语法树已经承载了源程序的全部信息，后续的转换工作就和源程序没关系了。"]}),"\n",(0,c.jsxs)(d.h3,{id:"从语法树到中间代码再到目标代码",children:[(0,c.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#从语法树到中间代码再到目标代码",children:"#"}),"从语法树到中间代码再到目标代码"]}),"\n",(0,c.jsxs)(d.p,{children:["鉴于计算机存在着多种",(0,c.jsx)(d.code,{children:"CPU"}),"硬件平台，考虑到程序在不同",(0,c.jsx)(d.code,{children:"CPU"}),"之间的可移植性，需要先将语法树转换成一个通用的、抽象的",(0,c.jsx)(d.strong,{children:"CPU指令"}),"，这就是中间代码最初的设计思想。然后根据具体选定的",(0,c.jsx)(d.code,{children:"CPU"}),"，将中间代码落实到具体",(0,c.jsx)(d.code,{children:"CPU"}),"的目标代码。"]}),"\n",(0,c.jsx)(d.p,{children:"语法树是个二维结构，中间代码是准一维结构，语法树到中间代码的转换过程，本质上是将二维结构转换为准一维结构的过程。"}),"\n",(0,c.jsxs)(d.p,{children:["选定具体的",(0,c.jsx)(d.code,{children:"CPU"}),"、操作系统后，中间代码就可以转换为目标代码——汇编代码。"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:d}=Object.assign({},(0,s.ah)(),e.components);return d?(0,c.jsx)(d,Object.assign({},e,{children:(0,c.jsx)(r,e)})):r(e)}let h=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["cs%2Fcompiler.md"]={toc:[{id:"c程序的运行式结构",text:"C程序的运行式结构",depth:2},{id:"程序加载时的内存概况",text:"程序加载时的内存概况",depth:3},{id:"程序运行过程中的内存变化",text:"程序运行过程中的内存变化",depth:3},{id:"汇编中的寄存器",text:"汇编中的寄存器",depth:2},{id:"编译过程概述",text:"编译过程概述",depth:2},{id:"词法分析",text:"词法分析",depth:3},{id:"语法分析",text:"语法分析",depth:3},{id:"从语法树到中间代码再到目标代码",text:"从语法树到中间代码再到目标代码",depth:3}],title:"编译原理",headingTitle:"编译原理",frontmatter:{}}}}]);