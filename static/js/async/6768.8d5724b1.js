"use strict";(self.webpackChunknote=self.webpackChunknote||[]).push([["6768"],{6815:function(n,e,t){t.r(e),t.d(e,{default:()=>c});var r=t(5893),s=t(65);function d(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ul:"ul",li:"li",code:"code",pre:"pre",strong:"strong",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,s.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"leetcode",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#leetcode",children:"#"}),"LeetCode"]}),"\n",(0,r.jsxs)(e.h2,{id:"滑动窗口算法",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#滑动窗口算法",children:"#"}),"滑动窗口算法"]}),"\n",(0,r.jsx)(e.p,{children:"滑动窗口算法主要用于解决数组/字符串的子元素问题。可以将嵌套的循环问题，转换为单循环问题，降低时间复杂度。"}),"\n",(0,r.jsx)(e.p,{children:"其主要过程是：维护一个队列或者两个指针，通过队列出队/入队或者左右两个指针的往右移动，使窗口不断向右滑动，直到最右面为止。"}),"\n",(0,r.jsx)(e.p,{children:"用到该算法的有："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#_3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2",children:"3. 无重复字符的最长子串"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#_76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2",children:"76. 最小覆盖子串"})}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"1-两数之和",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-两数之和",children:"#"}),"1. 两数之和"]}),"\n",(0,r.jsxs)(e.p,{children:["在数组中找到",(0,r.jsx)(e.code,{children:"2"}),"个数之和等于给定值的数字，结果返回",(0,r.jsx)(e.code,{children:"2"}),"个数字在数组中的下标。例如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const nums = [2, 7, 11, 15]\nconst target = 9\n\n// [0, 1]\n"})}),"\n",(0,r.jsx)(e.p,{children:"解题思路："}),"\n",(0,r.jsxs)(e.p,{children:["此题其实和数组去重类似，都是查询一个值是否在数组里去重是值本身，而此题是和",(0,r.jsx)(e.code,{children:"target"}),"之差。"]}),"\n",(0,r.jsxs)(e.p,{children:["一开始想到的方式，是双指针循环两次，算法复杂度为","O(n","2",")","："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function twoSum(nums, target){\n    const {length} = nums\n    let j = length - 1\n    let i\n    let isFind = false\n    while(!isFind && j){\n        const end = nums[j]\n\n        for (i = 0; i < j; i++) {\n            const item = nums[i];\n\n            if(item + end === target){\n                isFind = true\n\n                break\n            }\n        }\n\n        if(isFind) break\n\n        j--\n    }\n\n    return isFind ? [i, j] : null\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["深入思考后，其实与数组去重类似，可以用空间换时间，时间复杂度为",(0,r.jsx)(e.code,{children:"O(n)"}),"："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function twoSum(nums, target){\n    const {length} = nums\n    const map = {}\n\n    for (let index = 0; index < length; index++) {\n        const item = nums[index]\n        const diff = target - item\n        const diffIndex = map[diff]\n\n        if(diffIndex !== undefined){\n            return [diffIndex, index]\n        }else{\n            map[item] = index\n        }\n    }\n    \n    return null\n}\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"2-两数相加",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-两数相加",children:"#"}),"2. 两数相加"]}),"\n",(0,r.jsxs)(e.p,{children:["两个",(0,r.jsx)(e.strong,{children:"非空"}),"的链表，表示两个非负的整数。每位数字",(0,r.jsx)(e.strong,{children:"逆序"}),"存储的，且每个节点只存储",(0,r.jsx)(e.strong,{children:"一位"}),"数字。"]}),"\n",(0,r.jsx)(e.p,{children:"请你将两个数相加，并以相同形式返回一个表示和的链表。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function ListNode(val, next) {\n    this.val = (val === undefined ? 0 : val)\n    this.next = (next === undefined ? null : next)\n}\n\nfunction addTwoNumbers(l1, l2) {\n    let isCarry = 0\n    let first, current\n\n    while (l1 || l2 || isCarry) {\n        const value1 = l1 ? l1.val : 0\n        const value2 = l2 ? l2.val : 0\n        let sum = value1 + value2 + isCarry\n\n        if (sum >= 10) {\n            isCarry = 1\n            sum = sum % 10\n        } else {\n            isCarry = 0\n        }\n\n        if (!first){\n            first = new ListNode(sum)\n            current = first\n        }else{\n            current.next = new ListNode(sum)\n            current = current.next\n        }\n\n        l1 = l1 && l1.next\n        l2 = l2 && l2.next\n    }\n\n    return first\n}\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"3-无重复字符的最长子串",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-无重复字符的最长子串",children:"#"}),"3. 无重复字符的最长子串"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"题目："})," 在一个字符串中寻找没有重复字母的最长子串"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function lengthOfLongestSubstring(s){\n    let left = 0\n    let right = 0\n    let maxLength = 0\n    const {length} = s\n\n    while (right < length) {\n        right ++\n        let sub = s.substring(left, right)\n        while(hasRepeted(sub)){\n            left++\n            sub = s.substring(left, right)\n        }\n\n        const subLength = sub.length\n        if(subLength > maxLength) maxLength = subLength\n    }\n\n    return maxLength\n}\n\nfunction hasRepeted(str){\n    const set = new Set()\n    const {length} = str\n    let result = false\n\n    for (let index = 0; index < length; index++) {\n        const char = str.charAt(index)\n\n        if(set.has(char)){\n            result = true\n            break\n        }\n\n        set.add(char)\n    }\n\n    return result\n}\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"12-整数转罗马数字",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#12-整数转罗马数字",children:"#"}),"12. 整数转罗马数字"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"题目："})}),"\n",(0,r.jsxs)(e.p,{children:["罗马数字包含以下七种字符：",(0,r.jsx)(e.code,{children:"I"}),"、",(0,r.jsx)(e.code,{children:"V"}),"、",(0,r.jsx)(e.code,{children:"X"}),"、",(0,r.jsx)(e.code,{children:"L"}),"、",(0,r.jsx)(e.code,{children:"C"}),"、",(0,r.jsx)(e.code,{children:"D"}),"和",(0,r.jsx)(e.code,{children:"M"}),"。"]}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"符号"}),(0,r.jsx)(e.th,{children:"十进制对应的值"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"I"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"1"})})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"V"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"5"})})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"X"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"10"})})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"L"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"50"})})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"C"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"100"})})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"D"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"500"})})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"M"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"1000"})})]})]})]}),"\n",(0,r.jsxs)(e.p,{children:["例如，罗马数字",(0,r.jsx)(e.code,{children:"2"}),"写做",(0,r.jsx)(e.code,{children:"II"}),"，即为两个并列的",(0,r.jsx)(e.code,{children:"1"}),"。",(0,r.jsx)(e.code,{children:"12"}),"写做",(0,r.jsx)(e.code,{children:"XII"}),"，即为",(0,r.jsx)(e.code,{children:"X +\xa0II"}),"。",(0,r.jsx)(e.code,{children:"27"}),"写做",(0,r.jsx)(e.code,{children:"XXVII"}),"，即为",(0,r.jsx)(e.code,{children:"XX +\xa0V\xa0+\xa0II"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如",(0,r.jsx)(e.code,{children:"4"}),"不写做",(0,r.jsx)(e.code,{children:"IIII"}),"，而是",(0,r.jsx)(e.code,{children:"IV"}),"。数字",(0,r.jsx)(e.code,{children:"1"}),"在数字",(0,r.jsx)(e.code,{children:"5"}),"的左边，所表示的数等于大数",(0,r.jsx)(e.code,{children:"5"}),"减小数",(0,r.jsx)(e.code,{children:"1"}),"得到的数值",(0,r.jsx)(e.code,{children:"4"}),"。同样地，数字",(0,r.jsx)(e.code,{children:"9"}),"表示为",(0,r.jsx)(e.code,{children:"IX"}),"。这个特殊的规则只适用于以下六种情况："]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"I"}),"可以放在",(0,r.jsx)(e.code,{children:"V"}),"(5)和",(0,r.jsx)(e.code,{children:"X"}),"(10)的左边，来表示",(0,r.jsx)(e.code,{children:"4"}),"和",(0,r.jsx)(e.code,{children:"9"}),"。\n",(0,r.jsx)(e.code,{children:"X"}),"可以放在",(0,r.jsx)(e.code,{children:"L"}),"(50)和",(0,r.jsx)(e.code,{children:"C"}),"(100)的左边，来表示",(0,r.jsx)(e.code,{children:"40"}),"和",(0,r.jsx)(e.code,{children:"90"}),"。\xa0\n",(0,r.jsx)(e.code,{children:"C"}),"可以放在",(0,r.jsx)(e.code,{children:"D"}),"(500)和",(0,r.jsx)(e.code,{children:"M"}),"(1000)的左边，来表示",(0,r.jsx)(e.code,{children:"400"}),"和",(0,r.jsx)(e.code,{children:"900"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["给定一个整数，将其转为罗马数字。输入确保在",(0,r.jsx)(e.code,{children:"1"}),"到",(0,r.jsx)(e.code,{children:"3999"}),"的范围内。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function intToRoman(int) {\n    const list = [{\n        roman: 'M',\n        value: 1000,\n    }, {\n        roman: 'D',\n        value: 500,\n    }, {\n        roman: 'C',\n        value: 100,\n    }, {\n        roman: 'L',\n        value: 50,\n    }, {\n        roman: 'X',\n        value: 10,\n    }, {\n        roman: 'V',\n        value: 5,\n    }, {\n        roman: 'I',\n        value: 1,\n    }]\n    let rest = int\n    let isConvertNine = false\n\n    return list.reduce( (result, item, index) => {\n        const {\n            roman,\n            value,\n        } = item\n        const next = list[index + 1]\n        const prev = list[index - 1]\n        const ten = list[index - 2]\n        let current = Math.floor(rest / value)\n\n        if (!current) return result\n\n        rest = rest % value\n\n        switch (true) {\n            case current === 1 && next && Math.floor(rest / next.value) === 4: // 9 需要特殊表示为prev + next\n                isConvertNine = true\n                break;\n            case isConvertNine && current === 4: // 说明值为9或者其倍数\n                result += roman + ten.roman\n                isConvertNine = false\n                break;\n            case !isConvertNine && current === 4: // 说明值为4\n                result += roman + prev.roman\n                break;\n            default:\n                while (current) {\n                    result += roman\n                    current--\n                }\n                break;\n        }\n\n        return result\n    }, '')\n}\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"13-罗马数字转整数",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#13-罗马数字转整数",children:"#"}),"13. 罗马数字转整数"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function romanToInt(roman) {\n    const map = {\n        I: 1,\n        V: 5,\n        X: 10,\n        L: 50,\n        C: 100,\n        D: 500,\n        M: 1000\n    }\n    const romanArr = roman.split('')\n\n    return romanArr.reduce((result, item, index) => {\n        const value = map[item]\n        const next = romanArr[index + 1]\n\n        if (!next) return result + value\n        const nextValue = map[next]\n\n        return value < nextValue ? result - value : result + value\n    }, 0)\n}\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"74-合并区间",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#74-合并区间",children:"#"}),"74. 合并区间"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"题目："})," 以数组",(0,r.jsx)(e.code,{children:"intervals"}),"表示若干个区间的集合，其中单个区间为",(0,r.jsx)(e.code,{children:"intervals[i] = [starti, endi]"}),"。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。"]}),"\n",(0,r.jsx)(e.p,{children:"示例："}),"\n",(0,r.jsx)(e.p,{children:"输入：intervals = [[1,3],[2,6],[8,10],[15,18]]"}),"\n",(0,r.jsx)(e.p,{children:"输出：[[1,6],[8,10],[15,18]]"}),"\n",(0,r.jsx)(e.p,{children:"解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]."}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"解析："})}),"\n",(0,r.jsxs)(e.p,{children:["关键需要先对",(0,r.jsx)(e.code,{children:"intervals"}),"进行排序，再从左到右遍历，合并重叠区间。"]}),"\n",(0,r.jsx)(e.p,{children:"否则用两次循环比较所有区间，效率会比较低。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function merge(intervals) {\n    intervals.sort((a, b) => a[0] - b[0])\n\n    let i = 0, j = 1, result = []\n\n    while(i < intervals.length){\n        const merged = [...intervals[i]]\n        let next = intervals[j]\n\n        while(j < intervals.length && next[0] <= merged[1]){\n            merged[1] = Math.max(merged[1], next[1])\n            j++\n            next = intervals[j]\n        }\n        result.push(merged)\n        i = j\n    }\n\n    return result\n}\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"76-最小覆盖子串",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#76-最小覆盖子串",children:"#"}),"76. 最小覆盖子串"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"题目："})," 给两个个字符串",(0,r.jsx)(e.code,{children:"s"}),"和",(0,r.jsx)(e.code,{children:"t"}),"。返回",(0,r.jsx)(e.code,{children:"s"}),"中涵盖",(0,r.jsx)(e.code,{children:"t"}),"所有字符的最小子串。如果不存在则返回空字符串",(0,r.jsx)(e.code,{children:'""'}),"。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function minWindow(s, t) {\n    const {length} = s\n    const total = t.length\n    const leftSteps = getContainedSteps(s, t)\n    const rightSteps = leftSteps.slice(0)\n    let left = leftSteps.shift()\n    let right = rightSteps.shift()\n    let minSubStr = ''\n    const sourceCountMap = {}\n    const targetCountMap = getCountMap(t)\n\n    while (right <= length) {\n        let rightChat = s.charAt(right)\n        let leftChat = s.charAt(left)\n        updateCountMap(sourceCountMap, rightChat)\n\n        while (right - left >= total && sourceCountMap[leftChat] > targetCountMap[leftChat]) {\n            reduceCountMap(sourceCountMap, leftChat)\n            left = leftSteps.shift()\n            leftChat = s.charAt(left)\n        }\n\n        const subStr = s.substring(left, right + 1)\n\n        if ((!minSubStr || minSubStr.length > subStr.length) && hasContainedSource(sourceCountMap, targetCountMap)) minSubStr = subStr\n\n        if (rightSteps.length){\n            right = rightSteps.shift()\n        }else {\n            right++\n        }\n\n    }\n\n    return minSubStr\n}\n\nfunction getContainedSteps(source, target) {\n    const steps = []\n    const {length} = source\n\n    for (let index = 0; index < length; index++) {\n        const char = source.charAt(index)\n\n        if (target.indexOf(char) > -1) steps.push(index)\n    }\n\n    return steps\n}\n\nfunction getCountMap(str) {\n    const map = {}\n    const {\n        length\n    } = str\n\n    for (let index = 0; index < length; index++) {\n        const char = str.charAt(index)\n\n        updateCountMap(map, char)\n    }\n\n    return map\n}\n\nfunction updateCountMap(map, char) {\n    map[char] = (map[char] || 0) + 1\n}\nfunction reduceCountMap(map, char) {\n    map[char] = map[char] > 0 ? map[char] - 1 : 0\n}\n\nfunction hasContainedSource(sourceCountMap, targetCountMap) {\n    let hasContained = true\n    for (const key in targetCountMap) {\n        if (Object.hasOwnProperty.call(targetCountMap, key)) {\n            const sourceCount = sourceCountMap[key] || 0\n            if (sourceCount < targetCountMap[key]){\n                hasContained = false\n                break\n            }\n\n        }\n    }\n\n    return hasContained\n}\n"})})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(d,n)})):d(n)}let c=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["advance%2Fleet-code.md"]={toc:[{id:"滑动窗口算法",text:"滑动窗口算法",depth:2},{id:"1-两数之和",text:"1. 两数之和",depth:2},{id:"2-两数相加",text:"2. 两数相加",depth:2},{id:"3-无重复字符的最长子串",text:"3. 无重复字符的最长子串",depth:2},{id:"12-整数转罗马数字",text:"12. 整数转罗马数字",depth:2},{id:"13-罗马数字转整数",text:"13. 罗马数字转整数",depth:2},{id:"74-合并区间",text:"74. 合并区间",depth:2},{id:"76-最小覆盖子串",text:"76. 最小覆盖子串",depth:2}],title:"LeetCode",headingTitle:"LeetCode",frontmatter:{}}}}]);