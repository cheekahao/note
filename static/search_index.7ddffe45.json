[{"id":0,"title":"数据结构与算法","content":"#\n\n\n内存中的栈和堆#\n\n栈由操作系统自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。\n\n堆由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式类似于链表。\n\n栈使用的是一级缓存，在被调用时处于存储空间中，调用完毕立即释放。\n\n堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。\n\n与堆相比，栈存取速度比堆要快，仅次于直接位于CPU中的寄存器。缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。\n\n\n二分查找#\n\n输入一个有序元素列表，从1/2处开始查找，通过比较大小排除一半元素，再从剩下的元素的1/2处开始查找，不断递归，直到查找到结果为止。\n\n复杂度为O(log n)\n\n\n数组和链表#\n\n链表的每一个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串联起来。\n\n在链表中添加元素只需将其放入内存，并将其地址存储到前一个元素中。\n\n从链表中读取元素时，需要从第一个元素开始，依次往下访问，直到找到对应元素为止，所以读取元素效率较低。\n\n数组中的元素在内存中紧连在一起，所以从数组中随机的读取元素，只需要根据其索引值和起始地址做简单的算术运算即可。但是在数组中插入元素，就需要将要插入位置之后的元素\n依次后移，然后再讲元素插入，所以其插入效率较低。\n\n数组和链表的操作运行时间对比如下：\n\n操作   数组     链表\n读取   O(1)   O(n)\n插入   O(n)   O(1)\n删除   O(n)   O(1)\n\n\n选择排序#\n\n依次找到最小值，并将最小值与对应位置的元素交换\n\n复杂度为O(n2)\n\n\n\n\n栈#\n\n栈是一种后进先出的列表，只有压入(push)和弹出(pop)两种操作。\n\n\n递归#\n\n递归是一种函数自己调用自己解决方案，能用递归解决的问题都能用循环解决，递归并不是性能上的提升，而是更清晰，更容易理解。\n\n递归都有基线条件和递归条件。\n\n\n分治#\n\n分治算法divide and conquer，D & C，是一种著名的递归式问题解决方法。\n\n\n归并排序#\n\n归并排序是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。复杂度为O(nlog(n))\n\n\n\n\n快速排序#\n\n快速排序是一种常用的排序算法，复杂度为O(nlog n)，且性能比其他复杂度为O(nlog n)的排序算法好。\n\n具体步骤如下：\n\n 1. 从数组中选择中间一项作为基准值\n 2. 划分，将数组分为大于基准值和小于基准值的两个数组\n 3. 递归，递归上面划分的两个数组，知道所有都只有一个元素\n\n根据划分的过程是否需要额外的内存，又可将其分为in-place(原地算法)和out-place两种\n\nout-place\n\n\n\nin-place\n\n\n\n\n散列表#\n\n\n树#\n\n树是一种分层数据的抽象模型。一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点。位于树顶部的节点叫作根节\n点。树中的每个元素都叫作节点，节点分为内部节点和外部节点。至少有一个子节点的节点称为内部节点。没有子元素的节点称为外部节点或叶节点。\n\n子树由节点和它的后代构成。节点的一个属性是深度，取决于它的祖先节点的数量。树的高度取决于所有节点深度的最大值。\n\n\n二叉树#\n\n二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。\n\n二叉搜索树（BST）是二叉树的一种，它只允许在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。\n\n遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。访问树的所有节点有三种方式：中序、先序和后序。\n\n\n自平衡树#\n\nAVL(Adelson-Velskii-Landi)树是一种自平衡二叉搜索树，任何一个节点左右两侧子树的高度之差最多为1。添加或移除节点时，会尝试保持自平衡。\n\n\n红黑树#\n\n红黑树(Red-Black Tree, RBT)也是一个自平衡二叉搜索树。每个节点都遵循以下规则：\n\n 1. 每个节点不是红的就是黑的\n 2. 树的根节点是黑的\n 3. 所有叶节点都是黑的（用NULL引用表示的节点）\n 4. 如果一个节点是红的，那么它的两个子节点都是黑的\n 5. 不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点\n 6. 从给定的节点到它的后代节点（NULL叶节点）的所有路径包含相同数量的黑色节点\n\n\n图#\n\n\n图的相关概念#\n\n一个图G=(V, E)由以下元素组成：\n\n * V: 一组顶点\n * E: 一组边，连接V中的顶点\n\n\n\n由一条边连接在一起的顶点称为相邻顶点。例如C和D是相邻的。\n\n一个顶点的度是其相邻顶点的数量。例如A的度是3。\n\n路径是顶点v1, v2, …,\nvk的一个连续序列，其中vi和vi+1是相邻的。例如路径ABEI。简单路径要求不包含重复的顶点。除去最后一个顶点，环(ADCA)也是一个简单路径。\n\n如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。\n\n图可以是无向的（边没有方向，无向图）或是有向的（有向图）。有向图如下图所示：\n\n\n\n如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C和D是强连通的。\n\n图还可以是未加权的或是加权的。加权图的边被赋予了权值，如下图所示：\n\n\n\n\n图的表示#\n\n邻接矩阵#\n\n图最常见的实现是邻接矩阵。每个节点都和一个整数相关联，该整数将作为数组的索引，用一个二维数组来表示顶点之间的连接。如果索引为i的节点和索引为j的节点相邻，则ar\nray[i][j] === 1，否则array[i][j] === 0。\n\n不是强连通的图（稀疏图）用邻接矩阵来表示，矩阵中将会有很多0，会对存储空间造成一定的浪费。\n\n邻接表#\n\n还可以用一种叫作邻接表的动态数据结构来表示图。邻接表由图中每个顶点的相邻顶点列表所组成。可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。邻接表\n对大多数问题来说都是更好的选择。\n\n关联矩阵#\n\n还可以用关联矩阵来表示图。在关联矩阵中，矩阵的行表示顶点，列表示边。使用二维数组来表示两者之间的连通性，如果顶点v是边e的入射点，则array[v][e]\n=== 1；否则，array[v][e] === 0。关联矩阵通常用于边的数量比顶点多的情况。\n\n\n广度优先搜索#\n\n\n加权图与狄克斯特拉算法#\n\n\n贪心算法#\n\n\n贪心算法基础概念#\n\n狭义的贪心算法指的是解最优化问题的一种特殊方法，解决过程中总是做出当下最好的选择，因为具有最优子结构的特点，局部最优解可以得到全局最优解；这种贪心算法是动态规划\n的一种特例。能用贪心解决的问题，也可以用动态规划解决。\n\n而广义的贪心指的是一种通用的贪心策略，基于当前局面而进行贪心决策。\n\n\n贪心算法的思考过程#\n\n贪心的思考过程类似动态规划，依旧是两步：大事化小，小事化了。\n\n大事化小：\n\n一个较大的问题，通过找到与子问题的重叠，把复杂的问题划分为多个小问题；\n\n小事化了：\n\n从小问题找到决策的核心，确定一种得到最优解的策略。\n\n\n斐波那契数列计算#\n\n递归\n\n缺点，随着n的变大，执行次数大量增长\n\n\n\n动态规划\n\n通过一个数组保存中间结果，通过循环计算斐波那契数列，并将最后的值返回。 动态规划算法需要将中间结果保存起来。\n\n\n\n\n算法复杂度#\n\n\n大O表示法#\n\n大O表示法用于描述算法的性能和复杂程度。将算法按照消耗的时间进行分类，依据随输入增大所需要的空间/内存。\n\n常用的函数有：\n\n符号           名称\nO(1)         常数的\nO(log(n))    对数的\nO(log(n))c   对数多项式的\nO(n)         线性的\nO(n2)        二次的\nO(nc)        多项式的\nO(cn)        指数的","routePath":"/advance/algorithm","lang":"","toc":[{"text":"内存中的栈和堆","id":"内存中的栈和堆","depth":2,"charIndex":3},{"text":"二分查找","id":"二分查找","depth":2,"charIndex":272},{"text":"数组和链表","id":"数组和链表","depth":2,"charIndex":362},{"text":"选择排序","id":"选择排序","depth":2,"charIndex":691},{"text":"栈","id":"栈","depth":2,"charIndex":737},{"text":"递归","id":"递归","depth":2,"charIndex":779},{"text":"分治","id":"分治","depth":2,"charIndex":862},{"text":"归并排序","id":"归并排序","depth":3,"charIndex":915},{"text":"快速排序","id":"快速排序","depth":3,"charIndex":1006},{"text":"散列表","id":"散列表","depth":2,"charIndex":1237},{"text":"树","id":"树","depth":2,"charIndex":1244},{"text":"二叉树","id":"二叉树","depth":3,"charIndex":1455},{"text":"自平衡树","id":"自平衡树","depth":3,"charIndex":1653},{"text":"红黑树","id":"红黑树","depth":3,"charIndex":1742},{"text":"图","id":"图","depth":2,"charIndex":1964},{"text":"图的相关概念","id":"图的相关概念","depth":3,"charIndex":1969},{"text":"图的表示","id":"图的表示","depth":3,"charIndex":2346},{"text":"邻接矩阵","id":"邻接矩阵","depth":4,"charIndex":2353},{"text":"邻接表","id":"邻接表","depth":4,"charIndex":2526},{"text":"关联矩阵","id":"关联矩阵","depth":4,"charIndex":2631},{"text":"广度优先搜索","id":"广度优先搜索","depth":2,"charIndex":2766},{"text":"加权图与狄克斯特拉算法","id":"加权图与狄克斯特拉算法","depth":2,"charIndex":2776},{"text":"贪心算法","id":"贪心算法","depth":2,"charIndex":2791},{"text":"贪心算法基础概念","id":"贪心算法基础概念","depth":3,"charIndex":2799},{"text":"贪心算法的思考过程","id":"贪心算法的思考过程","depth":3,"charIndex":2956},{"text":"斐波那契数列计算","id":"斐波那契数列计算","depth":2,"charIndex":3079},{"text":"算法复杂度","id":"算法复杂度","depth":2,"charIndex":3181},{"text":"大O表示法","id":"大o表示法","depth":3,"charIndex":3190}],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"架构","content":"#\n\n> 《架构整洁之道》读书笔记\n\n\n编程范式#\n\n * 结构化编程，结构化编程对程序控制权的直接转移进行了限制和规范。限制goto语句\n * 面向对象编程，面向对象编程对程序控制权的间接转移进行了限制和规范。限制函数指针\n * 函数式编程，函数式编程对程序中的赋值进行了限制和规范。限制赋值语句的使用\n\n\n软件架构#\n\n * 功能性\n * 组件独立性\n * 数据管理\n * 顺序结构\n * 分支结构\n * 循环结构\n\n\n面向对象#\n\n * 封装\n * 继承\n * 多态\n\n\n设计原则#\n\nSOLID原则\n\n * SRP: 单一职责原则。每个软件模块有且只有一个需要被改变的理由\n * OCP: 开闭原则。如果软件系统想要更容易被改变，其设计必须允许新增代码来修改系统行为，而非只能靠修改原来的代码\n * LSP: 里氏替换原则。软件系统的组件要遵守同一个约定，以便让这些组件可以相互替换\n * ISP: 接口隔离原则。在设计中避免不必要的依赖\n * DIP: 依赖反转原则。高层策略性代码不应该依赖实现底层细节的代码，实现底层细节的代码应该依赖高层策略性代码\n * LKP: 最少知识原则。一个软件实体应当尽可能少地与其他实体发生相互作用\n\n\n架构关注点#\n\n架构是系统设计的一部分，它突出了某些细节，并通过抽象省略掉另一些细节。\n\n架构关注的是组件之间的关系和系统组件外部可见的属性，设计还要关注这些组件的内部结构。\n\n\n架构关注点#\n\n * 品质关注点，例如稳定性，技术栈等\n\n\n组件构建基本原则#\n\n * REP：复用/发布等同原则。软件复用的最小粒度应等同于其发布的最小粒度\n * CCP：共同闭包原则。将会同时修改，且为了相同目的而修改的代码放到同一个组件中。反之亦然。\n * CRP：共同复用原则。不应强迫一个组件的用户依赖他们不需要的东西。\n\n\n什么是软件架构#\n\n设计软件架构的目的是为了在工作中更好地对这些组件进行研发、部署、运行以及维护。\n\n软件架构设计的主要目标是支撑软件系统的全生命周期，设计良好的架构可以让系统便于理解、易于修改、方便维护，并且能轻松部署。软件架构的终极目标就是最大化程序员的生产\n力，同时最小化系统的总运营成本。\n\n对于一个只有五个开发人员的小团队来说，他们完全可以非常高效地共同开发一个没有明确定义组件和接口的单体系统（monolithic system）。\n\n设计良好的系统架构应该可以使开发人员对系统的运行过程一目了然。\n\n所有的软件系统都可以降解为策略与细节这两种主要元素。策略体现的是软件中所有的业务规则与操作过程。\n\n软件架构师的目标是创建一种系统形态，该形态会以策略为最基本的元素，并让细节与策略脱离关系，以允许在具体决策过程中推迟或延迟与细节相关的内容。\n\n软件架构设计本身就是一门划分边界的艺术。边界的作用是将软件分割成各种元素，以便约束边界两侧之间的依赖关系。\n\n本质上，所有的软件系统都是一组策略语句的集合。\n\n软件架构设计的工作重点之一就是，将这些策略彼此分离，然后将它们按照变更的方式软件架构设计的工作重点之一就是，将这些策略彼此分离，然后将它们按照变更的方式进行重新\n分组。其中变更原因、时间和层次相同的策略应该被分到同一个组件中。反之，变更原因、时间和层次不同的策略则应该分属于不同的组件。\n\n我们对“层次”是严格按照“输入与输出之间的距离”来定义的。一条策略距离系统的输入/输出越远，它所属的层次就越高。而直接管理输入/输出的策略在系统中的层次是最低的\n。\n\n我们希望源码中的依赖关系与其数据流向脱钩，而与组件所在的层次挂钩。\n\n离输入/输出最远的策略——高层策略——一般变更没有那么频繁。即使发生变更，其原因也比低层策略所在的组件更重大。反之，低层策略则很有可能会频繁地进行一些小变更。\n\n\n业务逻辑#\n\n如果我们要将自己的应用程序划分为业务逻辑和插件两部分，就必须更仔细地了解业务逻辑究竟是什么，它到底有几种类型。\n\n业务逻辑就是程序中那些真正用于赚钱或省钱的业务逻辑与过程。更严格地讲，无论这些业务逻辑是在计算机上实现的，还是人工执行的，它们在省钱/赚钱上的作用都是一样的。\n\n“关键业务逻辑”通常会需要处理一些数据，我们将这些数据称为“关键业务数据”，关键业务逻辑和关键业务数据是紧密相关的，所以它们很适合被放在同一个对象中处理。我们将\n这种对象称为“业务实体（Entity）”。\n\n\n架构设计的主题#\n\n架构设计不是（或者说不应该是）与框架相关的，框架只是一个可用的工具和手段。\n\n软件的系统架构应该为该系统的用例提供支持。\n\n\n领域驱动设计DDD#\n\n领域驱动设计作为一个针对大型复杂业务系统的领域建模方法体系，它通过面向领域的思维方式，将要解决的业务概念和业务规则等内容提炼为领域知识，然后借由不同的建模范式将\n这些领域知识抽象为能够反映真实世界的领域模型。\n\n领域驱动设计包括战略设计和战术设计两个阶段。\n\n\n运用限界上下文与通用语言进行战略设计#\n\n领域驱动设计关注的是如何在明确的限界上下文中创建通用语言的模型。\n\n限界上下文是语义和语境上的边界，边界内每个代表软件模型的组件都有着特定的含义并处理特定的事务。\n\n限界上下文是问题空间Problem Space的一部分。随着软件模型开始呈现出更深层次以及更清晰的含义是，限界上下文将会被迅速转换到解决方案空间Solution\nSpace中。\n\n\n运用子域进行战略设计#\n\n子域Sub Domain是整个业务领域的一部分，代表的是一个单一的、有逻辑的领域模型。\n\n子域主要有三种类型：\n\n * 核心域Core Domain\n * 支撑子域Supporting Subdomain\n * 通用子域Generic Subdomain","routePath":"/advance/architecture","lang":"","toc":[{"text":"编程范式","id":"编程范式","depth":2,"charIndex":19},{"text":"软件架构","id":"软件架构","depth":2,"charIndex":154},{"text":"面向对象","id":"面向对象","depth":3,"charIndex":211},{"text":"设计原则","id":"设计原则","depth":2,"charIndex":238},{"text":"架构关注点","id":"架构关注点","depth":2,"charIndex":523},{"text":"架构关注点","id":"架构关注点-1","depth":3,"charIndex":613},{"text":"组件构建基本原则","id":"组件构建基本原则","depth":2,"charIndex":643},{"text":"什么是软件架构","id":"什么是软件架构","depth":2,"charIndex":781},{"text":"业务逻辑","id":"业务逻辑","depth":2,"charIndex":1586},{"text":"架构设计的主题","id":"架构设计的主题","depth":2,"charIndex":1836},{"text":"领域驱动设计`DDD`","id":"领域驱动设计ddd","depth":2,"charIndex":-1},{"text":"运用限界上下文与通用语言进行战略设计","id":"运用限界上下文与通用语言进行战略设计","depth":3,"charIndex":2052},{"text":"运用子域进行战略设计","id":"运用子域进行战略设计","depth":3,"charIndex":2247}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"函数式编程","content":"#\n\n虽然JavaScript是一门面向对象的编程语言（确切的说是基于原型)，但是也拥有很多函数式语言的特性，例如Lambda表达式、闭包和高阶函数等。\n\n> 函数式编程是一种典型的编程范型（编程范式、程序设计法，programming paradigm）。常见的编程范型有函数式编程、面向对象编程、指令式编程等\n\n\n闭包#\n\n\n高阶函数#\n\n所谓高阶函数(higher-order function)就是操作函数的函数，它结束一个或者多个函数作为参数，并返回一个新函数。具有以下两个特点：\n\n * 函数作为参数被传递\n * 函数作为返回值输出\n\n\n柯里化#\n\n在此之前，先补充一些概念：\n\n * 一元函数，只接受一个参数的函数称为一元（unary）函数\n * 二元函数，接受两个参数的函数称为二元（binary）函数\n * 变参函数，指函数接受的参数数量是可变的\n\n函数柯里化（function currying）有称部分求值。函数柯里化就是把一个多参数函数转换为一个嵌套的一元函数的过程。\n\n一个柯里化的函数，首先会接受一些参数，接受了这些参数之后不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中暂存起来。待函数需要求值时，之前\n传入的参数都会被一次性用于求值。\n\n\n\n\n防抖与节流#\n\n\nThunk函数#\n\nThunk函数的主要的作用是实现传名调用。\n\n所谓的传名调用（call by name）是编译器一种求值策略，即函数的参数到底应该何时求值，除此之外还有传值调用（call by value）。\n\n\n\n编译器的传名调用实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。\n\n其JavaScript实现及使用如下：\n\n\n\nThunk函数可以用于Generator函数的自动流程管理。\n\n\n装饰器#","routePath":"/advance/functional","lang":"","toc":[{"text":"闭包","id":"闭包","depth":2,"charIndex":158},{"text":"高阶函数","id":"高阶函数","depth":2,"charIndex":164},{"text":"柯里化","id":"柯里化","depth":3,"charIndex":274},{"text":"防抖与节流","id":"防抖与节流","depth":3,"charIndex":549},{"text":"Thunk函数","id":"thunk函数","depth":3,"charIndex":558},{"text":"装饰器","id":"装饰器","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"LeetCode","content":"#\n\n\n滑动窗口算法#\n\n滑动窗口算法主要用于解决数组/字符串的子元素问题。可以将嵌套的循环问题，转换为单循环问题，降低时间复杂度。\n\n其主要过程是：维护一个队列或者两个指针，通过队列出队/入队或者左右两个指针的往右移动，使窗口不断向右滑动，直到最右面为止。\n\n用到该算法的有：\n\n * 3. 无重复字符的最长子串\n * 76. 最小覆盖子串\n\n\n1. 两数之和#\n\n在数组中找到2个数之和等于给定值的数字，结果返回2个数字在数组中的下标。例如：\n\n\n\n解题思路：\n\n此题其实和数组去重类似，都是查询一个值是否在数组里去重是值本身，而此题是和target之差。\n\n一开始想到的方式，是双指针循环两次，算法复杂度为O(n2)：\n\n\n\n深入思考后，其实与数组去重类似，可以用空间换时间，时间复杂度为O(n)：\n\n\n\n\n2. 两数相加#\n\n两个非空的链表，表示两个非负的整数。每位数字逆序存储的，且每个节点只存储一位数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n\n\n\n3. 无重复字符的最长子串#\n\n题目： 在一个字符串中寻找没有重复字母的最长子串\n\n\n\n\n12. 整数转罗马数字#\n\n题目：\n\n罗马数字包含以下七种字符：I、V、X、L、C、D和M。\n\n符号   十进制对应的值\nI    1\nV    5\nX    10\nL    50\nC    100\nD    500\nM    1000\n\n例如，罗马数字2写做II，即为两个并列的1。12写做XII，即为X + II。27写做XXVII，即为XX + V + II。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如4不写做IIII，而是IV。数字1在数字5的左边，所表示的数等于大数5减小数1得到的数值4。同\n样地，数字9表示为IX。这个特殊的规则只适用于以下六种情况：\n\nI可以放在V(5)和X(10)的左边，来表示4和9。 X可以放在L(50)和C(100)的左边，来表示40和90。 \nC可以放在D(500)和M(1000)的左边，来表示400和900。\n\n给定一个整数，将其转为罗马数字。输入确保在1到3999的范围内。\n\n\n\n\n13. 罗马数字转整数#\n\n\n\n\n74. 合并区间#\n\n题目： 以数组intervals表示若干个区间的集合，其中单个区间为intervals[i] = [starti,\nendi]。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。\n\n示例：\n\n输入：intervals = [[1,3],[2,6],[8,10],[15,18]]\n\n输出：[[1,6],[8,10],[15,18]]\n\n解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n\n解析：\n\n关键需要先对intervals进行排序，再从左到右遍历，合并重叠区间。\n\n否则用两次循环比较所有区间，效率会比较低。\n\n\n\n\n76. 最小覆盖子串#\n\n题目： 给两个个字符串s和t。返回s中涵盖t所有字符的最小子串。如果不存在则返回空字符串\"\"。\n\n","routePath":"/advance/leet-code","lang":"","toc":[{"text":"滑动窗口算法","id":"滑动窗口算法","depth":2,"charIndex":3},{"text":"1. 两数之和","id":"1-两数之和","depth":2,"charIndex":173},{"text":"2. 两数相加","id":"2-两数相加","depth":2,"charIndex":356},{"text":"3. 无重复字符的最长子串","id":"3-无重复字符的最长子串","depth":2,"charIndex":440},{"text":"12. 整数转罗马数字","id":"12-整数转罗马数字","depth":2,"charIndex":485},{"text":"13. 罗马数字转整数","id":"13-罗马数字转整数","depth":2,"charIndex":915},{"text":"74. 合并区间","id":"74-合并区间","depth":2,"charIndex":932},{"text":"76. 最小覆盖子串","id":"76-最小覆盖子串","depth":2,"charIndex":1236}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"微前端","content":"#","routePath":"/advance/micro-frontends","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"设计模式","content":"#\n\n设计模式由GoF在《设计模式：可复用面向对象软件的基础》一书在中提出。是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。是对被用来在特定场景下\n解决一般设计问题的类和相互通信的对象的描述。\n\n在《设计模式：可复用面向对象软件的基础》一书中提出了23中设计模式，按照模式的目的可以分为以下三类：\n\n * 创建型，用于描述怎样创建对象，主要特点是将对象的创建与使用分离，包括工厂模式、抽象工厂模式、建造者模式、单例模式和原型模式5种\n * 结构型，用于描述如何将类或对象按某种布局组成更大的结构，包括适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式和享元模式7种\n * 行为型，用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。包括策略模式，模板方法模式，发布订阅模式，迭代器模式，职责\n   链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式\n\n\n创建型#\n\n\n单例模式Singleton#\n\n单例模式，保证一个类仅有一个实例，并提供一个访问他的全局访问点。\n\n\n工厂模式FactoryMethod#\n\n定义一个用于创建对象的接口，让子类决定实例化哪个类，将一个类的实例化延迟到其子类。\n\n\n抽象工厂模式AbstractFactory#\n\n提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们的具体类。\n\n由一个抽象工厂和创建具体类的ConcreteFactory组成\n\n用户仅与抽象类定义的接口交互，而不使用特定的具体类的接口。\n\n抽象工厂AbstractFactory一般由工厂方法FactoryMethod实现。\n\n\n建造者模式Builder#\n\n将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。\n\n与抽象工厂模式相比，建造者模式着重于一步步构造一个复杂对象，而抽象工厂模式着重于多个系列的产品对象。建造者模式在最后返回产品，而抽象工厂模式是立即返回的。组合模\n式通常是用Builder生成的。\n\n\n原型模式Prototype#\n\n将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。\n\n\n结构型#\n\n\n适配器模式Adapter#\n\n适配器模式的目的是为了解决对象之间的接口不兼容的问题，通过适配器模式可以不更改源代码的情况下，让两个原本不兼容的对象在调用时正常工作。\n\n\n代理模式Proxy#\n\n代理模式是为一个对象提供一个代用品或者占位符，以便控制对它的访问。\n\n代理模式的目的是为了控制对实体对象的访问。具体可分为：\n\n * 远程代理Remote Proxy为一个对象在不同的地址空间提供局部代表\n * 虚代理Virtual Proxy根据需要创建开销很大的对象\n * 保护代理Protection Proxy控制对原始对象的访问，例如可以用于对象应该有不同的访问权限的情况下\n * 智能指引Smart Reference在访问对象时执行一些附加的操作\n\n\n装饰器模式Decorator#\n\n装饰器模式是一种动态的给对象增加职责的方式，能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。\n\n与继承相比，装饰器模式更加轻便灵活，是一种“即用即付”的方式。\n\n\n享元模式Flyweight#\n\n享元模式是一种用于性能优化的模式，其核心是运用共享技术来有效支持大量细粒度的对象。\n\n在面向对象语言中，状态模式和策略模式最好用享元模式来实现，以节省内存消耗。\n\n\n组合模式Composite#\n\n组合模式就是由一些小的子对象构建出的更大的对象，而这些小的子对象本身可能也是由多个孙对象组合而成的。\n\n组合模式将对象组合成树状结构，以表示“部分-整体”的层次结构。除了用来表示树状结构之外，组合模式的另一个好处就是通过对象的多态性表现，使得用户对单个对象和组合对\n象的使用具有一致性。\n\n\n桥接模式Bridge#\n\n将抽象与实现分离，使它们可以独立变化。用组合关系代替继承关系来实现，以降低抽象和实现的耦合度。\n\n抽象工厂模式可以用来创建和配置一个特定的桥接模式。\n\n适配器模式用来帮助无关的类协同工作，通常在系统设计完成之后才会被使用。而桥接模式则是在系统开始时就被使用，是为了抽象接口和实现部分可以独立进行改变。\n\n\n外观模式Facade#\n\n为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。\n\n外观模式适用于以下情况：\n\n * 需要为一个复杂的子系统提供一个简单接口时。对于复杂的子系统，为了使其更具可重用性和可定制性，运用的大部分设计模式都会产生更多更小的类，但也会系统使用的复杂\n   度。外观模式可以降低只需要基础功能的用户的使用难度。\n * 客户程序与抽象类的实现部分存在的很大的依赖性，外观模式可以将之与其他子系统和客户程序分离，提高子系统的独立性和可移植性\n * 构建一个层次结构的子系统时，外观模式可以定义子系统每层入口点，并且使子系统之间进通过Facade进行通信，简化依赖关系\n\n抽象工厂模式通常可以和外观模式一起使用，以提供一个接口，该接口以一种子系统独立的方式创建子系统对象。抽象工厂模式也可以代替外观模式隐藏与平台相关的类。\n\n中介者模式与外观模式的相似之处是都抽象了一些已有的类的功能。但是中介者模式的目的是\n\n外观模式只需要一个Facade对象，通常是一个单例模式。\n\n\n行为型#\n\n\n迭代器模式Iterator#\n\n提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。\n\n\n观察者模式Observer#\n\n用于定义对象间一对多依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。\n\n\n命令模式Command#\n\n命令模式是指将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开，并且可以对请求排队或记录日志，并支持可撤销的操作。\n\n其中的命令command指的是一个执行某些特定事情的指令。\n\n命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请\n求发送者和请求接收者能够消除彼此之间的耦合关系。\n\n相对于过程化的请求调用，command对象拥有更长的生命周期。对象的生命周期是跟初始请求无关的，因为这个请求已经被封装在了command对象的方法中，成为了这个\n对象的行为，我们可以在程序运行的任意时刻去调用这个方法。此外，命令模式还支持撤销、排队等操作。\n\n命令模式的由来，其实是回调callback函数的一个面向对象的替代品。\n\n\n\n命令的撤消一般是给命令对象增加一个名为unexecude或者undo的方法，执行execute的反向操作。\n\n需要撤销一系列的命令时，可以把所有执行过的命令都储存在一个历史列表中，然后倒序循环来依次执行需要撤销的命令的undo操作。\n\n对于某些无法顺利地利用undo操作让对象回到execute之前状态的情况，可以通过先回退初始状态，再把执行过的命令全部重新执行一遍来实现。\n\n\n策略模式Strategy#\n\n定义一系列的算法，把它们一个个的封装起来，并且使他们可以相互替换。\n\n\n状态模式State#\n\nGoF中的定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。\n\n将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。\n\n所使用的对象，在不同的状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。\n\n状态模式的优点：\n\n * 状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。\n * 避免Context无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了Context中原本过多的条件分支。\n * 用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。\n * Context中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。\n\n状态模式的缺点:\n\n会在系统中定义许多状态类，而且系统中会因此而增加不少对象。另外，由于逻辑分散在状态类中，虽然避开了不受欢迎的条件分支语句，但也造成了逻辑分散的问题，我们无法在一\n个地方就看出整个状态机的逻辑。\n\n状态模式和策略模式的异同\n\n相同点是都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行。\n\n区别是策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系，所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法；而在状态模式中，状态和状态\n对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情发生在状态模式内部。对客户来说，并不需要了解这些细节。\n\n\n中介者模式Mediator#\n\n中介者模式的主要作用是解除对象之间的强耦合关系，通过增加一个中介者，让所有的对象通过中介者通信，而不是相互引用，所以当一个对象发生改变时，只需要通知中介者对象即\n可。\n\n面向对象设计鼓励将行为分布到各个对象中，把对象划分成更小的粒度，有助于增强对象的可复用性，但由于这些细粒度对象之前的联系激增，又有可能反过来降低其可复用性。中介\n模式可以使各对象之间耦合松散，可以独立地改变它们之间的交互，将网状的多对多关系变成了相对简单的一对多关系。\n\n\n模板方法模式TemplateMethod#\n\n定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。\n\n模板方法模式适用于以下情况：\n\n * 一次性实现一个算法不变的部门，并将可变的部分留给子类来实现\n * 各子类中公共的行为应该被提取出来并集中到一个公用父类中以避免代码的重复\n * 控制子类扩展，模板方法只在特定点调用hook操作，也就只允许在这些点进行扩展\n\n\n职责链模式Chain of Responsibility#","routePath":"/advance/patterns","lang":"","toc":[{"text":"创建型","id":"创建型","depth":2,"charIndex":422},{"text":"单例模式Singleton","id":"单例模式singleton","depth":3,"charIndex":429},{"text":"工厂模式FactoryMethod","id":"工厂模式factorymethod","depth":3,"charIndex":480},{"text":"抽象工厂模式AbstractFactory","id":"抽象工厂模式abstractfactory","depth":3,"charIndex":544},{"text":"建造者模式Builder","id":"建造者模式builder","depth":3,"charIndex":713},{"text":"原型模式Prototype","id":"原型模式prototype","depth":3,"charIndex":876},{"text":"结构型","id":"结构型","depth":2,"charIndex":929},{"text":"适配器模式Adapter","id":"适配器模式adapter","depth":3,"charIndex":936},{"text":"代理模式Proxy","id":"代理模式proxy","depth":3,"charIndex":1021},{"text":"装饰器模式Decorator","id":"装饰器模式decorator","depth":3,"charIndex":1266},{"text":"享元模式Flyweight","id":"享元模式flyweight","depth":3,"charIndex":1374},{"text":"组合模式Composite","id":"组合模式composite","depth":3,"charIndex":1473},{"text":"桥接模式Bridge","id":"桥接模式bridge","depth":3,"charIndex":1635},{"text":"外观模式Facade","id":"外观模式facade","depth":3,"charIndex":1801},{"text":"行为型","id":"行为型","depth":2,"charIndex":2252},{"text":"迭代器模式Iterator","id":"迭代器模式iterator","depth":3,"charIndex":2259},{"text":"观察者模式Observer","id":"观察者模式observer","depth":3,"charIndex":2315},{"text":"命令模式Command","id":"命令模式command","depth":3,"charIndex":2383},{"text":"策略模式Strategy","id":"策略模式strategy","depth":3,"charIndex":2960},{"text":"状态模式State","id":"状态模式state","depth":3,"charIndex":3011},{"text":"中介者模式Mediator","id":"中介者模式mediator","depth":3,"charIndex":3695},{"text":"模板方法模式TemplateMethod","id":"模板方法模式templatemethod","depth":3,"charIndex":3933},{"text":"职责链模式Chain of Responsibility","id":"职责链模式chain-of-responsibility","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"MCP","content":"#\n\n\nMCP简介#\n\n通过一个通用的协议，解决AI应用与外部工具的集成难题，是MCP设计的出发点。\n\nMCP采用主机-客户端-服务器架构。\n\nMCP使用JSON-RPC作为客户端与服务器的通信基础。\n\n\nJSON-RPC 2.0协议规范#\n\n请求对象#\n\n字段        是否必填   类型            说明\njsonrpc   是      字符串           指定JSON-RPC协议的版本，必须为2.0\nmethod    是      字符串           表示要调用的方法名\nid        否      字符串/数字/null   用于将请求与对应的响应关联起来\nparams    否      对象/数组         包含传递给方法的参数\n\n响应对象#\n\n字段        是否必填   类型            说明\njsonrpc   是      字符串           指定JSON-RPC协议的版本，必须为2.0\nid        否      字符串/数字/null   用于将请求与对应的响应关联起来\nresult    否      对象            响应成功时必须，表示方法调用的结果\nerror     否      对象            响应失败时必须，表示错误消息\n\n批处理#\n\n请求方可以同时发送多个请求对象，并将它们封装在一个数组中。被请求方应返回一个包含对应响应对象的数组，但对于通知类型的请求，不应返回任何响应。\n\n\n\n\nMCP 连接生命周期#\n\nMCP连接生命周期主要分为三个阶段：\n\n * 初始化阶段，客户端与服务器进行协议版本和能力协商\n * 操作阶段，客户端与服务器按照协议正常通信，交换消息\n * 关闭阶段，客户端与服务器各自优雅地终止连接\n\nMCP通信双方应为所有发送的请求设置超时，以防止连接挂起和资源耗尽。当请求在超时期间未收到成功响应或收到错误响应时，发送者应发出对该请求的取消通知并停止等待响应\n。\n\nMCP通信双方应准备处理以下错误情况：\n\n * 协议版本不匹配\n * 无法协商所需能力\n * 请求超时\n\n\nMCP 传输机制#\n\nMCP支持两种主要的传输机制：stdio传输和SSE传输。\n\nstdio传输#\n\nstdio即standard input & output（标准输入/输出），是MCP推荐使用的一种传输机制，主要用于本地进程通信。\n\nSSE传输#\n\nServer-Sent Events (SSE)\n是一种Web标准，允许服务器向客户端推送实时数据。基于HTTP协议的单向通信机制，服务器可以持续向客户端发送数据流。\n\nMCP支持使用SSE传输来解决远程资源访问的问题。底层基于HTTP通信，通过类似API的方式，让客户端直接访问远程资源，而不用通过stdio传输做中转。在SSE\n传输中，服务器作为一个独立进程运行，可以处理多个客户端连接。\n\n服务器必须提供两个端点，分别是：\n\n * SSE端点，供客户端与服务器建立双向通信连接（GET请求）\n * 消息端点，供客户端向服务器发送消息（POST请求）\n\n通信步骤如下：\n\n 1. 客户端向服务器的SSE端点发送请求（一般是GET请求），建立SSE连接\n 2. 服务器通过该连接发送事件消息，告知客户端发送所需要的端点地址\n 3. 客户端根据地址向服务器发送消息请求\n 4. 服务器返回状态码，确认已接收消息\n 5. 服务器通过SSE连接向客户端推送处理结果或其他事件消息\n 6. 客户端从SSE流中持续接收服务器发送的事件消息\n 7. 通信结束之后，客户端关闭SSE连接\n\nSSE传输适用于客户端和服务器不在同一网络下的通信场景。\n\nSSE传输的主要优势如下：\n\n * 支持远程资源访问，解决了stdio传输仅适用于本地资源的问题\n * 基于HTTP实现，兼容性好，便于与现有Web基础设施集成\n * 服务器可作为独立进程运行，支持处理多个客户端连接\n * 相比WebSocket，实现更简单，因为它是HTTP的扩展，不需要协议升级\n\nSSE传输的主要劣势如下：\n\n * 复杂的双通道响应机制，SSE传输要求服务器在接收客户端消息后，既要给当前请求响应，也要给之前建立的SSE连接发送事件消息，实现复杂\n * 连接不稳定，在无服务器环境中，SSE连接会随机、频繁断开，不能提供可靠连接\n * 不方便持久连接，无服务器架构通常自动扩缩容，不适合长时间连接，而SSE需要维持持久连接\n * 需要大量会话管理，SSE传输需要为每个SSE连接分配一个唯一的标识符（sessionId）来防止数据混淆，这意味着实现方必须承担额外的会话管理工作，增加了\n   系统的实现复杂度\n * 额外实现成本，需要实现心跳检测和超时机制来避免资源泄露\n\n流式HTTP传输#\n\n在流式HTTP传输中，服务器必须提供一个同时支持POST请求和GET请求的HTTP端点。\n\n流式HTTP传输通信流程的主要步骤如下：\n\n 1. 客户端向服务器的通信端点发送消息\n 2. 服务器返回响应\n 3. 客户端继续向服务器发送下一条消息\n 4. 服务器继续响应客户端消息\n\n\nMCP服务器能力#\n\nMCP为服务器的实现提供提示词（Prompts）、资源（Resources）、工具（Tools）三大核心能力：\n\n\n提示词#\n\nMCP为服务器向客户端暴露提示词提供了一种标准方式。提示词允许服务器提供与大模型交互的结构化消息和指令。客户端可以发现可用的提示词，检索其内容，并提供自定义参数\n来使用它们。提示词被设计为由用户控制，这意味着它们从服务器暴露给客户端之后，由用户来进行选择和使用。通常，在客户端的UI界面中，用户通过输入命令来触发提示词，用\n户可以自然地发现和调用可用的提示词。\n\n\n资源#\n\nMCP为服务器向客户端暴露资源提供了一种标准方式。资源允许服务器共享为大模型提供上下文的数据，例如文件、数据库结构或特定的应用程序信息。每个资源由一个URI（U\nniform Resource Identifier，统一资源标识符）进行唯一标识。\n\nMCP中的资源被设计为由应用驱动，也就是说由主机来根据其自身的需求，将服务器的资源融入其上下文。主机可以这样实现：\n\n * 通过一个列表或者目录树，显示可用的资源\n * 允许用户搜索和筛选可用的资源\n * 将资源整合到上下文中\n\n\n工具#\n\nMCP允许服务器暴露可供大模型调用的各类工具，支持与外部系统交互，比如数据库查询、API调用、数据处理等。每一个工具必须定义唯一的标识符（name）和对其功能的\n描述（description）。\n\nMCP中的工具设计为由模型控制，这意味着大模型可以根据其对上下文的理解和用户输入的内容自动发现和选择工具。\n\n从信任和安全角度考虑，工具调用应该让用户感知，并且用户有拒绝调用工具的权利。\n\n实现工具调用的应用应该：\n\n * 提供清晰的UI，以明确展示哪些工具被暴露给了大模型\n * 当工具被调用时，视觉呈现上要有明确的提示\n * 设置弹框用来提示用户确认对工具的调用操作\n\n\nMCP客户端能力#\n\nMCP为客户端的实现提供了两个能力：\n\n * 根（root）\n * 采样（sampling）\n\n基于这两个能力，客户端可以为服务器提供文件系统访问控制和大模型代理服务。\n\n\n根#\n\nMCP为客户端提供了一种标准方式，使其能够向服务器暴露文件系统的“根”。根定义了服务器在文件系统中可以操作的边界，使它们能够理解自己有权访问哪些目录和文件。服务\n器可以从支持的客户端请求根列表，并在该列表发生变化时接收通知。\n\nMCP中的根通常通过工作区或项目配置界面暴露。例如，主机可以提供工作区/项目选择器，允许用户选择服务器有权访问的目录和文件，也可以通过版本控制系统或打开的文件自\n动检测工作区。\n\n根本质上是一种针对文件系统的访问控制机制。客户端根能力的设计，主要出于以下几方面的考虑：\n\n * 安全边界控制，为提升安全性，应限制服务器只能访问指定目录和文件，避免接触敏感或未授权的内容\n * 最小权限原则，服务器只有在需要操作文件系统时，才向客户端申请根列表，减少权限过大带来的安全风险\n * 用户控制和透明度，服务器操作文件系统时需要向客户端申请根列表，由用户选择同意或拒绝，操作过程对用户透明\n * 多项目隔离，服务器在操作不同项目时需要申请不同的根列表，实现多项目隔离\n\n\n采样#\n\nMCP为服务器提供了一种标准方式，通过客户端请求大模型采样（补全或生成内容）。此流程允许客户端保持对模型访问、选择和权限的控制，同时使服务器能够利用大模型的能力\n，而无须在服务器端设置大模型的API密钥。\n\n采样的本质是客户端为服务器调用大模型提供代理服务。客户端采样能力的设计，主要出于以下几方面的考虑：\n\n * 控制权分离与安全性。由客户端控制大模型的访问、选择和权限，服务器只关注功能实现，无须关注大模型的接入问题。大模型的API密钥由客户端统一管理，以提高安全性\n * 实现智能代理行为。服务器可以在处理复杂任务时通过客户端代理，动态调用大模型的能力。• 灵活的模型选择机制。采样允许服务器建议特定模型，并由客户端做最终决定\n * 支持多模态。采样支持文本、音频和图像交互，为复杂的AI应用场景提供基础","routePath":"/ai/mcp","lang":"","toc":[{"text":"MCP简介","id":"mcp简介","depth":2,"charIndex":3},{"text":"JSON-RPC 2.0协议规范","id":"json-rpc-20协议规范","depth":3,"charIndex":102},{"text":"请求对象","id":"请求对象","depth":4,"charIndex":121},{"text":"响应对象","id":"响应对象","depth":4,"charIndex":347},{"text":"批处理","id":"批处理","depth":4,"charIndex":585},{"text":"MCP 连接生命周期","id":"mcp-连接生命周期","depth":2,"charIndex":666},{"text":"MCP 传输机制","id":"mcp-传输机制","depth":3,"charIndex":920},{"text":"stdio传输","id":"stdio传输","depth":4,"charIndex":962},{"text":"SSE传输","id":"sse传输","depth":4,"charIndex":1040},{"text":"流式HTTP传输","id":"流式http传输","depth":4,"charIndex":2015},{"text":"MCP服务器能力","id":"mcp服务器能力","depth":2,"charIndex":2167},{"text":"提示词","id":"提示词","depth":3,"charIndex":2236},{"text":"资源","id":"资源","depth":3,"charIndex":2425},{"text":"工具","id":"工具","depth":3,"charIndex":2671},{"text":"MCP客户端能力","id":"mcp客户端能力","depth":2,"charIndex":2963},{"text":"根","id":"根","depth":3,"charIndex":3061},{"text":"采样","id":"采样","depth":3,"charIndex":3511}],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"机器学习","content":"#\n\n\n概论#\n\n机器学习是计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的学科。\n\n在机器学习中，数据并非通常意义上的数量值，而是对于对象某些性质的描述。被描述的性质叫作属性，属性的取值称为属性值，不同的属性值有序排列得到的向量就是数据，也叫实\n例。\n\n根据线性代数的知识，数据的不同属性之间可以视为相互独立，因而每个属性都代表了一个不同的维度，这些维度共同张成了特征空间。","routePath":"/ai/ml","lang":"","toc":[{"text":"概论","id":"概论","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"编译原理","content":"#\n\n> 《编译系统透视：图解编译原理》读书笔记\n\n\nC程序的运行式结构#\n\nC程序运行的核心是函数的执行和调用，它构成了整个C程序运行时结构的基础框架。这一运行过程主要是在程序指令的驱动以及数据压栈、清栈的支持下实现的。\n\n以下面的程序为例：\n\n\n\n\n程序加载时的内存概况#\n\n运行时，在内存中，共有代码区、静态数据区和动态数据区三个区域。\n\n\n\n其中，代码区装载了程序所对应的机器指令；全局变量m的数值装载在静态数据区中；动态数据区加载程序运行过程中产生的数据。\n\n程序执行的本质就是代码区的指令不断执行，驱使动态数据区和静态数据区产生数据变化。\n\nCPU中有三个寄存器，分别是eip、ebp和esp。\n\neip永远指向代码区将要执行的下一条指令，它的管控方式有两种，一种是“顺序执行”，即程序执行完一条指令后自动指向下一条执行；另一种是跳转，也就是执行完一条跳转指\n令后跳转到指定的位置。\n\nebp和esp用来管控栈空间，ebp指向栈底，esp指向栈顶。在代码区中，函数调用、返回和执行伴随着不断压栈和清栈，栈中数据存储和释放的原则是后进先出。\n\neip指向main函数的第一条指令，此时程序还没有运行，栈空间里还没有数据，ebp和esp指向的位置是程序加载时内核设置的。\n\n\n程序运行过程中的内存变化#\n\n程序开始执行main函数第一条指令(call指令)，eip自动指向下一条指令。第一条指令的执行，致使ebp的地址值被保存在栈中，保存的目的是本程序执行完毕后，e\nbp还能返回现在的位置，复原现在的栈。\n\n随着ebp地址值的压栈，esp自动向栈顶方向移动，它将永远指向栈顶。\n\n接下来，开始构建main函数自己的栈，ebp原来指向的地址值已经被保存了，此时和esp是重叠的，用来看管main函数的栈底。\n\n\n汇编中的寄存器#\n\neax, ebx, ecx, edx, esi, edi, ebp, esp等都是X86汇编语言中CPU上的通用寄存器的名称，是32位的寄存器。\n\n如果用C语言来解释，可以把这些寄存器当作变量看待。\n\n汇编名称   寄存器类型                       作用\nEAX    累加寄存器accumulator register   加法乘法指令的缺省寄存器\nEBX    基址寄存器base register          内存寻址时存放基地址\nECX    程序计数器program counter        重复REP前缀指令和LOOP指令的内定计数器\nEDX                                用来存放整数除法产生的余数\nESI    源索引寄存器source index          在很多字符串操作指令中, DS:ESI指向源串\nEDI    目标索引寄存器destination index    在很多字符串操作指令中, ES:EDI指向目标串\nEBP    基址指针base pointer            常被用作高级语言函数调用的框架指针frame pointer，存放当前线程的栈底指针\nESP    堆栈指针                        存放当前线程的栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。\nEIP    指令寄存器instrution register    存放下一个CPU指令存放的内存地址\n\n因此，在函数的起始部分经常有：\n\n\n\n\n编译过程概述#\n\n源程序是给人看的，本质上就是文本文件。需要通过编译器Compiler将源程序编译为计算机可执行的程序。\n\n编译过程主要分为词法分析、语法分析、中间代码生成、目标代码生成四个过程。\n\n\n词法分析#\n\n词法分析的作用是从连续的字符中识别出标识符、关键字、数字、运算符并存储为符号token流。\n\n词法分析器Lexer，也叫扫描器Scanner，重要功能是根据对应语言的语法规则，一个字符一个字符从源程序的字符串中识别出一个个的符号token，并按序保存。\n\nC语言的语法规则是由一个状态转换图实现的。\n\n在词法分析阶段，词法分析器能够识别出一些符号的含义，包括关键字、数字、字符串、分隔符、运算符等，但是另外一切符号需要通过前后其他符号才能确定准确含义，仅能初步判\n断是一个标识符，更多详细信息在语法分析阶段完成。\n\n\n语法分析#\n\n语法分析的作用是从词法分析识别出的token流中识别出符合对应语言语法的语句。\n\n语法分析器Parser依据用计算机表示的语法，一个符号一个符号地识别出符合C语言语法的语句。\n\n在语法分析器中把通过产生式产生的对应语言语法映射成一套模板，并把这套模板融汇在语法分析器的程序中。语法分析器的作用就是将词法分析器识别出的符号token一个一个\n地与这套模板进行匹配，匹配上这套模板中的某个语法，就可以识别出一句完整的语句，并确定这条语句的语法。\n\n语法的计算机表示就是产生式。\n\n语法分析器的最终输出是语法树AST，是一个二维结构。语法树已经承载了源程序的全部信息，后续的转换工作就和源程序没关系了。\n\n\n从语法树到中间代码再到目标代码#\n\n鉴于计算机存在着多种CPU硬件平台，考虑到程序在不同CPU之间的可移植性，需要先将语法树转换成一个通用的、抽象的CPU指令，这就是中间代码最初的设计思想。然后根\n据具体选定的CPU，将中间代码落实到具体CPU的目标代码。\n\n语法树是个二维结构，中间代码是准一维结构，语法树到中间代码的转换过程，本质上是将二维结构转换为准一维结构的过程。\n\n选定具体的CPU、操作系统后，中间代码就可以转换为目标代码——汇编代码。","routePath":"/cs/compiler","lang":"","toc":[{"text":"C程序的运行式结构","id":"c程序的运行式结构","depth":2,"charIndex":26},{"text":"程序加载时的内存概况","id":"程序加载时的内存概况","depth":3,"charIndex":126},{"text":"程序运行过程中的内存变化","id":"程序运行过程中的内存变化","depth":3,"charIndex":541},{"text":"汇编中的寄存器","id":"汇编中的寄存器","depth":2,"charIndex":759},{"text":"编译过程概述","id":"编译过程概述","depth":2,"charIndex":1461},{"text":"词法分析","id":"词法分析","depth":3,"charIndex":1562},{"text":"语法分析","id":"语法分析","depth":3,"charIndex":1828},{"text":"从语法树到中间代码再到目标代码","id":"从语法树到中间代码再到目标代码","depth":3,"charIndex":2136}],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"DSL(Domain Specific Language)","content":"#\n\n> 参考自(https://zhuanlan.zhihu.com/p/107947462)[https://zhuanlan.zhihu.com/p/10794\n> 7462]\n\nDSL 即Domain Specific Language，领域特定语言是一种为特定领域设计的，具有受限表达性的编程语言。\n\n编程语言的发展其实是一个不断抽象的过程，比如从机器语言到汇编语言然后到C之类的高级语言。汇编语言通过助记符代替机器指令操作码，极大的增强了机器语言的可读性和可维\n护性，但本质上仍是一门面向处理器和寄存器等硬件系统的低级编程语言。高级语言以上层抽象的语句(流程控制、循环等)和数据结构等更趋近自然语言和数学公式的方式解决了这\n个问题，脱离了对机器指令集的直接关联，大大提升了程序开发的效率。\n\n但在高级语言层面，抽象带来的效率提升似乎有了天花板。无论是从C到Java，抑或是各种编程范式下衍生的抽象度更高的编程语言，解决的都是通用编程问题，它们都有充分的\n过程抽象和数据抽象，导致大量的概念产生，进而影响了编程效率。\n\n而在一些专有领域的任务处理上其实不需要那么多语言特性，DSL就是在这种矛盾中产生的解决方案。它是为了解决特定任务的语言工具，比如文档编写有markdown，字符\n串匹配有RegExp，任务控制有 make、gradle，数据查找有SQL，Web样式编码有CSS等等。本质是通过限定问题域边界，从而锁定复杂度，提高编程效率。\n\nDSL有两种不同类型：外部DSL和内部DSL。\n\n\n外部DSL#\n\n**外部DSL**是一种独立的编程语言，需要从解析器开始实现自己的编译工具，实现成本较高。其语法的灵活性更高，更容易达到用户的表现力需求。\n\n外部DSL的直接对应就是GPPL(General Purpose Programming\nLanguage，通用编程语言)，由于受限语法特性更少，一般不要求图灵完备，所以它实现难度会低于GPPL。\n\n前端常用的模板引擎如mustache以及React、Vue支持的JSX语法都属于外部DSL。\n\n\n内部DSL#\n\n**内部DSL（Embedded DSL or Internal\nDSL）**是建立在其它宿主语言之上（一般为GPPL）的特殊DSL，与宿主语言共享编译与调试工具等基础设施，学习成本更低，也更容易被集成。在语法上与宿主语言同源\n，但在运行时上需要做额外的封装。\n\n也可以将内部DSL视为针对特定任务的特殊接口封装风格，比如jQuery就可以认为是针对DOM操作的一种内部DSL。","routePath":"/cs/dsl","lang":"","toc":[{"text":"外部`DSL`","id":"外部dsl","depth":2,"charIndex":-1},{"text":"内部`DSL`","id":"内部dsl","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"程序是怎样跑起来的","content":"#\n\n> 《程序是怎样跑起来的》读书笔记\n\n\nCPU#\n\nCPU由寄存器(Register)、控制器、运算器和时钟组成。其中寄存器对于程序员最重要，因为程序是把寄存器作为对象来描述的。\n\n汇编语言assembly采用助记符memonic来编写程序，每一个原本是电气信号的机器语言指令都会有一个与其相应的助记符，助记符通常为指令功能的英语单词的简写。\n例如，mov和add分别是数据的存储move和相加addition的简写。汇编语言编写的程序转化成机器语言的过程被称为汇编；反之为反汇编。\n\n根据功能的不同，寄存器大致划分为八类。在CPU中程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，基址寄存器、变址寄存器和通用寄存器都不止一个\n。\n\n\n\n\n程序计数器#\n\n程序计数器决定着程序的流程。只有1行的有用程序是很少见的，存储指令和数据的内存，是通过地址来划分的。操作系统把程序从硬盘复制到内存后，会将程序计数器设定为开始位\n置的地址。然后程序便开始运行。CPU每执行一个指令，程序计数器的值就会自动加1（当执行的指令占据多个内存地址时，增加与指令长度相应的数值）。CPU的控制器就会参\n照程序计数器的数值，从内存中读取命令并执行。\n\n\n条件分支和循环机制#\n\n程序的流程分为顺序执行、条件分支和循环三种：\n\n * 顺序执行是指按照地址内容的顺序执行指令\n * 条件分支是指根据条件执行任意地址的指令\n * 循环是指重复执行同一地址的指令\n\n顺序执行时，每执行一个指令程序计数器的值就自动加1（或指令长度相应的数值），条件分支和循环时，机器语言的指令需要将程序计数器的值设定为任意地址。这就需要用到跳转\n指令了，它会参照当前执行的运算结果来判断是否跳转。\n\n标志寄存器用来保存当前累加寄存器的运算结果是负数、零还是正数，也可以存放溢出和奇偶校验的结果。\n\n以32位CPU的标志寄存器为例，第一个字节位、第二个字节位和第三个字节位的值为1时，分别表示运算结果分别为正数、零和负数。\n\n程序中的比较指令，就是在CPU内部做减法运算。\n\n\n函数的调用机制#\n\n函数调用处理是通过把程序计数器的值设定成函数的存储地址来实现的。\n\n函数的调用需要在完成函数内部的处理后，处理流程再返回到函数调用点（函数调用指令的下一个地址）。因此单纯的跳转指令无法实现函数的调用。\n\n机器语言的call指令和return指令用来处理函数的调用。函数调用使用的是call指令。\n\n在将函数的入口地址设定到程序计数器之前，call指令会把调用函数后要执行的指令地址存储在名为栈的主存内。\n\n函数处理完毕后，再通过函数的出口来执行return命令。return命令的功能是把保存在栈中的地址设定到程序计数器中。\n\n\n通过地址和索引实现数组#\n\n数组是指同样长度的数据在内存中进行连续排列的数据构造。用一个数组名来表示全体数据，通过索引来区分数组的各个数据（元素）。\n\n通过基址寄存器和变址寄存器，可以对主内存上特定的内存区域进行划分，从而实现类似于数组的操作。一个内存区域，将开始地址存入基址寄存器，实际的内存地址等于基址寄存器\n+变址寄存器。\n\n按照功能，CPU能执行的机器语言指令大体可以分为四类：\n\n\n\n\n数据是用二进制数表示的#\n\n计算机处理信息的最小单位——位(bit)，就相当于二进制中的一位。8位二进制数被称为一个字节(Byte)。字节是最基本的信息计量单位。\n\n位是最小单位，字节是基本单位。\n\n\n移位运算和乘除运算的关系#\n\n移位运算指的是将二进制数值的各数位进行左右移位（shift=移位）的运算。有左移（向高位方向）和右移（向低位方向）两种。\n\n移位运算可以通过数位移动来代替乘法运算和除法运算。讲一个正数，左移两位表示将数值放大四倍，右移两位表示数值变为原来的1/4。\n\n\n补位#\n\n右移之后，用了填充空出来的高位的数值，有0和1两种形式。区分这两种方式，需要先掌握二进制数表示负数的方法。\n\n二进制数中表示负数值时，会把最高位作为符号来使用。符号位是0时表示正数，符号位是1时表示负数。计算机在做减法运算时，内部是通过加法运算来实现减法运算的。因此在表\n示负数时就需要使用“二进制的补数”，即用正数来表示负数。\n\n获得补数的方法是将二进制数的各数位的数值全部取反，然后再将结果加1。例如用8位二进制数表示1时为00000001，其补数为11111110，然后再加1，即为11\n111111。\n\n此时，1+(-1)的二进制表示就是00000001+11111111，最高位溢出计算机会直接忽略，得到00000000，也就是0\n\n\n逻辑右移和算术右移的区别#\n\n右移有移位后在最高位补0和补1两种情况。当二进制数的值表示图形模式而非数值时，移位后需要在最高位补0，被称为逻辑右移。\n\n将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值（0或1），被称为算术右移。其中用补数表示的负数值，右移后在空出来的最高位补1，正数则\n补0。\n\n左移时，无论是图形模式（逻辑左移）还是相乘运算（算术左移），都只需在空出来的低位补0即可。\n\n符号扩充是指在保持值不变的前提下将其转换成更高位数的二进制数。例如8位转换16位/32位。符号扩充的方法是用符号位的值（0或者1）填充高位即可。\n\n\n计算机进行小数运算时出错的原因#\n\n\n内存#\n\n高级程序语言中的数据类型表示的是占据内存区域的大小和存储在该内存区域的数据类型。\n\n计算机是进行数据处理的设备，程序表示的就是数据处理顺序和数据结构。\n\n\n内存的物理机制#\n\n内存集成电路(integrated circuit,\nIC)中有电源、地址信号、数据信号、控制信号等用于输入输出的大量引脚，用过为其指定的地址(address)，来进行数据的读写。内存是以字节为存储单位的，数据信号\n引脚共有8个。地址信号引脚的个数，能够得出内存的容量。\n\n\n内存的逻辑模型#\n\n关于内存的逻辑模型，大部分参考书都会用类似楼房的图形表示内存。1层可以存放1个字节的数据，楼层号表示就是地址。\n\n\n\n编程语言中的数据类型表示存储的是何种类型的数据。从内存来看，就是占用的内存大小（占有的楼层数），即是物理上以1个字节为单位来逐一读写数据的内存，在程序中，通过指\n定其类型（变量的数据类型等），能实现以特定字节数为单位来进行读写。对于数据而言，数据类型不同，占用的内寸大小也不一样。\n\n\n指针#\n\n指针也是一种变量，所表示的不是数据的值，而是存储着数据的内存地址。\n\n\n磁盘#\n\n磁盘是通过把其物理表面划分成多个空间来使用的。划分的方式有扇区方式和可变长方式两种，前者是指将磁盘划分为固定长度的空间，后者则是指把磁盘划分为长度可变的空间。\n\nWindows计算机所使用的硬盘和软盘，采用的都是扇区方式。扇区方式中，把磁盘表面分成若干个同心圆的空间就是磁道，把磁道按照固定大小（能存储的数据长度相同）划分\n而成的空间就是扇区。Windows中一般1个扇区是512字节,在逻辑方面（软件方面）对磁盘进行读写的单位是扇区整数倍簇。\n\n不同的文件是不能存储在同一个簇中的，因此，不管是多么小的文件，都会占用1簇的空间。因此，只有1字节的文件使用空间也了512字节。\n\n\n从源文件到可执行文件#\n\n程序给变量及函数分配了虚拟的内存地址。在程序运行时，虚拟的内存地址会转换成实际的内存地址。链接器会在EXE文件的开头，追加转换内存地址所需的必要信息。这个信息称\n为再配置信息。\n\n再配置信息会生成变量和函数的相对地址。相对地址表示的是相对于基点地址的偏移量，也就是相对距离。\n\n在源代码中，变量及函数是在不同位置分散记述的，但链接后可执行文件中，变量及函数就会变成一个连续排列的组。\n\n可执行文件的内容分为再配置信息、变量组和函数组着三部分。\n\n当程序加载到内存后，还会额外生成另外两个组，栈和堆。\n\n栈是用来存储函数内部临时使用的变量（局部变量），以及函数调用时所用的参数的内存区域。堆是用来存储程序运行时的任意数据及对象的内存领域。\n\n因而，内存中的程序，就是由用于变量的内存空间、用于函数的内存空间、用于栈的内存空间、用于堆的内存空间这4部分构成的。\n\n栈及堆的相似之处在于，他们的内存空间都是在程序运行时得到申请分配的。\n\n在内存的使用方法上，二者存在些许不同。栈中对数据进行存储和舍弃（清理处理）的代码，是由编译器自动生成的，因此不需要程序员的参与。使用栈的数据的内存空间，每当函数\n被调用时都会得到申请分配，并在函数处理完毕后自动释放。与此相对，堆的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放。\n\n如果没有在程序中明确释放堆的内存空间，那么即使在处理完毕后，该内存空间仍会一直残留。这个现象称为内存泄露（memory leak）。\n\n\n汇编语言#\n\n伪指令proc和endp围起来的部分，表示的是过程（procedure）的范围。在汇编语言中，这种相当于C语言的函数的形式称为过程。\n\n在汇编语言中，1行表示对CPU的一个指令。汇编语言指令的语法结构是操作码+操作数（也存在只有操作码没有操作数的指令）。\n\n操作码表示的是指令动作，操作数表示的是指令对象。\n\n操作数中指定了寄存器名、内存地址、常数等。\n\n","routePath":"/cs/program","lang":"","toc":[{"text":"CPU","id":"cpu","depth":2,"charIndex":22},{"text":"程序计数器","id":"程序计数器","depth":3,"charIndex":332},{"text":"条件分支和循环机制","id":"条件分支和循环机制","depth":3,"charIndex":527},{"text":"函数的调用机制","id":"函数的调用机制","depth":3,"charIndex":875},{"text":"通过地址和索引实现数组","id":"通过地址和索引实现数组","depth":3,"charIndex":1150},{"text":"数据是用二进制数表示的","id":"数据是用二进制数表示的","depth":2,"charIndex":1348},{"text":"移位运算和乘除运算的关系","id":"移位运算和乘除运算的关系","depth":3,"charIndex":1449},{"text":"补位","id":"补位","depth":3,"charIndex":1591},{"text":"逻辑右移和算术右移的区别","id":"逻辑右移和算术右移的区别","depth":3,"charIndex":1919},{"text":"计算机进行小数运算时出错的原因","id":"计算机进行小数运算时出错的原因","depth":2,"charIndex":2203},{"text":"内存","id":"内存","depth":2,"charIndex":2222},{"text":"内存的物理机制","id":"内存的物理机制","depth":3,"charIndex":2305},{"text":"内存的逻辑模型","id":"内存的逻辑模型","depth":3,"charIndex":2453},{"text":"指针","id":"指针","depth":3,"charIndex":2665},{"text":"磁盘","id":"磁盘","depth":3,"charIndex":2706},{"text":"从源文件到可执行文件","id":"从源文件到可执行文件","depth":2,"charIndex":3002},{"text":"汇编语言","id":"汇编语言","depth":2,"charIndex":3648}],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"前端工程化","content":"#\n\n\n概述#\n\n前端工程化主要解决的问题：\n\n * 传统语言或语法的弊端(ES6、TypeScript、SCSS/LESS)\n * 无法使用模块化/组件化(ES Modules、Components)\n * 重复的机械式工作(Build、Publish)\n * 代码风格统一、质量保证(git、ESLint)\n * 依赖后端服务接口支持(Mock)\n * 整体依赖后端项目(DevServer)\n\n\n前端构建#\n\n鉴于模块化，ES6、LESS等前端新技术的发展，当前的前端源代码必须经过构建之后，才能进行部署。\n\n前端的构建，主要是指将源代码转换成可执行的JavaScript、CSS、HTML代码，主要包括以下内容：\n\n * 代码转换，将TypeScript或者ES6转换成ES5，将SCSS或LESS转成CSS\n * 文件优化，压缩JavaScript、CSS、HTML代码，压缩合并图片\n * 代码分割，提取多个页面的公共代码，提取首屏不要执行的代码让其异步加载\n * 模块合并，将多个模块和文件分类合并成一个文件\n * 自动刷新，监听本地源代码的变化，自动重新构建、刷新浏览器\n * 代码校验，在代码被提交到仓库之前校验代码是否符合规范，以及单元测试是否通过\n * 自动发布，更新代码后，自动构建出线上发布代码并传输给发布系统\n\n大部分的前端构建工具基本上都是基于Node.js开发，常见的有：\n\n构建工具         简介\nNpm Script   Npm内置功能，通过在package.json的scripts字段定义任务实现\nGrunt        与Npm\n             Script类似的任务执行者，配置驱动，基于插件封装各种常见任务。集成度不高，任务非常多难以维护，资源文件较多时存在I/\n             O性能问题\nGulp         基于流的自动化构建工具，除了管理和执行任务，还支持监听文件、读写文件设计简洁，只需要通过gulp.task注册任务、gu\n             lp.run执行任务、gulp.watch监听文件、gulp.src读取文件、gulp.dest写文件代码驱动，写任务就\n             和写普通的Node.js代码一样；好用又灵活，即可单独构建又可以和其他工具搭配使用\n             对文件读取是流式操作（Stream），一次I/O可以处理多个任务\nWebpack      前端资源模块化管理和打包工具。一切皆模块，可以清晰的处理各模块之前的依赖关系。灵活可配置，基于Loader和Plugin\n             的扩展机制。可以实现按需加载。\nRollup       类似于Webpack的JavaScript模块打包器，首先引入了Tree Shaking和Scope\n             Hoisting以减小文件大小和提升运行性能。不支持Code Spliting，更适用于打包JavaScript库","routePath":"/engineering/","lang":"","toc":[{"text":"概述","id":"概述","depth":2,"charIndex":3},{"text":"前端构建","id":"前端构建","depth":2,"charIndex":200}],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"Rollup","content":"#\n\nRollup是一个JavaScript模块打包器，与webpack相比，更适用于类库的打包，最先支持Tree Shaking。\n\n\n整体结构#\n\n * Graph: 全局唯一的图，包含入口以及各种依赖的相互关系，操作方法，缓存等。是rollup的核心\n * PathTracker: 引用(调用)追踪器\n * PluginDriver: 插件驱动器，调用插件和提供插件环境上下文等\n * FileEmitter: 资源操作器\n * GlobalScope: 全局作用域，相对的还有局部的\n * ModuleLoader: 模块加载器\n * NodeBase: AST各语法(ArrayExpression、AwaitExpression等)的构造基类\n\n\n打包流程#\n\nRollup的打包流程主要可以分为输入(input)、构建(build)和输出(output)三个阶段。\n\n\n输入(input)阶段#\n\n输入(input)阶段，主要是指在命令行运行rollup后，解析命令行输入参数，到调用Rollup.rollup(inputOptions)的过程。\n\n其整个流程比较简单，主要代码都cli目录下。\n\n\n\n\n构建(build)阶段#\n\n整个构建阶段，主要是在cli/build.js中调用Rollup.rollup(inputOptions)得到一个bundle的过程，具体过程如下：\n\n\n\n最后返回的是一个包含generate方法和write的类型为RollupBuild的对象。其类型定义如下：\n\n\n\n\n输出(output)阶段#\n\n输出(output)阶段，主要通过调用bundle.generate(output)完成，bundle.generate方法在Rollup.rollup的返回值\n中。具体过程如下：\n\n\n\n\n插件Plugin#\n\nRollup插件是一个具有约定好的属性、构建钩子或输出生成钩子的对象，可以用来定制Rollup的行为。\n\n因此一个Rollup插件中最主要的就是基于约定的钩子函数。\n\n\n钩子函数的调用时机#\n\n钩子函数的调用时机有三类：\n\n * Build Hooks，Rollup.rollup(inputOptions)执行的构建钩子函数\n * Output Generation Hooks，bundle.generate()期间执行的输出钩子函数\n * Watch Change Hooks， rollup.watch执行期间监听文件变化并重新执行构建时执行的钩子函数\n\n\n钩子函数处理方式分类#\n\n钩子函数的调用主要由PluginDriver负责，主要有以下四种类型：\n\n * 异步async: 处理promise的异步钩子，即这类hook可以返回一个解析为相同类型值的promise，同步版本hook也将将被转换为sync\n * 第一个有返回值first: 如果多个插件实现了相同的钩子函数，那么会串式执行，从头到尾，但是，如果其中某个的返回值不是null也不是\n   undefined的话，会直接终止掉后续插件\n * 连续sequential:\n   如果多个插件实现了相同的钩子函数，那么会串式执行，按照使用插件的顺序从头到尾执行，如果是异步的，会等待之前处理完毕，在执行下一个插件\n * parallel: 同上，不过如果某个插件是异步的，其后的插件不会等待，而是并行执行，这个也就是我们在rollup.rollup()阶段看到的处理方式。\n\n\n构建钩子函数#\n\n构建钩子函数可以影响构建执行方式、提供构建的信息或者在构建完成后修改构建。\n\n构建钩子函数主要关注在Rollup处理输入文件之前定位、提供和转换输入文件。构建阶段的第一个钩子是options，最后一个钩子总是buildEnd。构建发生错误\n时，会触发closeBundle。\n\n在观察模式下，watchChange钩子可以在任何时候被触发，以通知新的运行将在当前运行产生其输出后被触发。当watcher关闭时，closeWatcher钩子\n函数将被触发。\n\n\n输出钩子函数#\n\n输出生成钩子函数可以提供关于生成的包的信息并在构建完成后立马执行。\n\n输出生成阶段的第一个钩子函数是outputOptions，如果输出通过bundle.generate()成功生成则第一个钩子函数是\ngenerateBundle，如果输出通过bundle.write()，另外如果输出生成阶段发生了错误的话，最后一个钩子函数则是 renderError。\n\ncloseBundle可以作为最后一个钩子被调用，但用户有责任手动调用bundle.close()来触发它。CLI将始终确保这种情况发生。","routePath":"/engineering/rollup","lang":"","toc":[{"text":"整体结构","id":"整体结构","depth":2,"charIndex":68},{"text":"打包流程","id":"打包流程","depth":2,"charIndex":330},{"text":"输入(input)阶段","id":"输入input阶段","depth":3,"charIndex":392},{"text":"构建(build)阶段","id":"构建build阶段","depth":3,"charIndex":509},{"text":"输出(output)阶段","id":"输出output阶段","depth":3,"charIndex":659},{"text":"插件Plugin","id":"插件plugin","depth":2,"charIndex":769},{"text":"钩子函数的调用时机","id":"钩子函数的调用时机","depth":3,"charIndex":865},{"text":"钩子函数处理方式分类","id":"钩子函数处理方式分类","depth":3,"charIndex":1063},{"text":"构建钩子函数","id":"构建钩子函数","depth":3,"charIndex":1455},{"text":"输出钩子函数","id":"输出钩子函数","depth":3,"charIndex":1694}],"domain":"","frontmatter":{},"version":""},{"id":13,"title":"Vite","content":"#\n\n与Webpack等传统的打包工具相比，Vite属于新一代的Bundless构建工具。\n\n主要有两个优势：\n\n * 基于浏览器内置ES Module实现，只在浏览器请求源码时进行转换并按需提供源码\n * 借助esbuild超快的编译速度对第三方依赖进行预构建。这主要是因为依赖大多为在开发时不会变动，且处理代价较高，会存在多种模块化格式（例如ESM或者Com\n   monJS）\n\n\n依赖预构建#\n\nVite将应用中的模块区分为依赖和源码两类，会在首次启动Vite时，对依赖进行预构建。\n\n主要有两个目的：\n\n * CommonJS和UMD兼容性：Vite dev\n   server将所有代码视为原生ES模块。因此，=须先将作为CommonJS或UMD发布的依赖项转换为ESM\n * 性能：Vite会将有许多内部模块的ESM依赖关系转换为单个模块，以提高后续页面加载性能。","routePath":"/engineering/vite","lang":"","toc":[{"text":"依赖预构建","id":"依赖预构建","depth":2,"charIndex":193}],"domain":"","frontmatter":{},"version":""},{"id":14,"title":"webpack","content":"#\n\n\n工作原理#\n\n\n基本概念#\n\n * Entry: 入口，执行构建的输入\n * Module: 模块，在Webpack里一切皆模块，Webpack会从Entry开始，递归找出所有依赖的模块\n * Chunk: 代码块，一个Chunk由多个模块合成，用于代码合并和分割\n * Loader: 模块转换器，用于将模块的源内容按照需求转换成新内容\n * Plugin: 扩展插件，在构建流程中的特定时机会广播对应的事件，插件可以监听这些事件，做出对应的事情\n\n\n流程#\n\nWebpack的运行流程是一个串行的过程，从启动开始依次是：\n\n 1. 初始化参数：从配置文件和Shell语句中读取与合并参数，得出最终参数\n 2. 开始编译：基于最终的参数初始化Compiler对象，加载所有配置的插件，通过执行对象的run方法开始编译\n 3. 确定入口：根据配置中的Entry找出所有入口文件\n 4. 编译模块：从入口文件出发，调用所有配置的Loader对模块递归的进行编译\n 5. 完成模块编译：得到每个模块编译后的内容及之间的依赖关系\n 6. 输出资源：根据入口及模块之前的依赖关系，组装成一个个包含多个模块的Chunk，再将每个Chunk转换成一个单独的文件加入输出列表，这是修改输出内容的最后\n    机会\n 7. 输出完成：根据配置的输出路径和文件名，将文件内容写入文件系统中\n\n在以上过程中，Webpack会在特定的时间广播特定的事件，插件在监听到特定事件后可以执行对应的逻辑，并且可以调用Webpack提供的API改变Webpack的运\n行结果。\n\n整体构建流程可以分为以下三大阶段：\n\n * 初始化，启动构建，处理配置参数，加载Plugin，实例化Compiler\n * 编译，从Entry开始，针对每个Module串行调用对应Loader去编译内容，并依据Module之间的依赖关系，递归的进行编译处理\n * 输出，将编译后的Module组合成Chunk，然后转换成文件，输出到文件系统\n\nbuild时，只执行上述阶段一次。监听模式下，将不断的执行编译，输出阶段\n\n\n模块Module#\n\n在模块化编程中，开发者将程序分解成离散功能块(discrete chunks of functionality)，并称之为模块。\n\nWebpack模块能够以各种方式表达他们的依赖关系，例如：\n\n * ES6``import语句\n\n * CommonJS``require()语句\n\n * AMD``define和require语句\n\n * css/sass/less文件中的@import语句\n\n * 样式(url(...))或HTML文件(<img src=...>)中的图片链接(image url)\n\n\nLoader#\n\n以处理SCSS文件为例：\n\n\n\n一个Loader的职责是单一的，只负责一种转换。一个源文件需要多次转换，需要配置多个Loader。在调用多个Loader时，执行顺序是从后往前依次执行\n\n\n基本写法#\n\nLoader就是一个函数，获取处理前的内容，返回处理后的内容\n\n\n\n\n可调用的Webpack API#\n\n获取Loader的options#\n\n\n\n返回其他结果#\n\n直接return可以返回原内容转换后的内容，返回其他内容需要用到this.callback函数：\n\n\n\n此外，由于Source Map生产很耗时，通常在开发环境下才生成。因此可以通过this.sourceMapAPI来配置是否生成Source Map。\n\n同步与异步#\n\n异步转换流程如下：\n\n\n\n\n处理二进制数据#\n\n对于二进制数据，需要将exports.raw = ture:\n\n\n\n\n缓存加速#\n\n可以通过this.cacheable()方法设置是否缓存计算结果，默认是开启的\n\n\n\n\n其他Loader API#\n\nAPI                                                        简介\nthis.context                                               当前处理的文件所在目录，以/src/main.js为例，为/src\nthis.resoure                                               当前处理的完整请求路径，包括query string，例如/src/main.js?name=1\nthis.resourePath                                           当前处理文件的路径，例如/src/main.js\nthis.resoureQuery                                          当前处理文件的query string\nthis.target                                                Webpack中配置的Target\nthis.loadModule(request: string, callback: function(err,   Loader在处理一个文件时，需要加入依赖时，用于获取对应文件的处理结果\nsource, sourceMap, ast))\nthis.addDependency(file: string)                           为当前处理的文件添加依赖。其依赖文件发生变化时，会重新调用loader处理该文件\nthis.addContextDependency(directory: string)               将整个目录加入到正在处理的文件依赖中\nthis.clearDependencies()                                   清除当前处理文件的多有依赖\n`this.emitFile(name: string, content: Buffer               string, sourceMap)`\n\n\nPlugin#\n\n\nCompiler和Compilation#\n\n开发Plugin最常用的两个对象就是Compiler和Compilation，他们是Plugin和Webpack之间的桥梁。\n\n * Compiler包含所有配置信息(options、loaders和plugins等)，在Webpack启动时被实例化，全局唯一。代表了整个Webpack从\n   启动到关闭的生命周期\n * Compilation包含当前的模块资源、编译生成资源和变化的文件等。在开发模式下，每当有文件变化时，就有一次新的Compilation被创建。代表了一次\n   编译过程\n\n\nTapable#\n\nWebpack通过Tapable来组织构建的事件流。Webpack中许多对象(包括Compiler和Compilation)都继承自Tapable。\n\nTapable暴露了tap, tapAsync和tapPromise方法。可以使用这些方法，注入自定义的构建步骤，这些步骤将在整个编译过程中不同时机触发。\n\n都自Tapable，可以广播和监听事件：\n\n\n\n每个插件的Compiler和Compilation对象都是同一个引用。修改Compiler和Compilation对象上的属性就会影响后面的插件。有些事件是异步\n的，插件处理完成时调用回调函数通知Webpack，才能进入下一个流程。\n\n\n\n\n基本写法#\n\nPlugin主要通过监听Webpack在运行的生命周期中广播的特定事件，在合适的时机通过Webpack提供的API做出对应的处理，改变输出结果\n\n一个Plugin就是一个类，具体写法如下：\n\n\n\nWebpack启动后，读取配置过程中会初始化插件实例。在初始化compiler对象之后，在调用插件的apply方法，为实例传入compiler对象。插件实例在获\n取到compiler对象后，通过 compiler.plugin(event: string, callback:\nfunction(compilation))监听Webpack广播的事件，通过compiler对象去操作Webpack\n\n\n常用API#\n\n插件可以用来修改输出文件和增加输出文件，甚至提升Webpack性能\n\n读取输出资源、代码块、模块及依赖#\n\nemit事件发生时，代表源文件的转换和组装已经完成，可以读取到最终输出的资源、代码块、模块及其依赖，并修改输出资源的内容\n\n\n\n\n热更新原理#\n\nSSE","routePath":"/engineering/webpack","lang":"","toc":[{"text":"工作原理","id":"工作原理","depth":2,"charIndex":3},{"text":"基本概念","id":"基本概念","depth":3,"charIndex":11},{"text":"流程","id":"流程","depth":3,"charIndex":230},{"text":"模块Module","id":"模块module","depth":2,"charIndex":888},{"text":"Loader","id":"loader","depth":2,"charIndex":1154},{"text":"基本写法","id":"基本写法","depth":3,"charIndex":1257},{"text":"可调用的Webpack API","id":"可调用的webpack-api","depth":3,"charIndex":1299},{"text":"获取`Loader`的`options`","id":"获取loader的options","depth":4,"charIndex":-1},{"text":"返回其他结果","id":"返回其他结果","depth":4,"charIndex":1338},{"text":"同步与异步","id":"同步与异步","depth":4,"charIndex":1475},{"text":"处理二进制数据","id":"处理二进制数据","depth":3,"charIndex":1497},{"text":"缓存加速","id":"缓存加速","depth":3,"charIndex":1542},{"text":"其他Loader API","id":"其他loader-api","depth":3,"charIndex":1593},{"text":"Plugin","id":"plugin","depth":2,"charIndex":2564},{"text":"Compiler和Compilation","id":"compiler和compilation","depth":3,"charIndex":2574},{"text":"Tapable","id":"tapable","depth":3,"charIndex":2847},{"text":"基本写法","id":"基本写法-1","depth":3,"charIndex":3157},{"text":"常用API","id":"常用api","depth":3,"charIndex":3463},{"text":"读取输出资源、代码块、模块及依赖","id":"读取输出资源代码块模块及依赖","depth":4,"charIndex":3506},{"text":"热更新原理","id":"热更新原理","depth":3,"charIndex":3590}],"domain":"","frontmatter":{},"version":""},{"id":15,"title":"CSS","content":"#\n\n\nflex布局#\n\n用flex布局实现垂直水平居中：\n\n\n\nflex的核心的概念就是容器和轴。容器包括外层的父容器和内层的子容器，轴包括主轴和交叉轴。flex 布局涉及到 12 个 CSS 属性（不含 display:\nflex）。\n\n\n容器#\n\n容器具有这样的特点：父容器可以统一设置子容器的排列方式，子容器也可以单独设置自身的排列方式，如果两者同时设置，以子容器的设置为准。\n\n父容器#\n\n\n\n子容器#\n\n\n\n\n轴#\n\n轴包括主轴和交叉轴，justify-content属性决定子容器沿主轴的排列方式，align-items属性决定子容器沿着交叉轴的排列方式。flex-direc\ntion属性决定主轴的方向，交叉轴的方向由主轴确定。\n\n\n\n\n进阶概念#\n\n父容器#\n\n\n\n轴向与换行组合设置：flex-flow\n\n子容器#\n\n设置基准大小：flex-basis\n\n设置扩展比例：flex-grow\n\n设置收缩比例：flex-shrink\n\n设置排列顺序：order\n\n\nBFC#\n\n文档流分为定位流、浮动流和普通流三种。\n\nFC是formatting\ncontext的首字母缩写，即格式化上下文，是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局以及和其他元素之间的关系和作用。\n\n常见的FC有BFC、IFC（行级格式化上下文），还有GFC（网格布局格式化上下文）和FFC（自适应格式化上下文）\n\nBFC(Block formatting context)是块级格式化上下文，是一个独立的渲染区域，只有Block-level box参与，\n它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。\n\nBFC可以简单的理解为某个元素的一个CSS属性，只不过这个属性不能被开发者显式的修改，拥有这个属性的元素对内部元素和外部元素会表现出一些特性，这就是BFC。\n\n\n触发条件：#\n\n 1. 根元素，即HTML元素\n 2. float的值不为none\n 3. overflow的值不为visible\n 4. display的值为inline-block、table-cell、table-caption\n 5. position的值为absolute或fixed\n\n\nBFC布局规则：#\n\n 1. 内部的Box会在垂直方向，一个接一个地放置。\n 2. Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠，所以要解决margin会发生重叠的问题就要把它用不同的\n    BFC分隔开\n 3. 每个元素的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n 4. BFC的区域不会与float box重叠。\n 5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n 6. 计算BFC的高度时，浮动元素也参与计算\n\n\nBFC有哪些作用：#\n\n 1. 自适应两栏布局\n 2. 可以阻止元素被浮动元素覆盖\n 3. 可以包含浮动元素——清除内部浮动\n 4. 分属于不同的BFC时可以阻止margin重叠\n\n\n移动端1px问题#","routePath":"/fe/css","lang":"","toc":[{"text":"`flex`布局","id":"flex布局","depth":2,"charIndex":-1},{"text":"容器","id":"容器","depth":3,"charIndex":121},{"text":"父容器","id":"父容器","depth":4,"charIndex":193},{"text":"子容器","id":"子容器","depth":4,"charIndex":201},{"text":"轴","id":"轴","depth":3,"charIndex":210},{"text":"进阶概念","id":"进阶概念","depth":3,"charIndex":326},{"text":"父容器","id":"父容器-1","depth":4,"charIndex":333},{"text":"子容器","id":"子容器-1","depth":4,"charIndex":362},{"text":"BFC","id":"bfc","depth":2,"charIndex":440},{"text":"触发条件：","id":"触发条件","depth":3,"charIndex":805},{"text":"BFC布局规则：","id":"bfc布局规则","depth":3,"charIndex":955},{"text":"BFC有哪些作用：","id":"bfc有哪些作用","depth":3,"charIndex":1259},{"text":"移动端1px问题","id":"移动端1px问题","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":16,"title":"React Hooks","content":"#\n\n\nClass Component面临的问题#\n\nClass Component存在以下两个问题：\n\n 1. 业务逻辑分散。业务逻辑分散在不同生命周期中，造成同一个生命周期中包含多种不相关逻辑，也会造成同一个业务逻辑被分割到不同生命周期中。\n 2. 有状态的逻辑复用困难。由于逻辑被分割到不同生命周期中，导致跨组件复用有状态的逻辑困难。虽然有HOC和Render\n    Props等模式可以解决这个问题，但也为组件结构引入了新的复杂度。\n\n\nSuspense#\n\nSuspense是React 16.6引入的一个新特性，用于处理异步操作。它允许在子组件完成加载前展示后备方案。\n\nSuspense对应的子节点包括Offscreen和Fallback两个child。当处于suspend(挂起状态)时，会展示Fallback组件。","routePath":"/framework/react/hooks","lang":"","toc":[{"text":"Class Component面临的问题","id":"class-component面临的问题","depth":2,"charIndex":3},{"text":"Suspense","id":"suspense","depth":2,"charIndex":223}],"domain":"","frontmatter":{},"version":""},{"id":17,"title":"React","content":"#\n\n\n组件#\n\n组件允许你将UI拆分为独立可复用的代码片段，并对每个片段进行独立构思。\n\n组件，从概念上类似于JavaScript函数。它接受任意的入参props，并返回用于描述页面展示内容的React元素。\n\nReact组件分为函数组件与class组件。\n\n\nHook#\n\nHook是React16.8 的新增特性。可以在不编写class的情况下使用state以及其他的React特性。\n\nHook为已知的React概念提供了更直接的API：props， state，context，refs以及生命周期。\n\n可以使用Hook从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook可以在无需修改组件结构的情况下复用状态逻辑。这使得在组件间或社区内共享Hook变得\n更便捷。\n\n * 利于组件预编译，更易于优化\n * class组件会无意中鼓励开发者使用一些让优化措施无效的方案\n * class不能很好的压缩，并且会使热重载出现不稳定的情况\n\nHook是一些可以让你在函数组件里“钩入”React state及生命周期等特性的函数。\n\n\nState Hook#\n\nuseState通过在函数组件里调用它来给组件添加一些内部 state。React会在重复渲染时保留这个state。\n\n不同于 class 组件state必须为一个对象，useState可以接受一个基本类型，也可以接受引用类型。\n\n返回一对值：当前状态state和一个可以更新它的函数setState，可以在事件处理函数中或其他一些地方调用这个函数。\n\nuseState类似于class组件的this.setState，但是它不会把新的state和旧的state进行合并。\n\nstate不一定要是一个对象，且这个初始state参数只有在第一次渲染时会被用到\n\n具体示例如下：\n\n\n\nReact假设当你多次调用useState的时候，你能保证每次渲染时它们的调用顺序是不变的\n\n\nEffect Hook#\n\nEffect\nHook可以让你在函数组件中执行副作用操作，类似于componentDidMount、componentDidUpdate、componentWillUnmou\nnt这三个生命周期。\n\nEffect\nHook会在每次渲染后都执行。但是与componentDidMount或componentDidUpdate不同，使用useEffect调度的effect不会阻\n塞浏览器更新屏幕，这让你的应用看起来响应更快。如果需要阻塞视图更新，可以使用useLayoutEffect Hook\n\n在React组件中有两种常见副作用操作：需要清除的和不需要清除的。需要清除的effect可以在useEffect中返回一个函数，React将会在执行清除操作时调\n用它。\n\nReact会在执行当前effect之前对上一个effect进行清除。\n\n如果某些特定值在两次重渲染之间没有发生变化，可以通过传递数组作为useEffect的第二个可选参数，通知 React 跳过对 effect 的调用。\n\n如果想执行只运行一次的effect（仅在组件挂载和卸载时执行），可以传递一个空数组[]作为第二个参数。\n\n具体见下例：\n\n\n\n\nHook规则#\n\nHook 就是JavaScript函数，但是要注意两点规则：\n\n * 只能在函数最外层调用Hook，不能在循环、条件判断或者子函数中调用。这样能确保Hook在每一次渲染中都按照同样的顺序被调用。让React能够在多次的use\n   State和useEffect调用之间保持hook状态的正确\n * 只能在React的函数组件中调用Hook，不要在其他 JavaScript函数中调用。另外自定义的Hook中也可以调用\n\nReact靠的是Hook调用的顺序来确定哪个state对应哪个useState\n\n\n其他Hook#\n\nuseContext接收一个context对象（React.createContext的返回值）并返回该context的当前值。\n\n\n\nuseReducer，useState的替代方案。接收一个形如(state, action) => newState的reducer，并返回当前的state\n以及与其配套的dispatch方法。\n\n\n\nuseLayoutEffect其函数签名与useEffect相同，但它会在所有的DOM变更之后同步调用effect，会阻塞视图更新\n\n\n自定义Hook#\n\n自定义Hook是一个函数，其名称以use开头，函数内部可以调用其他的Hook。\n\n\nReact的生命周期#\n\n * componentDidMount，组件第一次被渲染到DOM中的时候\n * componentWillUnmount，组件被删除的时候\n\n当组件实例被创建并插入DOM中时(挂载)，其生命周期调用顺序如下：\n\n * constructor()\n * static getDerivedStateFromProps()\n * render()\n * componentDidMount()\n\n当组件的props或state发生变化时会触发更新。组件更新的生命周期调用顺序如下：\n\n * static getDerivedStateFromProps()\n * shouldComponentUpdate()\n * render()\n * getSnapshotBeforeUpdate()\n * componentDidUpdate()\n\n当组件从DOM中移除(卸载)时会调用如下方法：\n\n * componentWillUnmount()\n\n错误处理，当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：\n\n * static getDerivedStateFromError()\n * componentDidCatch()\n\n\nFiber#\n\n\nReact架构#\n\nReact 15架构可以分为两层：\n\n * Reconciler协调器：负责找出变化的组件\n * Renderer渲染器：负责将变化的组件渲染到页面上\n\nReact 16架构可以分为三层：\n\n * Scheduler调度器：调度任务的优先级，高优任务优先进入Reconciler\n * Reconciler协调器：负责找出变化的组件\n * Renderer渲染器：负责将变化的组件渲染到页面上","routePath":"/framework/react/","lang":"","toc":[{"text":"组件","id":"组件","depth":2,"charIndex":3},{"text":"Hook","id":"hook","depth":2,"charIndex":131},{"text":"`State Hook`","id":"state-hook","depth":3,"charIndex":-1},{"text":"`Effect Hook`","id":"effect-hook","depth":3,"charIndex":-1},{"text":"`Hook`规则","id":"hook规则","depth":3,"charIndex":-1},{"text":"其他`Hook`","id":"其他hook","depth":3,"charIndex":-1},{"text":"自定义`Hook`","id":"自定义hook","depth":3,"charIndex":-1},{"text":"`React`的生命周期","id":"react的生命周期","depth":2,"charIndex":-1},{"text":"Fiber","id":"fiber","depth":2,"charIndex":2450},{"text":"`React`架构","id":"react架构","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":18,"title":"React原理","content":"#\n\n\n前端框架原理概览#\n\n现代前端框架的实现原理：UI=f(state)，框架内部运行机制根据当前状态渲染视图。\n\n其中：\n\n * state代表当前视图状态\n * f代表框架内部运行机制\n * UI代表宿主环境的视图\n\n为了实现UI与逻辑的关注点分离，需要一种存放 UI与逻辑的松散耦合单元，这就是组件。 组件通过是那种方式组织逻辑与 UI：\n\n * 逻辑中的自变量变化，导致UI变化\n * 逻辑中的自变量变化，导致“无副作用因变量”变化，导致 UI变化，例如useMemo，computed等\n * 逻辑中的自变量变化，导致“有副作用因变量”变化，导致副作用，例如useEffect，watchEffect，autorun等\n\n在前端框架中，组件内部定义的自变量被称为state(状态)，其他组件传递而来的自变量成为props(属性)。当自变量需要跨层级传递时，可以通过store实现。R\neact 主要通过Context实现。\n\n前端框架可以根据与自变量建立对应关系的抽象层级分为以下三类：\n\n * 应用级框架，如React\n * 组件级框架，如Vue\n * 元素级框架，如Svelte\n\n\nReact16 架构#\n\n相较于 React15，React16 中新增了Scheduler（调度器），分为以下三层：\n\n * Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler\n * Reconciler（协调器）—— 负责找出变化的组件\n * Renderer（渲染器）—— 负责将变化的组件渲染到页面上\n\n在 React 工作流程中：\n\n * Reconciler工作的阶段被称为render阶段。因为在该阶段会调用组件的render方法\n * Renderer工作的阶段被称为commit阶段。就像你完成一个需求的编码后执行git\n   commit提交代码。commit阶段会把render阶段提交的信息渲染在页面上\n * render与commit阶段统称为work，即React在工作中。相对应的，如果任务正在Scheduler内调度，就不属于work\n\n\nReact理念#\n\nReact使用JavaScript构建快速响应的大型 Web应用程序的首选方式。\n\n * CPU瓶颈，当执行大计算量的操作或者设备性能不足时，页面掉帧，导致卡顿\n * I/O 瓶颈，进行I/O操作后需要等待数据返回才能继续操作，等待的过程导致不能快速响应\n\nReact的发展阶段：\n\n * Sync同步模式\n * Async Mode异步模式\n * Concurrent Mode并发模式\n * Concurrent Feature并发特性\n\nReact各版本重要更新点\n\n * React 16将同步的不可中断的递归渲染重构为异步的、可中断的链表遍历，为后续的并发特性打下基础\n * Reat 17通过重构事件系统等底层，为React 18的并发更新以及大型应用的渐进式升级铺平道路，确保生态的平稳过渡\n * React 18引入并发渲染（Concurrent\n   Rendering），允许React同时准备多个版本的UI，并能根据优先级中断或继续渲染。新增了startTransition（保持UI响应）和Suspe\n   nse SSR（流式页面加载）等强大功能\n * React\n   19专注于提升开发体验。通过Actions等特性，将数据变更、表单处理、乐观更新等常见场景进行抽象和简化，支持更声明式、更少的代码来完成更多工作\n\n\nReact Reconciler的 render阶段#\n\nReconciler的工作流程主要是采用 DFS(深度优先遍历)的顺序构建 Wip Fiber\nTree，主要分为“递”beginWork和“归”completeWork 两个阶段：\n\n * beginWork根据当前 fiberNode 创建下一级fiberNode，在 update时标记\n   Placement(新增、移动)、ChildDeletion(删除)。\n * completeWork在 mount时构建 DOM Tree, 初始化属性，在 update时标记 Update(属性更新)，最终执行 flags冒泡。\n\n最终 HostRootFiber完成completeWork后，Reconciler的工作流程结束，可以得到：\n\n * 代表本次更新的Wip Fiber Tree\n * 被标记的 flags\n\nHostRootFiber对应的 FiberRootNode传递给 Renderer进行 commit阶段的工作\n\n\nReact Renderer的commit阶段#\n\ncommit阶段始于React Reconciler的commitRoot方法，是同步执行，不可打断的。有三个子阶段：\n\n * BeforeMutation 阶段\n * Mutation 阶段\n * Layout 阶段\n\n\nBeforeMutation 阶段#\n\n主要处理以下两种类型的 FiberNode:\n\n * ClassComponent，执行 getSnapshowBeforeUpdate方法\n * HostRoot，清空挂载内容，方便Mutation阶段渲染\n\n\nMutation 阶段#\n\n在 react-dom 中，对于HostComponent，主要进行 DOM\n元素的增、删、改操作。其他类型的Component处理与组件相关的副作用和生命周期。\n\n主要包括：\n\n * 副作用处理： ○ 处理函数组件的useEffect和useLayoutEffect的清理函数 ○ 处理类组件的componentWillUnmount\n   生命周期\n * Ref 处理 ○ 从 DOM 中移除 ref ○ 从组件实例中移除 ref\n * 子组件遍历 ○ 递归处理子组件的变更 另外，当Mutation阶段的主要工作完成之后，会进行 Fiber Tree的切换\n\n\nLayout 阶段#\n\nLayout 阶段在DOM已经被修改之后，在浏览器绘制之前。所有Layout的副作用都是同步调用的，不会被延迟或打断。\n\n目的是为了允许开发者在 DOM 变更后、用户看到更新前、读取 DOM布局信息或执行必须同步完成的操作。\n\nLayout阶段向下遍历过程中，会执行 OffscreenComponent的显隐逻辑。\n\n向上遍历过程中，会根据 fiberNode.tag 不同执行不同操作：\n\n * 对于 ClassComponent，执行 componentDidMount/Update 方法\n * 对于 FC，执行 useLayoutEffect callback\n\n\nReact Scheduler#\n\nScheduler预置了五种优先级：\n\n * ImmediatePriority立即执行, 优先级最高，同步执行\n * UserBlockingPriority用户阻塞\n * NormalPriority正常执行\n * LowPriority低优先级\n * IdlePriority空闲时执行\n\nScheduler调度的主要数据结构为Task:\n\n\n\n\nScheduler的执行流程#\n\nScheduler的执行流程如下：\n\n 1. 根据是否传递delay参数，执行scheduleCallback方法后生产的task会进入timerQueue或taskQueue, 其中\n\n * timerQueue中的task以currentTime + delay为排序依据\n * taskQueue中的task以expirationTime为排序依据\n\n 2. 当timerQueue中第一个task延时时间到期后，执行advanceTimers将其移动到taskQueue中\n 3. 执行requestHostCallback在新的宏任务中执行workLoop方法\n 4. workLoop方法循环消费taskQueue中的task（即执行task.callback）, 直到taskQueue为空或Time\n    Slice时间用尽且当前task未过期(currentTask.expirationTime > currentTime)时中断循环\n 5. 如果taskQueue不为空，则进入步骤3，如果timerQueue不为空，则进入步骤2\n\nworkLoop执行的时机选择，在支持setImmediate的环境下使用setImmediate，在支持MessageChannel的环境下使用Message\nChannel，在不支持以上两种环境下使用setTimeout。\n\n\n优先级队列#\n\n优先级队列使用的数据结构为小顶堆，其特点是：\n\n * 是一个完全二叉树（除最后一层外，其他层的节点个数都是满的，且最后一层的节点都靠左填充）\n * 堆中每个节点的值都小于等于其子树的每一个节点的值\n\n完全二叉树适合用数组保存，用数组下标代替指向左右节点的指针。\n\n堆包含以下三个方法：\n\n * push向堆中推入元素\n * pop从堆顶取出元素\n * peek获取排序依据最小的对应节点\n\npush和pop方法都涉及堆化操作，即在插入、取出节点时对堆重新排序。堆化操作的时间复杂度与二叉树的高度正相关，为O(log n)。\n\n\nReact Lane模型#\n\nReact的Lane模型是并发调度系统Concurrent\nMode的核心组成部分，借鉴了操作系统中常见的优先级调度思想，通过将更新任务抽象为车道Lane，实现了对不同优先级任务的灵活调度与中断恢复机制。\n\n\nLane优先级#\n\nLane是一个32bit Integer，最高位为符号位，总共有31个不同的优先级，越低的位优先级越高。具体如下：\n\n\n\nLanes代表一个或者多个Lane的集合。\n\n","routePath":"/framework/react/source","lang":"","toc":[{"text":"前端框架原理概览","id":"前端框架原理概览","depth":2,"charIndex":3},{"text":"React16 架构","id":"react16-架构","depth":2,"charIndex":500},{"text":"React理念","id":"react理念","depth":2,"charIndex":905},{"text":"React Reconciler的 render阶段","id":"react-reconciler的-render阶段","depth":2,"charIndex":1489},{"text":"React  Renderer的commit阶段","id":"react--renderer的commit阶段","depth":2,"charIndex":-1},{"text":"BeforeMutation 阶段","id":"beforemutation-阶段","depth":3,"charIndex":2080},{"text":"Mutation 阶段","id":"mutation-阶段","depth":3,"charIndex":2207},{"text":"Layout 阶段","id":"layout-阶段","depth":3,"charIndex":2505},{"text":"React Scheduler","id":"react-scheduler","depth":2,"charIndex":2805},{"text":"`Scheduler`的执行流程","id":"scheduler的执行流程","depth":3,"charIndex":-1},{"text":"优先级队列","id":"优先级队列","depth":3,"charIndex":3612},{"text":"React Lane模型","id":"react-lane模型","depth":2,"charIndex":3884},{"text":"Lane优先级","id":"lane优先级","depth":3,"charIndex":4004}],"domain":"","frontmatter":{},"version":""},{"id":19,"title":"全局API","content":"#\n\n\nVue3入口-createApp#\n\n相比较于Vue 2通过构造函数new Vue()的方式创建根Vue实例，Vue 3改为了通过调用 createApp返回一个应用实例：\n\n\n\ncreateApp源码位于@vue/runtime-dom/src/index.ts：\n\n\n\nensureRenderer\n\n\n\ncreateRenderer位于@vue/runtime-core/renderer.ts，调用了同文件的baseCreateRenderer，其代码如下：\n\n\n\n因为在createApp中只使用到了render.createApp，所以我们把无关代码省略，可以看到render.createApp是由createAppAP\nI生成的，代码位于@vue/runtime-core/apiCreateApp.ts第114行，其作用是返回一个createApp方法，用于生成一个AppCon\ntext和一个App，其作用相当于Vue2的new Vue()，代码如下：\n\n\n\n\nApp的mount过程#\n\n由于在@vue/runtime-dom/src/index.ts的createApp函数中重写了app.mount方法，所以App的mount入口在这里：\n\n\n\n主要做了以下的操作，将选择器转行成DOM，将container清空，调用app原来的mount方法，并对DOM的属性做了一些操作\n\napp原来的mount方法位于@vue/runtime-core/apiCreateApp.ts的createAppAPI中，其主要内容为，将App组件内容生成\nVNode，将vnode.appContext设置上，调用render(vnode,\nrootContainer)渲染组件，将闭包里的isMounted设置成true，将rootContainer设置给app._container，将vnode.\ncomponent!.proxy返回。\n\n","routePath":"/framework/vue3/api","lang":"","toc":[{"text":"Vue3入口-createApp","id":"vue3入口-createapp","depth":2,"charIndex":3},{"text":"App的mount过程","id":"app的mount过程","depth":2,"charIndex":444}],"domain":"","frontmatter":{},"version":""},{"id":20,"title":"编译器","content":"#\n\n在Vue3中，编译器主要负责把模板编译成渲染render函数。Vue模板属于领域特定语言(DSL)。其编译过程与通用语言的编译过程有所不同。\n\n完整的编译过程通常包含以下步骤：\n\n * 【编译前端】词法分析\n * 【编译前端】语法分析\n * 【编译前端】语义分析\n * 【编译后端】中间代码生成\n * 【编译后端】优化\n * 【编译后端】目标代码生成\n\nVue模板的编译过程如下：\n\n * 词法分析\n * 语法分析，得到模板AST\n * 将模板AST转换成JavaScript AST\n * 根据JavaScript AST生成JavaScript代码","routePath":"/framework/vue3/compiler","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":21,"title":"组件","content":"#\n\n对于Vue3的使用者而言，组件就是一个选项对象。\n\n对于渲染器而言，组件是一个特殊类型的VNode，vnode.type是组件定义本身。在渲染器中，组件的渲染是由processComponent函数负责的","routePath":"/framework/vue3/component","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":22,"title":"概述","content":"#\n\n\n关于本文#\n\n本文通过对Vue3源码删繁就简，深入了解Vue3内部实现逻辑。并结合与Vue2的对比，分析两者之间的异同。\n\nVue3新增了Composition\nAPI组合式API，能够通过较低级别的数据驱动视图和组件生命周期，将与同一个逻辑关注点相关的代码配置在一起。从而实现一种更自由形式的编写组件逻辑的方式。\n\nVue3的核心逻辑是基于Composition API的，对于Options API采用兼容处理。\n\n\nVue3与Vue2的对比#\n\n * 对于数据变动的监听，Vue2基于Object.defineProperty实现，而Vue3基于Proxy实现\n * Vue2使用JavaScript + Flow开发，而Vue3使用TypeScript开发\n * Vue2采用面向对象的编程范式，而Vue3采用的是函数式编程\n * Vue3新增了组合式API(Composition API)，兼容了原来的Option API，而Vue2是基于Option API的\n\n\nVue3的整体结构#\n\nVue3主要由数据响应系统reactivity、渲染器renderer、编译器compiler这三部分组成。","routePath":"/framework/vue3/","lang":"","toc":[{"text":"关于本文","id":"关于本文","depth":2,"charIndex":3},{"text":"Vue3与Vue2的对比","id":"vue3与vue2的对比","depth":2,"charIndex":214},{"text":"Vue3的整体结构","id":"vue3的整体结构","depth":2,"charIndex":443}],"domain":"","frontmatter":{},"version":""},{"id":23,"title":"数据响应式系统","content":"#\n\nVue3的数据响应式系统主要由@vue/reactivity承担，主要包括副作用函数effect，依赖收集track和触发更新trigger这三部分。\n\nComposition API实现响应式的关键API为包装基本类型的ref和引用类型的reactive。\n\n\nreactive#\n\n仅对简单的对象的reactive过程做考虑的话，代码如下：\n\n\n\n逻辑很简单，就是通过Proxy返回目标的对象的代理，并将目标的对象和代理的映射关系缓存到一个proxyMap中，其代理的handlers内容如下：\n\n\n\n我们先只关注基本的get和set ProxyHandler，其逻辑也比较简单。其中get ProxyHandler除了调用默认的Reflect\nAPI，就是调用了track方法。类似的，set ProxyHandler除了调用默认的Reflect\nAPI以外，根据目标对象target中是否有要set的key，没有时调用了TriggerOpTypes.ADD类型的trigger方法，已经有key，并且值发生\n了改变时，调用了TriggerOpTypes.SET类型的trigger方法。\n\n\n依赖收集与触发#\n\nVue3中的依赖以副作用函数effect的方式体现。副作用函数就是指会产生副作用的函数，就是该函数的执行会直接或者间接影响其他的函数的执行，例如更新DOM，修改\n作用域以外的变量等。\n\ntrack和trigger主要负责依赖的收集(追踪)和触发，类似于Vue2中的Dep，分别在响应式数据get和set操作中被执行。用于将响应式数据和effect\n关联起来。\n\n这两个方法位于@vue/reactivity/src/effect.ts文件中，在解析这两个方法之前，需要先对这两个方法依赖的几个局部变量做下说明：\n\n\n\ntargetMap是一个WeakMap，其key目标对象target，其value是一个以目标对象target的key为key、其依赖的集合为value的Map\n，所以targetMap是一个所有目标对象target的依赖集合的映射总集合。\n\nactiveEffect为当前激活状态的effect，具体在effect分析\n\nshouldTrack用于表示是否需要开始依赖收集，trackStack用于标识当前依赖收集的深度。主要用于effect方法中。\n\n\ntrack#\n\n精简后代码如下：\n\n\n\n从上面代码可以知道，track的逻辑非常简单，就是向targetMap的具体dep中加入当前activeEffect，并像activeEffect的deps中加\n入对于的dep。\n\n\ntrigger#\n\n\n\ntrigger的主要逻辑为在targetMap中去除对应的depsMap，然后根据不同的数据类型，不同的TriggerOpTypes，触发对应的effect。更\n新方式有异步更新队列和立即更新两种。\n\n\neffect#\n\neffect方法返回ReactiveEffect函数，作用相当于vue2中的观察者Watcher。简化后代码如下：\n\n\n\n\n异步更新队列#\n\n\n原来的分析#\n\nreactive方法源码位于@vue/reactivity/src/reactive.ts的第63行，其逻辑很简单，先判断是否为readonly，如果是，直接返\n回target，否则调用createReactiveObject方法：\n\n\n\ncreateReactiveObject方法位于同文件的第136行：\n\n\n\n在new\nProxy，根据TargetType分别使用了collectionHandlers和baseHandlers，先看下baseHandlers其值由reactiv\ne调用时传入的实参mutableHandlers，其定义位于@vue/reactivity/src/baseHandlers.ts的第187行：\n\n\n\n接下来我们一次看下对应的ProxyHandler:\n\n\nget#\n\nmutableHandlers的get``ProxyHandler定义位于同文件的第35行，调用了同文件的第72行的createGetter。\n\n\n\n其主要逻辑为调用@vue/reactivity/src/effect.ts的第141行的track方法，并且根据类型对值进行如下的特殊处理：将ref执行unwr\nap，引用类型递归转为proxy。\n\ntrack方法主要作用是追踪响应，将需要被追踪的对象作为键更新到全局的depsMap里，并与activeEffect关联起来，相当于Vue2中的Dep。\n\n\n\n\nset#\n\nmutableHandlers的set ProxyHandler定义位于同文件的第125行，调用了同文件的第128行的createGetter。\n\n\n\n当target为引用类型是set ProxyHandler会根据是否hadKey分别调用TriggerOpTypes类型为SET/ADD类型的trigger。\n\ntrigger代码位于@vue/reactivity/src/effect.ts的第167行，是响应的触发器，\n\n","routePath":"/framework/vue3/reactivity","lang":"","toc":[{"text":"reactive","id":"reactive","depth":2,"charIndex":134},{"text":"依赖收集与触发","id":"依赖收集与触发","depth":2,"charIndex":502},{"text":"track","id":"track","depth":3,"charIndex":1000},{"text":"trigger","id":"trigger","depth":3,"charIndex":1112},{"text":"effect","id":"effect","depth":3,"charIndex":1226},{"text":"异步更新队列","id":"异步更新队列","depth":3,"charIndex":1297},{"text":"原来的分析","id":"原来的分析","depth":2,"charIndex":1307},{"text":"get","id":"get","depth":3,"charIndex":1663},{"text":"set","id":"set","depth":3,"charIndex":1925}],"domain":"","frontmatter":{},"version":""},{"id":24,"title":"渲染器","content":"#\n\n渲染器的作用是将虚拟DOM渲染为特定平台上的真实元素。\n\n虚拟DOM与真实DOM的结构一样，是由一个个虚拟节点VNode组成的树形结构。\n\n渲染器把虚拟DOM节点渲染为真实DOM节点的过程叫作挂载。\n\n\nVNode#\n\n\nVNode的类型#\n\n常规的VNode包括Text、Comment、Static、Fragment这几种类型。\n\n\n\nVNode的内容：\n\n\n\ncreateVNode位于@vue/runtime-core/vnode.ts，在生产环境调用了第317行的_createVNode，其代码如下：\n\n\n\n\n渲染器的基本结构#\n\n在Vue3中渲染器被抽象成了一个对象，其TypeScript类型定义位于@vue/runtime-core/renderer.ts中：\n\n\n\n主要就是一个拥有render和createApp方法的对象。\n\n在Vue3中可以通过createRenderer自定义渲染器，浏览器平台的DOM渲染器就是自定义渲染器的一个实现。\n\n\n\ncreateRenderer函数将自定义渲染器的依赖抽象成了RendererOptions，其TypeScript类型定义如下：\n\n\n\n\nmount#\n\napp的mount方法中的render由createAppAPI作为参数传入，来源于@vue/runtime-core/renderer.ts中的baseCre\nateRenderer方法定义：\n\n\n\nrender方法主要有两个逻辑分支，如果vnode不为null时，为新建或者更新逻辑，调用patch方法；如果vnode为null，，并且container._\nvnode不为null，即vnode从有值变为null，调用unmount方法。\n\n\npatch#\n\npatch函数是整个渲染器的核心入口，承载了最重要的渲染逻辑\n\npatch的类型#\n\n不同类型的元素或组件，有不同的patch策略\n\n\n\npatch方法位于同文件的452行：\n\n\n\npatch方法经过swtich语句调用了processComponent方法，其代码位于同文件的第1201行：\n\n\n\n其主要有两个逻辑分支：旧的VNode``n1不为null时，调用更新组件的updateComponent方法；当n1为null时，又有两个子分支：新的VNode\n``n1为keep-alive的组件时，调用其ctx的activate方法，否则调用挂载组件的mountComponent方法。\n\n我们先看挂载组件的mountComponent方法，其位于processComponent的下方：\n\n\n\n\ncreate#\n\n首先调用createComponentInstance方法生成组件的实例，先看下组件实例的构成：\n\n\n\ncreateComponentInstance方法的代码位于@vue/runtime-core/component.ts的第401行：\n\n\n\n\nsetup#\n\nsetup主要包括setupComponent和setupRenderEffect两个过程。\n\nsetupComponent方法代码位于@vue/runtime-core/component.ts的第516行：\n\n\n\n内部主要做了初始化属性initProps和初始化插槽initSlots这两件事儿，并且带状态isStateful的组件，会执行setupStatefulComp\nonent方法获取setupResult。最后将标识组件是否在SSR环境下执行setup的标识置为false，并返回setupResult。\n\ninitProps方法位于@vue/runtime-core/componentProps.ts的第114行：\n\n\n\nsetFullProps位于同文件：\n\n\n\nshallowReactive为Vue3暴露的响应式核心API之一，用于创建一个不会深度嵌套的响应式proxy。调用了Reactivity部分的核心代码crea\nteReactiveObject，通过new Proxy的方式来响应data的变化。\n\n\nupdate#\n\nsetupRenderEffect主要设置了实例的update方法，此处调用了reactivity中的effect方法，在定义之后会立即执行，出发DOM渲染：\n\n\n\n\nDiff算法#","routePath":"/framework/vue3/render","lang":"","toc":[{"text":"VNode","id":"vnode","depth":2,"charIndex":104},{"text":"VNode的类型","id":"vnode的类型","depth":3,"charIndex":113},{"text":"渲染器的基本结构","id":"渲染器的基本结构","depth":2,"charIndex":263},{"text":"mount","id":"mount","depth":2,"charIndex":507},{"text":"patch","id":"patch","depth":3,"charIndex":740},{"text":"patch的类型","id":"patch的类型","depth":4,"charIndex":780},{"text":"create","id":"create","depth":3,"charIndex":1099},{"text":"setup","id":"setup","depth":3,"charIndex":1232},{"text":"update","id":"update","depth":3,"charIndex":1709},{"text":"`Diff`算法","id":"diff算法","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":25,"title":"VNode","content":"#\n\nVNode中的patchFlag用于标识那些是静态属性，那些是动态属性。以对应渲染器中的不同的patch策略","routePath":"/framework/vue3/vnode","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":26,"title":"Vue","content":"#\n\n\n父组件和子组件生命周期钩子执行顺序#\n\n\n渲染过程#\n\n先创建父组件，然后创建子组件，也就是说父组件的created在子组件created之前。\n\n父组件在子组件之后挂载，故父组件的mounted在子组件mouted之后。\n\n\n\n整体渲染过程如下：\n\n父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created ->\n子beforeMount -> 子mounted -> 父mounted\n\n\n更新过程#\n\n子组件更新过程\n\n * 影响到父组件: 父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updted\n * 不影响父组件: 子beforeUpdate -> 子updated\n\n父组件更新过程\n\n * 影响到子组件: 父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updted\n * 不影响子组件: 父beforeUpdate -> 父updated\n\n\n销毁过程#\n\n与渲染类似的：\n\n父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed\n\n综上，可以看出，Vue父子组件生命周期钩子的执行顺序遵循：从外到内，然后再从内到外的规律。\n\n\nVuex#\n\n\ninstall#\n\nVuex的install通过beforeCreacte钩子中增加处理逻辑，保证了所有组件实例的$store都是同一份Store实例：\n\n\n\n\n数据响应化#\n\nVuex通过new Vue()的方式实现state和computed的响应化，具体通过resetStoreVM方法：\n\n\n\n\n严格模式#\n\nVuex严格模式下，所有修改state的操作必须通过mutation实现，否则会抛出错误。这是通过watch state实现的：\n\n\n\n\nObject.defineProperty有哪些缺点#\n\n 1. Object.defineProperty只能劫持对象的属性，而Proxy 是直接代理对象。由于Object.defineProperty\n    只能对属性进行劫持，需要遍历对象的每个属性。而Proxy 可以直接代理对象。\n 2. Object.defineProperty对新增属性需要手动进行 Observe。由于Object.defineProperty\n    劫持的是对象的属性，所以新增属性时，需要重新遍历对象，对其新增属性再使用Object.defineProperty进行劫持。\n    也正是因为这个原因，使用Vue给data 中的数组或对象新增属性时，需要使用vm.$set 才能保证新增的属性也是响应式的。\n 3. Proxy支持13种拦截操作，这是defineProperty所不具有的。\n 4. Proxy作为新标准，长远来看，JS引擎会继续优化Proxy ，但getter和setter基本不会再有针对性优化。\n 5. Proxy兼容性差目,前并没有一个完整支持Proxy所有拦截方法的Polyfill方案\n\n\nVue3新特性#\n\n * 基于Proxy实现数据变动的监听\n * 使用TypeScript开发\n * 组合式API(Composition API)\n\n\nComposition API#\n\n是较低级别的数据驱动视图和组件生命周期API，能够实现一种更自由形式的编写组件逻辑的方式。可以像编写函数一样自由地表达，编写和重用有状态组件逻辑\n\nComposition API完全可以和现有的Options API配合使用\n\n * Composition API会在Options API之前解析，并且不能提前访问这些选项中定义的 property\n * setup()函数返回的property将会被暴露给 this，在 Options API中可以访问到\n\n\nRef#\n\nRef是为了以变量形式传递响应式的值而引入的“新”概念。基本类型值需要以Ref的形式引用\n\n\n\nReactive的应用类型解构赋值时候，会失去可响应性，需要用toRefsAPI\n\n\n\n\n与React Hooks相比#\n\n基于函数的Composition API提供了与React Hooks 同等级别的逻辑组合能力。但其setup()函数只会被调用一次，因此有一下优点：\n\n * 一般来说更符合惯用的JavaScript代码的直觉\n * 不需要顾虑调用顺序，可以用在条件语句中\n * 不会在每次渲染时重复执行，可以以降低垃圾回收的压力\n * 不存在内联处理函数导致子组件永远更新的问题，不需要 useCallback\n * 不存在忘记记录依赖的问题，也不需要useEffect和useMemo并传入依赖数组以捕获过时的变量。Vue的自动依赖跟踪可以确保侦听器和计算值总是准确无误","routePath":"/framework/vue3/vue","lang":"","toc":[{"text":"父组件和子组件生命周期钩子执行顺序","id":"父组件和子组件生命周期钩子执行顺序","depth":2,"charIndex":3},{"text":"渲染过程","id":"渲染过程","depth":3,"charIndex":24},{"text":"更新过程","id":"更新过程","depth":3,"charIndex":242},{"text":"销毁过程","id":"销毁过程","depth":3,"charIndex":474},{"text":"Vuex","id":"vuex","depth":2,"charIndex":600},{"text":"install","id":"install","depth":3,"charIndex":608},{"text":"数据响应化","id":"数据响应化","depth":3,"charIndex":689},{"text":"严格模式","id":"严格模式","depth":3,"charIndex":760},{"text":"`Object.defineProperty`有哪些缺点","id":"objectdefineproperty有哪些缺点","depth":2,"charIndex":-1},{"text":"`Vue3`新特性","id":"vue3新特性","depth":2,"charIndex":-1},{"text":"`Composition API`","id":"composition-api","depth":3,"charIndex":-1},{"text":"`Ref`","id":"ref","depth":3,"charIndex":-1},{"text":"与`React Hooks`相比","id":"与react-hooks相比","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":28,"title":"ES6","content":"#\n\n\n块级作用域#\n\n\n全局块作用域绑定#\n\nvar被用于全局作用域时，会创建一个全局变量作为全局对象(浏览器window对象)的属性。\n\nlet或const, 会在全局作用域下创建一个新的绑定，但不会添加到全局对象的属性。\n\n\n扩展对象功能#\n\n\nObject.is#\n\nJavaScript中比较两个值，全等运算符(===)要比相等运算符(==)更可信。但是===也不完全准确，+0和-0在JavaScript引擎中，被表示为两个\n完全不同的实体，但是===返回的是true，而NaN === NaN返回false。\n\nObject.is用来弥补全等运算符的不准确运算：\n\n\n\n\n自有属性枚举顺序#\n\nObject.getOwnPropertyNames的枚举顺序：\n\n 1. 所有数字键按升序排序\n 2. 所有字符串建按照被加入对象的顺序排序\n 3. 所有symbol建按照被加入对象的顺序排序\n\n> for-in循环每个厂商的实现方式各不相同、Object.keys、JSON.stringify与for-in循环有相同的枚举顺序\n\n\n对象原型#\n\nES5中，对象原型实例化之后是保持不变的，无论是通过构造函数还是Object.create()。ES5有Object.getPrototypeOf()方法获取对\n象原型，但无法在对象实例化之后修改。\n\n在ES6中添加了Object.setPrototypeOf()，用以改变任意指定对象的原型。有两个形参Object.setPrototypeOf(target,\nnewProto)：\n\n * 被改变原型的对象\n * 替代原型的对象\n\n\nsuper关键字#\n\nsuper总是指向对象的原型。\n\nES6正式将方法定义成一个函数，内部的[[HomeObject]]属性指向这个从属对象。这一点，对于super而言非常重要，都是通过[[HomeObject]]\n属性来找到其对应的原型。\n\n\n函数#\n\n\n箭头函数#\n\n与传统的JavaScript函数的不同\n\n * 没有this、super、arguments和new.target绑定。这些值由外围最近一层的非箭头函数决定\n * 不能通过new关键字调用，箭头函数没有[[Construct]]方法\n * 没有prototype原型\n * 不可以改变this绑定\n * 不支持arguments对象\n * 不支持重复的命名参数\n\n\n迭代器和生成器#\n\n\n迭代器(Iterator)和生成器(Generator)#\n\n迭代器是一种特殊的对象，具有为迭代过程设计的专有接口，都一个next方法，每次调用都返回一个结果对象。结果对象有两个属性：一个是value，表示下一个将要返回的\n值；另一个是布尔类型的done，当没有更多数据返回时返回true。迭代器会保存一个内部指针，用来指向当前集合中值的位置。\n\n生成器是一种返回迭代器的函数，通过function关键字后的星号(*)来表示，函数中会用到关键字yield。\n\n不能用箭头函数创建生成器，但是可以直接将生成器作为方法添加到对象用。\n\n\n\n可以通过给迭代器的next()方法传递参数，这个参数的值会替代生成器内部上一条yield语句的返回值。\n\n需要注意的是，第一次调用next()方法，无论传什么参数都无效。\n\n\n\n生成器内部可以通过try-catch来捕获错误\n\n\n\n\n可迭代对象#\n\n可迭代对象具有Symbol.inerator属性，Symbol.inerator通过指定的函数，可以返回一个作用于附属对象的迭代器。在ES6中，所有的集合对象(\nArray/Set/Map)和字符串都是可迭代对象。for-of循环需要用到可迭代对象的这些功能。\n\n普通对象不是可迭代对象，不能用于for-of循环。\n\n迭代器默认会为Symbol.inerator属性赋值，所用通过生成器创建的迭代器都是可迭代队形。\n\nfor-of循环没执行一次都会调用可迭代对象的next()方法，并将迭代器返回的结果对象的value属性储存在一个变量中，循环将持续执行这个过程直到返回队形的d\none属性为true\n\n\n内置迭代器#\n\n集合对象迭代器#\n\nES6中有3种集合对象：数组，Map和Set。都有以下三种迭代器：\n\n * entries()，返回一个所拥有的键值对的迭代器。数组的第一个元素为数字类型索引，Set的键和值都为值。\n * values()，返回一个包含集合中的所有值的迭代器\n * keys(), 返回一个包含集合中所有键的迭代器\n\n在for-of循环中，没有显示指定，则使用集合的默认迭代器。数组和Set集合的默认迭代器是values()方法，Map集合的默认迭代器是entries()方法\n\n字符串迭代器（问题未复现）#\n\nES5中是可以通过方括号访问字符串中的字符的，但是由于方括号操作的是编码单元而不是字符，无法正确访问双字节字符。而在ES6中通过字符串的默认迭代器解决了这个问题\n。\n\nNodeList迭代器#\n\nDOM标准中的NodeList是一个类数组对象。ES6添加了默认迭代器后，DOM标准(定义在HTML标准中)也拥有了与数组行为一致的迭代器。因此在for-of循\n环中，与数组表现一致。\n\n\n展开运算符#\n\n展开运算符...可以操作所有可迭代对象，从默认迭代器中读取所有值，然后按照返回顺序依次插入到数组中。\n\n\n委托生成器#\n\n需要将多个迭代器合为一个时，可以创建一个生成器，给yield语句添加一个星号，就可以将生成数据的过程委托给其他迭代器。\n\n生成器委托可以进一步利用返回值来处理复杂任务\n\n\n异步任务执行#\n\n\nasync函数#\n\nES2017标准引入了async函数，使得异步操作变得更加方便。\n\n简而言之，async函数就是Generator函数的语法糖。将Generator函数的星号*替换成async，将yield替换成await。\n\n相对于Generator函数，async函数做了以下的改进\n\n * 内置执行器。Generator函数的执行必须靠执行器(例如co模块)，而async函数自带执行器\n * 语义更清晰。与Generator函数的星号*和yield相比，async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果\n * 适用性更广。await关键字后面，可以是Promise对象和原始类型的值，原始类型的值会自动转成立即resolved的Promise对象\n * 返回值是Promise。\n\n\n类#\n\nES6的类是基于已有自定义类型声明的语法糖。但是类和自定义类型仍存在以下区别：\n\n * 类声明与let声明类似不能被提升，正在执行声明语句之前，存在于临时死区中\n * 类声明中所有代码都自动运行在严格模式下\n * 类声明中，所有方法都是不可枚举的。而自定义类型中是可枚举的\n * 类有一个名为[[Construct]]的内部方法，通过new关键字调用不含[[Construct]]的方法，会抛错\n * 不使用new关键字调用类的构造函数会抛错\n * 在类中修改类名会抛错\n\n\n\n同函数一样，类也是一等公民。可以传入函数也可以从函数返回。\n\n类可以通过立即调用类构造函数创建单例：\n\n\n\n\n访问器属性#\n\n类支持在构造函数constructor中创建属性，也支持直接在原型上定义访问器属性\n\n\n\n\n可计算成员名称及生产器方法#\n\n与对象字面量类似，类的方法和访问器属性支持变量。也支持用生成器定义方法。\n\n\n\n\n静态成员#\n\n可以使用static关键字为类添加静态成员：\n\n\n\n> 静态成员挂在类上面，不能在静态成员中访问\n\n\n类的继承与派生#\n\nES6可以使用extends关键字实现类的继承。可以调用super()方法访问基类的构造函数。\n\n\n\n继承自其他类的类被称为派生类。如果派生类有构造函数，必须调用super()，否则会报错。如果派生类不实用构造函数，则创建新的实例时会自动调用super()并传入\n所有参数。\n\nsuper()的使用有以下几个关键点：\n\n * 只能在派生类的构造函数中使用，在非派生类或者函数中使用会报错\n * 要在构造函数访问this之前调用super()，他负责初始化this，在super()之前使用this会报错\n * 在类的构造函数中返回一个对象，可以不调用super()\n\n类的方法的遮蔽\n\n派生类中的方法会覆盖基类中的同名方法。可以使用super.method()调用基类被覆盖的方法。\n\n静态成员的继承\n\n如果基类有静态成员，派生类中冶可以使用。\n\nextend高级用法\n\nextend可以从表达式导出类。只有表达式可以被解析成一个函数并且有[[Construct]]属性和原型，就可以用extend进行派生。\n\n\n\n> extends后面的表达式不能是null或者生成器函数会导致错误\n\n内建对象的继承\n\n在ES5中无法实现对内建对象(如Array)的继承：\n\n\n\nES6的extends与ES5实现的继承不同的是：\n\n * ES5先由派生类型创建this值，然后调用基类的构造函数(apply)。this开始指向派生类的实例，随后被基类的属性修饰\n * ES6的extends先由基类创建this值，然后派生类的构造函数再修改这个值，然后在正确的接受所有与之相关的功能\n\n\n\n\nSymbol.species属性#\n\n内建对象继承，会使原本在内建对象中返回自身实例的方法将自动返回派生类的实例。这主要是通过Symbol.species属性实现的。\n\n\n\nSymbol.species属性主要用于定义返回函数的静态访问器属性。被返回的函数是一个构造函数，实例的方法中创建的类的实例时必须用这个构造函数。以下内建类型均\n已定义Symbol.species属性\n\n * Array\n * ArrayBuffer\n * Map\n * Promise\n * RegExp\n * Set\n * Typed arrays\n\n内建类型的Symbol.species属性实现的功能，可以用以下代码模拟：\n\n\n\n由于clone()方法通过调用this.constructor[Symbol.species]获取MyClass，因此派生类可以覆盖这个值。\n\n\n类的构造函数中的new.target#\n\n在类的构造函数中可以通过new.target确定类是如何被调用的。在一般简单情况下，new.target等于类的构造函数。\n\n但是在派生类中调用基类的构造函数时，new.target等于派生类的构造函数。\n\n","routePath":"/javascript/es6/","lang":"","toc":[{"text":"块级作用域","id":"块级作用域","depth":2,"charIndex":3},{"text":"全局块作用域绑定","id":"全局块作用域绑定","depth":3,"charIndex":12},{"text":"扩展对象功能","id":"扩展对象功能","depth":2,"charIndex":115},{"text":"`Object.is`","id":"objectis","depth":3,"charIndex":-1},{"text":"自有属性枚举顺序","id":"自有属性枚举顺序","depth":3,"charIndex":292},{"text":"对象原型","id":"对象原型","depth":3,"charIndex":472},{"text":"`super`关键字","id":"super关键字","depth":3,"charIndex":-1},{"text":"函数","id":"函数","depth":2,"charIndex":822},{"text":"箭头函数","id":"箭头函数","depth":3,"charIndex":828},{"text":"迭代器和生成器","id":"迭代器和生成器","depth":2,"charIndex":1018},{"text":"迭代器(`Iterator`)和生成器(`Generator`)","id":"迭代器iterator和生成器generator","depth":3,"charIndex":-1},{"text":"可迭代对象","id":"可迭代对象","depth":3,"charIndex":1414},{"text":"内置迭代器","id":"内置迭代器","depth":3,"charIndex":1725},{"text":"集合对象迭代器","id":"集合对象迭代器","depth":4,"charIndex":1733},{"text":"字符串迭代器（问题未复现）","id":"字符串迭代器问题未复现","depth":4,"charIndex":1975},{"text":"`NodeList`迭代器","id":"nodelist迭代器","depth":4,"charIndex":-1},{"text":"展开运算符","id":"展开运算符","depth":3,"charIndex":2184},{"text":"委托生成器","id":"委托生成器","depth":3,"charIndex":2245},{"text":"异步任务执行","id":"异步任务执行","depth":3,"charIndex":2339},{"text":"async函数","id":"async函数","depth":2,"charIndex":2349},{"text":"类","id":"类","depth":2,"charIndex":2711},{"text":"访问器属性","id":"访问器属性","depth":3,"charIndex":3009},{"text":"可计算成员名称及生产器方法","id":"可计算成员名称及生产器方法","depth":3,"charIndex":3063},{"text":"静态成员","id":"静态成员","depth":3,"charIndex":3120},{"text":"类的继承与派生","id":"类的继承与派生","depth":3,"charIndex":3178},{"text":"Symbol.species属性","id":"symbolspecies属性","depth":3,"charIndex":3878},{"text":"类的构造函数中的new.target","id":"类的构造函数中的newtarget","depth":3,"charIndex":4257}],"domain":"","frontmatter":{},"version":""},{"id":29,"title":"模块","content":"#\n\n模块(Module)是自动运行在严格模式下并且没有办法退出运行的JavaScript代码。\n\n * 模块的代码自动运行在严格模式下\n * 模块的顶部，this的值是undefined\n\n\n导出语法#\n\n可以用export关键字将任意变量、函数或类声明从模块中导出。除非用default关键字，否则不能用export导出匿名函数或类\n\n\n\n\n导入语法#\n\n模块的导出可以通过import关键字在另一个模块中访问。\n\n\n\nimport后面的大括号表示从给定模块导入的绑定(binding)。\n\n> 导入绑定的列表看起来和解构对象很像，但它不是\n\n关键字from表示从哪个模块导入。由表示模块路径的字符串指定。\n\n * 浏览器使用的路径格式与传给<script>元素的相同，必须加上扩展名\n * Node.js则遵循基于文件系统前缀区分本地文件和包的习惯\n\n从模块中导入的绑定，和常量const类似，不能存在同名变量，也无法在import语句前使用标识符或改变绑定的值\n\n可以使用as关键字将整个模块作为一个单一对象导入。该模块的所有导出都可以作为对象的属性使用。\n\n\n\n一个模块不管被import了几次，都只执行一次。\n\nexport和import的一个重要限制是必须在其他语句和函数之外使用\n\n\n导出和导入时重命名#\n\n当导入或者导出变量、函数或者类时，可以用as关键字改变名称。\n\n\n\n\n模块的默认值#\n\n模块的默认值是指通过default关键字指定的单个变量、函数或类。只能为每个模块设置一个默认导出值。\n\n\n\n另外还可以通过重命名来导出默认值，上例可以改成：\n\n\n\n\n重新导出一个绑定#\n\n\n\n\n加载模块#\n\nES6定义了模块语法，但是并没有定义如何加载这些模块。加载机制由一个未定义的内部抽象方法HostResolveImportedModule决定，浏览器和Node\n.js可以自己实现。\n\n在<script>中将type设置为module时，支持加载模块。为了保证模块的加载顺序，<script\ntype=\"module\">在执行时，自动应用defer属性。因此，所以的模块组件在文档被解析完才会执行。\n\n由于每个模块都可以从其他模块导入，因此在加载阶段，该模块加载完之后会识别所有导入语句，然后每个导入语句都出发一次获取过程，并且在所有导入资源都被加载之后，执行当\n前模块。\n\n以如下代码为例：\n\n\n\n完整的加载顺序如下：\n\n 1. 下载并解析module1.js\n 2. 递归下载并解析module1.js中导入的模块\n 3. 解析内联模块\n 4. 递归下载并解析内联模块中导入的模块\n 5. 下载并解析module2.js\n 6. 递归下载并解析module2.js中导入的模块\n\n加载完成之后，只有当文档完全被解析之后才会执行以下操作：\n\n 1. 递归执行module1.js中导入的模块\n 2. 执行module1.js\n 3. 递归执行内联模块中导入的模块\n 4. 执行内联模块\n 5. 递归执行module2.js中导入的模块\n 6. 执行module2.js\n\n\n异步模块加载#\n\n与通用脚本加载一样，模块也支持async属性，设置之后，会以异步方式加载。异步加载的模块不必等待文档解析完成，但是需要模块中所有导入文件都加载完成，才会执行模块\n。但是无法保证模块的先后执行顺序，而是哪个模块及其依赖模块先加载完就先执行哪个模块。\n\n\n将模块作为Worker加载#\n\n通过配置Worker的第二个参数，可以支持以模块方式加载。\n\n\n\n以脚本方式加载的Worker与以模块方式加载的Worker存在以下两点不同：\n\n 1. Worker脚本只能引用与网页同源的JavaScript，而Worker模块不会完全受限，可以加载并访问具有适当的跨域资源共享(CORS)头的文件。\n 2. Worker脚本可以使用self.importScripts()加载其他脚本，但Worker模块不能，而是应该使用import来导入。\n\n\n浏览器模块说明符解析#\n\n在浏览器中，模块说明符(module specifier)只支持以下四种格式：\n\n * 以/开头，从根目录开始解析\n * 以./开头，从当前目录开始解析\n * 以../开头，从父级目录开始解析\n * URL格式，不同源时，需要正确配置跨域(CORS)\n\n以下的格式，是无效的，并且会导致错误\n\n\n\n\nES Modules进阶#\n\n * 精读《snowpack和vite》-ESM\n * 图说 ES Modules","routePath":"/javascript/es6/module","lang":"","toc":[{"text":"导出语法","id":"导出语法","depth":2,"charIndex":96},{"text":"导入语法","id":"导入语法","depth":2,"charIndex":172},{"text":"导出和导入时重命名","id":"导出和导入时重命名","depth":2,"charIndex":549},{"text":"模块的默认值","id":"模块的默认值","depth":2,"charIndex":596},{"text":"重新导出一个绑定","id":"重新导出一个绑定","depth":2,"charIndex":688},{"text":"加载模块","id":"加载模块","depth":2,"charIndex":702},{"text":"异步模块加载","id":"异步模块加载","depth":2,"charIndex":1297},{"text":"将模块作为`Worker`加载","id":"将模块作为worker加载","depth":2,"charIndex":-1},{"text":"浏览器模块说明符解析","id":"浏览器模块说明符解析","depth":2,"charIndex":1674},{"text":"ES Modules进阶","id":"es-modules进阶","depth":2,"charIndex":1837}],"domain":"","frontmatter":{},"version":""},{"id":30,"title":"代理和反射","content":"#\n\n代理(Proxy)是一种可以拦截并改变底层JavaScript引擎操作的包装器。\n\n> 在ES6中数组被认为是奇异对象(exotic object)\n\n调用new Proxy可创建目标(target)对象的代理，他虚拟化了目标，二者看起来功能一致。\n\n代理可以拦截JavaScript引擎内部目标的底层对象操作，会触发对应的陷阱函数\n\n反射API以Reflect对象的形式出现，对象中方法的默认特性与相同的底层操作一直，代理可以覆写这些操作，每个代理陷阱都对应一个命名和参数相同的Reflect方\n法\n\n代理陷阱                       覆写的特性                                                          默认特性\nget                        读取一个属性值                                                        Reflect.get()\nset                        写入一个属性值                                                        Reflect.set()\nhas                        in操作符                                                          Reflect.has()\ndeleteProperty             delete操作符                                                      Reflect.deleteProperty()\ngetPrototypeOf             Object.getPrototypeOf()                                        Reflect.getPrototypeOf()\nsetPrototypeOf             Object.setPrototypeOf()                                        Reflect.setPrototypeOf()\nisExtensible               Object.isExtensible()                                          Reflect.isExtensible()\npreventExtensions          Object.preventExtensions()                                     Reflect.preventExtensions()\ngetOwnPropertyDescriptor   Object.getOwnPropertyDescriptor()                              Reflect.getOwnPropertyDescriptor()\ndefineProperty             Object.defineProperty()                                        Reflect.defineProperty()\nownKeys                    Object.keys()、Object.getOwnPropertyNames()和、Object.getOwnPro   Reflect.ownKeys()\n                           pertySymbols()\napply                      调用一个函数                                                         Reflect.apply()\nconstruct                  用new调用一个函数                                                     Reflect.construct()\n\n\n代理的使用#\n\n\n\n\n浏览器支持程度#\n\n49以上版本Chrome支持Proxy。IE浏览器不支持。","routePath":"/javascript/es6/proxy","lang":"","toc":[{"text":"代理的使用","id":"代理的使用","depth":2,"charIndex":1845},{"text":"浏览器支持程度","id":"浏览器支持程度","depth":2,"charIndex":1856}],"domain":"","frontmatter":{},"version":""},{"id":31,"title":"`Set`和`Map`","content":"Set和Map#\n\n长久以来，数组Array一直是JavaScript中唯一的集合类型，但是由于是数值型索引而在使用上受限。对于非数值类型索引的集合，就是Set和Map。\n\n\n基于对象实现的Set和Map#\n\n在ES6发布之前，开发者以及基于非数组对象实现了类似的功能：\n\n\n\n上述解决方案存在以下一些问题：\n\n * 对象的属性必须是字符串类型，所以map[\"5\"]和map[5]引用的是同一个属性\n * 对象类型会被转换成\"[object Object]\"，会出现错误\n * map中值为False类的值，直接if判断会存在bug，使用in操作符会检索对象的原型，需要保证对象的原型为null\n\n\nES6中的Set和WeakSet#\n\nSet是一种有序列表，其中含有一些相互独立的非重复值。通过Set集合可以快速访问其中的数据，更加有效的追踪各种离散值\n\n将对象存储在Set中，与存储在变量中完全一样，只要改实例存在，垃圾回收机制就不能释放该对象的内存空间，可以被看做是一个强引用的Set集合。WeakSet则是弱引\n用集合，只存储对象的弱引用，并且不可以存储原始值，集合中的弱引用如果是对象的唯一引用，该对象可以正常被垃圾回收。\n\n两者的区别\n\n * 在WeakSet中，通过add()方法添加非对象参数会报错，has()和delete()方法会返回false\n * WeakSet不可迭代，不能用于for-of循环\n * WeakSet不暴露任何迭代器方法(keys()和values())，无法通过程序本身来检测其中的内容\n * WeakSet不支持forEach()方法\n * WeakSet不支持size属性","routePath":"/javascript/es6/set-map","lang":"","toc":[{"text":"基于对象实现的`Set`和`Map`","id":"基于对象实现的set和map","depth":2,"charIndex":-1},{"text":"`ES6`中的`Set`和`WeakSet`","id":"es6中的set和weakset","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":32,"title":"JavaScript","content":"#","routePath":"/javascript/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":33,"title":"JS拾遗","content":"#\n\n\nObject.create详解#\n\n\nObject.create是什么#\n\nObject.create的作用是使用指定的原型和属性来创建一个对象。有两个形参：\n\n * 指定的原型proto\n * 一个可选参数descriptors，属性描述符\n\n\n\n\nObject.create(null)与{}的区别#\n\nObject.create(null)不继承任何原型方法，Object.create用于创建一个新对象，其中第一个参数为这个对象的原型，而由于null没有原型，\n所以该方法不继承Object.prototype。\n\n因此，{}等同于Object.create(Object.prototype)。\n\n可以用以下代码模拟Object.create:\n\n\n\n\nObject.setPrototypeOf#\n\nES6新增了Object.setPrototypeOf，用于设置一个指定的对象的原型 ( 即内部[[Prototype]]属性）到另一个对象或 null。\n\nObject.setPrototypeOf(obj, prototype)\n\n\n\n\nnew操作符模拟实现#\n\n\nnew操作符都做了什么：#\n\n * 创建了一个全新的对象\n * 这个对象会被执行[[Prototype]]（也就是__proto__）链接\n * 生成的新对象会绑定到函数调用的this\n * 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上\n * 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg,\n   Error)，那么new表达式中的函数调用会自动返回这个新的对象\n\n\n\n\nnew操作符和Object.create的区别#\n\nnew操作符将父类的属性和方法全都赋给子类\n\nObject.create只修改原型\n\n\nJS继承#\n\n\n原型链继承#\n\n特点：\n\n * 父类新增原型方法/原型属性，子类都能访问到\n * 简单，易于实现\n\n缺点：\n\n * 无法实现多继承\n * 来自原型对象的所有属性被所有实例共享\n * 创建子类实例时，无法向父类构造函数传参\n * 要想为子类新增属性和方法，必须要在inherits之后执行，不能放到构造器中\n\n\n\n问题\n\n父类的私有属性中有引用类型的属性，那它被子类继承的时候会作为公有属性，这样子类1操作这个属性的时候，就会影响到子类2。\n\n\n借用构造函数继承#\n\n在子类型构造函数中通用call()调用父类型构造函数\n\n\n\n特点：\n\n * 解决了原型链继承中子类实例共享父类引用属性的问题\n * 创建子类实例时，可以向父类传递参数\n * 可以实现多继承(call多个父类对象)\n\n缺点：\n\n * 实例并不是父类的实例，只是子类的实例\n * 只能继承父类的实例属性和方法，不能继承原型属性和方法\n * 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n\n原型链+借用构造函数的组合继承#\n\n通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。\n\n\n\n优点：\n\n * 可以继承实例属性/方法，也可以继承原型属性/方法\n * 不存在引用属性共享问题\n * 可传参\n * 函数可复用 缺点： 调用了两次父类构造函数，生成了两份实例\n\n\n组合继承优化#\n\n\n\n优点：\n\n不会初始化两次实例方法/属性，避免的组合继承的缺点\n\n缺点：\n\n没办法辨别是实例是子类还是父类创造的，子类和父类的构造函数指向是同一个。\n\n\n组合继承优化2#\n\n\n\n\nES6 extends#\n\n组合式继承\n\n\n\n\nnull和undfined#\n\nnull是JavaScript的关键字，用来描述空值。因为typeof null ==\n\"object\"，可将null不严谨的认为成一种特殊的对象，即非对象。这是是一个历史悠久的\nbug，就是在JS的最初版本中null的内存存储信息是000开头的，而000开头的会被判断为Object类型。\n\n实际上，null是JavaScript的基本类型之一，表示数字、字符串、对象等是无值的。\n\nundefined用以表示更深层次的空值，即未定义。是变量的一种取值，表明变量未被初始化。若查询对象的属性，数组元素等返回u\nndefined，也说明属性或元素不存在。undefined是预定义的全局变量，但不是JavaScript关键字。在ECMAScript\n3中是可读写的，可以被赋予任何值，在ECMAScript 5中是只读的。\n\nnull == undefined为真，要严格判断需要用===。另外，null和undefined都不包含任何属性和方法，也没有包装对象。\n\n\n不可变的原始值和可变的对象引用#\n\nJavaScript中的原始值（u\nndefined、null、布尔值、数字和字符串）是不可更改的：任何方法都无法更改（或“突变”）一个原始值。字符串中所有的方法都会返回一个新的字符串值。\n\n原始值的比较是值的比较：只有在它们的值相等时它们才相等。比较两个字符串，当且仅当它们的长度相等且每个索引的字符都相等时，JavaScript才认为它们相等。\n\n对象的比较并非值的比较：即使两个对象包含同样的属性及相同的值，它们也是不相等的。同样，各个索引元素完全相等的两个数组也不相等。对象值都是引用（reference\n），对象的比较是引用的比较：当且仅当引用同一个基对象时才相等。因此，对象又被称为引用类型（referencetype），以此与基本类型做区分。\n\n\nJavaScript类型转换#\n\n转为布尔值\n\nnull、undfined、\"\"、0、-0、NaN这6个转为false，其他的都会转为true。false又和这6个值被称为“假值”（falsy\nvalue），其他值称做“真值”（truthy value）。\n\n包装对象也会被转换成true，所以new Boolean(false) == true\n\n转为数字\n\n * 以数字表示的字符串可以直接转换为数字，也允许在开始和结尾处带有空格，但有任意非空格字符的字符串都会转为NaN。\n * 空字符串\"\"会被转换为0\n * null转为0，undefined转为NaN\n * true转换为1，false也会被转换为0\n * 空数组会被转换为0，只有一个数字元素的数组例如[2]或者其他唯一一个可以被会被转成数字的字符串，会被转换成对应的数字。而唯一的布尔值元素数组不会被转换为数\n   字。\n\n通过Number()将字符串转为数字时，只能基于十进制数进行转换，并且不能出现非法的尾随字符。parseInt()和parseFloat()都会跳过任意数量的前\n导空格，尽可能解析更多数值字符，并忽略后面的内容，如果第一个非空格字符是非法的数字直接量，将返回NaN。另外，parseInt()可以接收第二个可选参数，这个参\n数指定数字转换的基数，合法的取值范围是2～36。\n\n转为对象\n\n如果试图把null或u\nndefined转换为对象会抛出一个类型错误（TypeError）。Object()函数在这种情况下不会抛出异常：仅简单地返回一个新创建的空对象。\n\n转为字符串\n\nNumber类的toString()方法可以接收表示转换基数（radix）的可选参数，如果不指定，默认转换成十进制。进制基数范围应该在2～36之间。\n\n数字转字符串需要控制小数点的有效数字位数时，可用以下三个方法。toFixed()任何时候都不会使用指数记数法；toExponential()则将数字转换为指数形\n式的字符串，其中小数点前只有一位，小数点后的位数则由参数指定；toPrecision()根据指定的有效数字位数将数字转换成字符串。这三个方法都会适当地进行四舍五\n入或者填充0。\n\n对象转换为原始值\n\n对象到字符串（object-to-string）和对象到数字（object-to-number）的转换是通过调用待转换对象的toString方法或valueOf\n方法来完成的。\n\ntoString\n\n * 对象默认的toString方法返回一个反映这个对象的字符串 \"[object Object]\"。\n * 数组的toString方法将每个数组元素转换为一个字符串，其接受一个参数定义分隔符，默认值是逗号,。具体实现就是由数组中的每个元素的toString返回值\n   经调用join 方法连接（由逗号隔开）组成。\n * 函数toString方法返回函数的JavaScript源代码字符串。\n * 日期的toString方法返回一个可读的（可被JavaScript解析的）日期和时间字符串。\n * RegExp类的toString方法返回表示正则表达式直接量的字符串。\n\nvalueOf\n\nvalueOf方法主要作用是，如果存在任意原始值，就将其转换为表示它的原始值。对象默认的valueOf方法简单地返回对象本身。数组、函数和正则表达式等与之相同。\n只有日期类不同，valueOf方法会返回一个内部表示：1970年1月1日以来的毫秒数。\n\n鉴于日期类的特殊性，运算符+、==、!=和比较运算符，需要同类型，所以在需要转化成数字的情况下，会调用日期类的toString方法，需要数字的情况下调用valu\neOf方法。其他运算符的类型转换都是决定的\n\n\n\n\n作为属性的变量#\n\n当声明一个JavaScript全局变量时，实际上是定义了全局对象的一个属性\n\n命名函数的函数名在该函数内部是一个常量，不能被再次赋值，再次赋值时，严格模式下会报错，非严格模式下会静默失败。\n\n\n严格判断数组#\n\nArray.isArray()是ES5的方法，可以用Object.prototype.toString.call(arr) === '[object\nArray]'来进行polyfill。\n\n\ninstanceof#\n\ninstanceof通过判断对象的原型链中是不是能找到类型的 prototype。instanceof的右侧必须为一个对象，否则会报错\n\n\n\n怪异的是：\n\n\n\n并且instanceof无法跨iframes判断数组：\n\n\n\n\n存取器属性#\n\n对象的属性有数据属性和存取器属性两种：\n\n数据属性，包含的一个数据值的位置，可以对数据值进行读写。包含四个特性：\n\n * configurable:\n   表示属性是否可配置，即能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或能否把属性修改为访问器属性，默认为true\n\n * enumerable: 可枚举性，表示能否通过for-in循环返回属性\n\n * writable：可写性，表示能否修改属性的值\n\n * value: 包含该属性的数据值。默认为undefined\n\n存取器属性，accessor\nproperty，又称访问器属性，不同于数据属性，包含的是一对get和set方法。在读取属性时调用get函数，在写入属性时调用set函数，因此get和set方法\n分别代替了数据属性的value和writable特性\n\n\n函数的length属性与arguments.length#\n\n函数的length属性指函数定义时所声明的形参的个数，而arguments.length表示的是函数调用时，实参的个数。\n\n实际调用函数时，传入的参数的个数可以比形参的个数少，也可以比它多。","routePath":"/javascript/omission","lang":"","toc":[{"text":"`Object.create`详解","id":"objectcreate详解","depth":2,"charIndex":-1},{"text":"`Object.create`是什么","id":"objectcreate是什么","depth":3,"charIndex":-1},{"text":"`Object.create(null)`与`{}`的区别","id":"objectcreatenull与的区别","depth":3,"charIndex":-1},{"text":"`Object.setPrototypeOf`","id":"objectsetprototypeof","depth":3,"charIndex":-1},{"text":"`new`操作符模拟实现","id":"new操作符模拟实现","depth":2,"charIndex":-1},{"text":"`new`操作符都做了什么：","id":"new操作符都做了什么","depth":3,"charIndex":-1},{"text":"`new`操作符和`Object.create`的区别","id":"new操作符和objectcreate的区别","depth":3,"charIndex":-1},{"text":"`JS`继承","id":"js继承","depth":2,"charIndex":-1},{"text":"原型链继承","id":"原型链继承","depth":3,"charIndex":813},{"text":"借用构造函数继承","id":"借用构造函数继承","depth":3,"charIndex":1035},{"text":"原型链+借用构造函数的组合继承","id":"原型链借用构造函数的组合继承","depth":3,"charIndex":1246},{"text":"组合继承优化","id":"组合继承优化","depth":3,"charIndex":1406},{"text":"组合继承优化2","id":"组合继承优化2","depth":3,"charIndex":1493},{"text":"`ES6 extends`","id":"es6-extends","depth":3,"charIndex":-1},{"text":"`null`和`undfined`","id":"null和undfined","depth":2,"charIndex":-1},{"text":"不可变的原始值和可变的对象引用","id":"不可变的原始值和可变的对象引用","depth":2,"charIndex":1981},{"text":"`JavaScript`类型转换","id":"javascript类型转换","depth":2,"charIndex":-1},{"text":"作为属性的变量","id":"作为属性的变量","depth":2,"charIndex":3899},{"text":"严格判断数组","id":"严格判断数组","depth":2,"charIndex":4006},{"text":"`instanceof`","id":"instanceof","depth":2,"charIndex":-1},{"text":"存取器属性","id":"存取器属性","depth":2,"charIndex":4237},{"text":"函数的length属性与arguments.length","id":"函数的length属性与argumentslength","depth":2,"charIndex":4618}],"domain":"","frontmatter":{},"version":""},{"id":34,"title":"TypeScript","content":"#\n\n\nTypeScript的设计目标#\n\n * TypeScript是一种在编译期进行静态类型分析的强类型语言。拥有一个语言服务层为开发者提供更好的工具。\n * 与JavaScript兼容。TypeScript是JavaScript的超集，任何合法的JavaScript程序都是合法的TypeScript程序。\n * 给大型项目提供一个构建机制，加入了基于类Class的对象、接口和模块。\n * 对于发行版本代码，没有运行时开销。TypeScript程序通常将设计阶段和运行阶段分开。TypeScript的新特性仅对设计时代码design time\n   code有效，而对于执行时代码excution time\n   code则通过代码转换（转换为JavaScript代码）和类型擦除将之转换为纯净的JavaScript代码。\n * 遵循当前以及未来的ECMAScript规范。\n * 开源。\n\n\nTypeScript的声明空间#\n\n在TypeScript里存在两种声明空间：类型声明空间与变量声明空间。\n\n\nTypeScript的类型系统#\n\nTypeScript为JavaScript增加了可选的静态类型说明，用以约束函数、变量、属性等程序实体。以便编译器和相应的开发工具可以在开发过程中提供更好的正确\n性校验和帮助提示。\n\n可选的静态类型声明optional static type notation在变量的后面并且以冒号分隔：\n\n\n\n\nJS基本类型#\n\nJavaScript的基本类型在TypeScript中都有对应的类型：\n\n * number\n * string\n * boolean\n * symbol，是ES6新增的数据类型，在编译目标是ES5及以下时会报错。由于只能通过Symbol函数生成，可以通过类型推断确定类型，无需特别声明变量为sy\n   mbol类型。\n * u\n   ndefined和null，是所有其他类型的子类型，可以赋值给任何其他类型的变量。在tsconfig中开启了strictNullChecks，那么unde\n   fined和null就只能赋值给void或any类型变量以及它们自身类型的变量。\n\n\nAny类型#\n\nany类型，表示任何JavaScript值。any类型即是类型系统的顶级类型（全局超级类型），又是bottom\ntype（任何类型的subtype），是类型系统的一个逃逸舱。\n\n可以将在编程阶段还不清楚类型的变量指定为any类型。另外，any类型是与现有代码一起工作时的一种高效的方式。any类型也可以用于只知道一部分类型的情况，例如一个\n混合了各种类型的数据（Array<any>）。\n\n\nUnknown类型#\n\nTypeScript3.0引入的另一种顶级类型。与any相比，unknown是类型安全的。任何值都可以赋给unknown类型，但是unknown类型在被类型断言\n或者基于控制流的类型细化之前，不能赋值给除了any类型和unknown类型本身以外的类型。\n\n\nVoid类型#\n\nvoid类型与any类型相反，表示没有任何类型。当一个函数没有返回值时，其返回值类型是void。\n\nvoid类型只能被赋值为undefined和null。\n\n\nNever类型#\n\nnever用于表示永远不会存在的值的类型。never是任何类型的子类型，但没有类型是never的子类型。\n\nnever类型常用于以下情况：\n\n 1. 用于描述从不会有返回值的函数或箭头函数\n 2. 用于描述总是抛出错误的函数\n 3. 当变量被永不为真的类型保护所约束时\n\n\nObject类型#\n\nobject表示非原始类型，即除number，string，boolean，symbol，null或u\nndefined之外的类型。与any类似，可以在编译时可选择地包含或移除类型检查。但是object类型只允许被赋值为任意类型，但是不能够调用任意方法，即使它真的\n有这些方法。\n\n\n\n\nTypeScript的编译原理#\n\nTypeScript编译器由以下几个部分组成：\n\n * Scanner扫描器\n * Parser解析器\n * Binder绑定器\n * Checker检查器\n * Emitter发射器","routePath":"/javascript/ts","lang":"","toc":[{"text":"TypeScript的设计目标","id":"typescript的设计目标","depth":2,"charIndex":3},{"text":"TypeScript的声明空间","id":"typescript的声明空间","depth":2,"charIndex":400},{"text":"TypeScript的类型系统","id":"typescript的类型系统","depth":2,"charIndex":456},{"text":"JS基本类型","id":"js基本类型","depth":3,"charIndex":623},{"text":"Any类型","id":"any类型","depth":3,"charIndex":924},{"text":"Unknown类型","id":"unknown类型","depth":3,"charIndex":1128},{"text":"Void类型","id":"void类型","depth":3,"charIndex":1269},{"text":"Never类型","id":"never类型","depth":3,"charIndex":1358},{"text":"Object类型","id":"object类型","depth":3,"charIndex":1505},{"text":"TypeScript的编译原理","id":"typescript的编译原理","depth":2,"charIndex":1660}],"domain":"","frontmatter":{},"version":""},{"id":35,"title":"低代码","content":"#\n\n\n低代码的概念与分类#\n\n由于企业的经营日益复杂，企业内部各业务实体之间以及企业与企业之间的业务关联不断增强，业务数据交互日益频繁，企业面临着越来越多的难题。此外，市场的变化频率越来越快\n，这意味着企业需要迅速且灵活地响应这些变化，以满足环境的可变要求。因此，承载企业运维能力的IT系统和业务系统需要能够承受环境负荷的压力，具备满足快速变化的需求的\n能力。该能力被一些学者（例如西班牙的桑奇和波勒）定义为企业复原力，旨在为企业提供预防和预测的能力，改变企业的性质和适应不断变化的环境的能力以及应对动态需求的能力\n。\n\n速度是当前企业数字化及IT系统转型中一个非常重要的影响因素。\n\n为了提高企业的适应能力，以便迅速有效地满足市场需求，为企业内外部快速开发满足业务和市场需求的软件解决方案，在历经最底层的汇编、高级语言、更高效率的编程框架（如S\npring框架、大前端框架等）后，计算机科学领域的大量研究工作集中在一个共同的目标上：实现软件的高效构建，无须重复传统的手动编程，同时兼顾业务人员和专业开发人员\n的更多参与。低代码平台被视为一种新机制，可促进软件的快速开发及其自动化，以满足当前企业需求并促进弹性数字化转型。\n\n低代码的概念最早由Forrester在2014年提出。低代码就是指开发者写很少的代码，通过低代码平台提供的界面、逻辑、对象、流程等可视化编排工具来完成大量开发工\n作，降低软件开发中的不确定性和复杂性，从而大幅提升开发效率，让企业能够降低开发成本，降低技术门槛，快速创新应用，实现快速试错，敏捷迭代。\n\nGartner认为，低代码主要有以下几个主流分支：\n\n * 无代码开发平台，属于低代码平台的一种，不提供或者仅支持非常有限的编程扩展能力，一般仅用来开发内部管理类或市场营销类表单\n * 低代码应用平台LCAP，狭义的低代码平台，用来开发包含前端和后端的应用。关注通过声明式的模型驱动和基于元数据的服务来提供快速的应用开发、部署和执行\n * 多重体验开发平台MXDP，提供快速开发跨平台App的工具，突出前端开发能力，一般用来开发多平台/多终端应用。支持自定义移动应用、响应式Web和渐进式Web\n   应用（PWA）、沉浸式用户体验及对话式应用\n * 智能业务流程管理套件iBPMS，整合了AI等技术的业务流程管理系统BPMS，突出后端流程定义和数据整合能力，一般用于解决大型企业的跨系统业务流程","routePath":"/low-code/","lang":"","toc":[{"text":"低代码的概念与分类","id":"低代码的概念与分类","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":36,"title":"HTTP缓存","content":"#\n\nWeb缓存通过复用以前获取的资源，减少等待时间和网络流量，减少了显示资源表示形式所需的时间，可以显著提高网站和应用程序的性能。通过使用HTTP缓存，可以使网站的\n响应更加敏捷。\n\n但是，缓存也需要合理配置，因为并不是所有资源都是永久不变的。重要的是，对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。\n\n缓存可分为私有与共享缓存两类：\n\n * 共享缓存存储的响应能够被多个用户使用，例如网关缓存、CDN、反向代理缓存和负载均衡器等。\n * 私有缓存只能用于单个用户，例如浏览器缓存(Brower Caching)。\n\nHTTP缓存只应该缓存GET请求，因为其是幂等的。\n\n\n缓存规则#\n\n按照缓存规则，缓存可以分为强制缓存和协商缓存两类：\n\n强制缓存是指当缓存数据库中已有所请求的数据时，直接从缓存数据库中获取数据。只有缓存数据库中没有所请求的数据时，才会从服务端获取数据。\n\n协商缓存又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，然后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回304，此时客户端直接从缓存\n中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。\n\n两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。\n\n\n缓存控制#\n\n缓存相关的规则信息包含在header中，具体如下：\n\n\n强制缓存#\n\n对于强制缓存，服务器响应的header中可以用以下两种方式表明过期时间：\n\nExpires：服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。Expires属于HTTP\n1.0协议，但由于服务端时间和客户端时间可能有误差，会导致缓存命中的误差，现在大多数使用Cache-Control替代。\n\nCache-Control：Cache-Control有很多属性，不同的属性代表的意义也不同。max-age=t可用来指定时间，表示t秒之后缓存内容将失效。\n\n当在Cache-Control中设置了max-age时，Expires将会被忽略。\n\n\n协商缓存#\n\n协商缓存需要进行对比判断是否可以使用缓存。\n\nLast-Modified\n\n浏览器第一次请求数据时，服务器会将最后修改时间以Last-Modified: <date>响应首部的形与数据一起发送给客户端。\n\n当需要对缓存进行在验证时，浏览器会将该最后修改时间放到If-Modified-Since请求首部中，发送给服务器。服务器会将此时间与服务器上请求资源的最后修改时\n间进行对比，如果一致则返回一个304 Not Modified响应。304的响应头也可以同时更新缓存文档的过期时间。否则返回带有新数据的状态为200的响应。\n\n另外还有一个If-Unmodified-Since请求首部，意思为，当数据没有被修改时，返回数据。否则返回一个412 Precondition\nfailed的响应。\n\n对于Last-Modified而言，如果一个资源被修改的，但是实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端。因此\n，Last-Modified又被称为弱校验。\n\nETag\n\n为了解决Last-Modified问题，HTTP 1.1推出了被称为实体标签ETag强校验。\n\nETag是附加到文档上的任意标签（引用字符串），可能包含了文档的序列号或者版本名，或者是文档内容的校验及其他指纹信息。\n\n与Last-Modified类似，服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）。\n\n再次请求服务器时，浏览器会将ETag的值放到If-None-Match请求首部中。服务器会将此值与被请求资源的唯一标识进行对比。相同返回304 Not\nModified，不同返回带有新的资源内容的200的响应。\n\nETag的缺点就是其值是使用算法得出的，会占用服务端计算的资源。\n\n\nCache-Control#\n\nHTTP/1.1定义了Cache-Control请求首部来区分不同的缓存策略，请求首部和响应首部都支持。\n\n * Cache-Control: no-store，禁止缓存。缓存中不会存储任何关于客户端请求和服务端响应的内容\n * Cache-Control:\n   no-cache，缓存但重新验证。每次有请求发出时，缓存会将此请求发到服务器，以验证请求中所描述的缓存是否过期，若未过期才使用本地缓存副本。\n * Cache-Control: public公共缓存或Cache-Control:\n   private私有缓存。公共缓存可以被任何中间人（比如中间代理、CDN等）缓存。私有缓存表示该响应是专用于某单个用户的，中间人不能缓存此响应，只能应用于浏\n   览器私有缓存中。\n * Cache-Control: max-age=<seconds>。表示资源能够被缓存（保持新鲜）的最大时间\n * Cache-Control:\n   must-revalidate。在事先没有跟原始服务器再验证的情况下，不能提供这个对象的陈旧副本，但缓存可以提供新鲜副本。如果在进行must-revali\n   date新鲜度检查时，原始服务器不可用时要返回504 Gateway Timeout错误\n\n\n不同刷新的请求执行过程#\n\n * 浏览器地址栏中写入URL，回车浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）\n * F5，就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-Since。\n * Ctrl+F5告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作.\n\n> 参考资料：\n> \n> https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ\n> \n> https://juejin.cn/post/6844903517702848526#heading-1","routePath":"/network/caching","lang":"","toc":[{"text":"缓存规则","id":"缓存规则","depth":2,"charIndex":297},{"text":"缓存控制","id":"缓存控制","depth":2,"charIndex":581},{"text":"强制缓存","id":"强制缓存","depth":3,"charIndex":616},{"text":"协商缓存","id":"协商缓存","depth":3,"charIndex":912},{"text":"Cache-Control","id":"cache-control","depth":3,"charIndex":1695},{"text":"不同刷新的请求执行过程","id":"不同刷新的请求执行过程","depth":3,"charIndex":2258}],"domain":"","frontmatter":{},"version":""},{"id":37,"title":"HTTP基础","content":"#\n\n\nURI与URL#\n\nWeb服务器资源名被称为统一资源标识符（Uniform Resource Identifier,\nURI）。URI就像因特网上的邮件地址一样，在世界范围内唯一标识并定位信息资源。\n\nURI有两种形式，URL和URN。\n\n统一资源定位符（URL）是URI的最常见方式，描述了一台特定服务器上某资源的特定位置，可以明确说明如何从一个精确、固定的位置获取资源。\n\n大部分URL都遵守的标准格式包含以下三个部分：\n\n * 方案（scheme），表示资源使用的协议类型。如HTTP协议http://\n * 因特网网址，例如：www.baidu.com\n * 资源路径，例如：/network/http.html\n\n统一资源名（URN）是作为特定内容的唯一名称使用，与资源所在地无关。使用这个与位置无关的URN，就可以将资源四处搬移，也可以用同一个名字通过多种网路访问协议来访\n问资源。\n\n例如因特网标准文档RFC 2141可以命名为：urn:ietf:rfc:2141\n\nURN仍然处于试验阶段。永久统一资源定位符（persistent uniform resource locators,\nPURL）使用URL来实现URN功能的一个例子。其基本思想是在搜索资源过程中引入另一个中间层，通过一个中间资源定位符服务器对资源的实际URL进行登记和跟踪。\n\n\nURL语法#\n\nURL提供了一种定位Internet上任意资源的手段，但是不同的方案(例如HTTP、FTP和SMTP等)的语法不尽相同。\n\n大部分URL方案的URL语法建立在以下九个部分的通用格式上：\n\n\n\n组件           描述                                                             默认值\n方案scheme     访问服务器时使用的协议，有第一个:将其与URL其余部分分隔开，大小写无关                           -\n用户user       访问时需要的用户名，@将用户和密码组件和URL其余部分分隔开                                 匿名\n密码password   用户名后面需要包含密码，中间由冒号(:)分隔                                         <E-mail>地址\n主机host       资源宿主服务器的主机名或IP地址                                               -\n端口port       资源宿主服务器正在监听的端口号，很多方案都有默认端口号（HTTP的默认端口号为80）                     每个方案特有\n路径path       服务器上资源的本地名，用/将其与前面的URL组件分隔开，路径组件语法与服务器和方案有关。可以用/将HTTP          -\n             URL的路径组件划分成一些路径段（path segment），每个路径段都有自己的参数params组件\n参数params     某些方案（例如FTP）可以用这个组件来输入参数，参数为名/值对，可以包含多个参数字段，字段之间以及与路径其余部分之间用分   -\n             号(;)分隔\n查询query      某些方案（例如HTTP）用以传递参数以激活应用程序（比如数据库、公告板、搜索引擎等）。查询组件，没有通用格式，通常大部分   -\n             网关希望查询字符串以名值对的形式出现名值对之间用&分隔；用?将其与URL其余部分分隔开\n片段frag       一小片或者一部分资源的名字。引用对象时，不会将frag传给服务器，只在客户端内部使用，通过#将其与URL其余部分分隔开    -\n\n\n相对URL#\n\nURL有两种方式，绝对的和相对的。绝对URL包含访问资源所需要的全部信息。\n\n相对URL是URL的一种便捷缩略记法。相对URL是不完整的，要获取访问资源所需要的全部信息必须相对于基础（base）URL进行解析。\n\n\nURL字符集#\n\n基于历史原因，URL采用US-ASCII字符集。为了保证URL的完整性，设计了转义序列。通过转义序列，可以用US-ASCII字符集的有限子集对任意紫府进行编码。\n\nURL转义序列的编码机制包含一个百分号（%），后面跟着两个表示字符ASCII码的十六进制数。例如空格的ASCII码为32(0x20)，编码之后就是%20。\n\n在URL中，还有以下几种字符也会被转义：\n\n * 由于有特殊含义被作为保留字符\n * 不在US-ASCII可打印字符集中\n * 有些字符会与某些因特网网关和协议产生混淆\n\n字符                保留/受限原因\n%                 编码字符转义标志\n/                 路径组件中分隔路径段的定界符\n.                 路径组件中使用\n#                 分段定界符\n?                 查询字符串定界符\n;                 参数定界符\n:                 方案、用户/口令以及主机/端口组件定界符\n$,+               保留\n@&=               某些方案上下文有特殊含义\n`{}               ^~[]'`\n<>\"               不安全，在URL范围之外用意义\n0x00-0x1F, 0x7F   US-ASCII不可打印字符，受限\n>0x7F             不在US-ASCII7比特范围内，受限\n\n\nURL方案#\n\n方案            描述\nhttp          超文本传入协议方案，除了没有用户名和密码外，与通用URL格式相符，默认端口80。\n              基本格式：http://<host>:<port>/<path>?<query>#<frag>\nhttps         与http一致。默认端口443\nmailto        mailto URL指向的是Email地址，与其他方案有所不同，与标准URL也有所不同，其语法记录在RFC 822中\n              基本格式：mailto:<RFC-822-addr-spec>\nftp           文件传输协议，用来从FTP服务器上下载或者上传文件，并获取FTP服务器的目录结构内容列表。基本格式：ftp://<use\n              r>:<password>@<host>:<port>/<path>;<params>\nrtsp, rtspu   RTSP\n              URL是可以通过实时流传输协议解析的音/视频媒体资源标识符。rtspu表示使用UDP获取资源。基本格式：rtsp://<\n              user>:<password>@<host>:<port>/<path>\nfile          表示一台指定主机(本地磁盘、网络文件系统、或其他一些文件共享系统)上可以直接访问的文件。\n              基本格式：file://<host>/<path>\nnews          RFC 1036定义，用来访问一些特定的文章或者新闻组。news\n              URL包含的信息不足以对资源进行定位，需要解释程序。基本格式：news:<newsgroup>``news:<new-a\n              rticle-id>\ntelnet        用于访问交互式业务。表示的是可通过telnet协议访问的交互式应用程序（资源）。基本格式：telnet://<user>\n              :<password>@<host>:<port>/\n\n\nHTTP事务#\n\n一个HTTP事务由一条（从客户端发往服务器的）请求命令和一个（从服务器发回客户端的）响应结果组成。这种通信是通过名为HTTP报文（HTTP\nmessage）的格式化数据块进行的。\n\n\nHTTP协议版本#\n\n * HTTP/0.9，1991发布的原型版本，只支持GET方法。响应后就马上关闭连接\n * HTTP/1.0，第一个得到广泛应用的版本，增加了HEAD、POST方法，增加了HTTP Headers和响应状态码\n * HTTP/1.1，当前普遍使用的版本。\n   * 持久连接（Keep-Alive），通道复用\n   * 增加了PUT、DELETE，OPTIONS等方法\n   * 新增断点续传，身份认证，状态管理，缓存等特性\n * HTTP/2.0，数据以二进制分帧进行传输，头信息压缩，支持服务端推送\n * HTTPS，使用SSL加密传输的HTTP安全版本\n\n\nHTTP报文#\n\n\n报文流#\n\nHTTP报文是在HTTP应用程序之间发送的数据块，以文本形式的原信息（meta-information）开头，描述了报文的内容和含义，后面跟着可选的数据部分。\n\nHTTP使用术语流入(inbound)和流出(outbound)来描述事物处理(transaction)的方向。报文流入源端服务器，工作完成后回流用户的Agen\nt代理中。\n\nHTTP报文会像水一样流动，向下游(downstream)流动。所有报文的发送者都在接受者的上游(upstream)。\n\n\n报文的组成部分#\n\nHTTP报文是简单的格式化数据块，由以下三部分组成：\n\n * 起始行(start line)，对报文进行描述\n * 首部(header)，包含属性\n * 主体(body)，可选的，包含数据\n\n起始行和首部由行分隔，每行以一个由回车符(ASII码 13)和换行符(ASII码\n10)组成的行终止序列(CRLF)作为结束。但稳健的应用程序通常也接受单个换行符作为行的终止，因为有些老的或者不完整的HTTP应用程序并不总是即发送回车符，又发\n送换行符。\n\n主体(body)是一个可选的数据块，可以包含文本或者二进制数据。\n\n\nHTTP报文的语法#\n\nHTTP报文可以分为两类，请求报文(request message)和响应报文(response\nmessage)。请求报文向Web服务器请求一个动作。响应报文将请求的结果返回给客户端。\n\n请求报文的格式：\n\n\n\n响应报文的格式：\n\n\n\n各部分具体描述如下：\n\n部分                   描述\n方法method             客户端系统服务器对资源执行的动作，例如：GET、HEAD或者POST\n请求地址request URL      所请求资源的完整URL\n版本version            报文所使用HTTP版本，格式如下：HTTP/<major>.<minor>\n状态码status code       三位数字，描述请求过程发生的情况。第一位用于描述状态的一般类别\n原因短语reason phrase    状态码的可读版本，包含行终止符之前的所有文本\n首部header             可以有0个或者多个首部。是一些系列的名值对。具体参见HTTP首部\n实体的主体部分entity body   主要包含一个由任意数据组成的数据块。并不是所有的报文都包含实体部分\n\n请求报文示例如下：\n\n\n\n响应报文示例：\n\n\n\n\nHTTP方法#\n\n常用HTTP方法见下表：\n\n方法        描述                         是否包含主体\nGET       从服务器获取一份文档                 否\nHEAD      只从服务器获取文档的首部               否\nPOST      向服务器发送需要处理的数据              是\nPUT       将请求主体部分存储在服务器上             是\nTRACE     对可能经过代理服务器传送到服务器上的报文进行追踪   否\nOPTIONS   决定可以在服务器是上执行那些方法           否\nDELETE    从服务器上删除一份文档                否\n\n\nHTTP状态码#\n\n状态码分类如下：\n\n整体范围      已定义范围     分类\n100~199   100~101   信息提示\n200~299   200~206   成功\n300~399   300~305   重定向\n400~499   400~415   客户端错误\n500~599   500~505   服务器错误\n\n\n100~199信息性状态码#\n\nHTTP/1.1引入了信息性状态码，这些状态码相对较新，因其复杂性和感知价值尚存在一些争论，而受到限制。\n\n状态码   原因短语                  含义\n100   Continue              说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后，必须进行响应。\n101   Switching Protocals   说明服务器正在根据客户端的指定，将协议切换成Update首部所列的协议\n\n100 Continue状态码是针对如下情况：客户端在发送一个有实体的主体部分之前，期望查看下服务器是否接受这个实体。\n\n首先，客户端需要发送一个包含了Expect:\n100-continue首部的请求。这是一种优化，客户端只有在避免向服务器发送一个无法处理或使用大实体时，才使用100 Continue。\n\n服务器接受了该请求之后，用100 Continue状态码或者错误码响应。如果在发送100\nContinue状态码之前，就收到了部分（或全部)实体，服务器就不需要发送这个状态码了，而是跳过这个阶段，在读完请求之后，发送一个最终的状态码。\n\n代理接受到包含Expect:\n100-continue首部的请求，若知道下一个服务器兼容HTTP/1.1，或者不知道是否兼容，都应该将Expect首部放在请求中向下转发。如果知道不兼容HTT\nP/1.1，则以417 Expectation Failed响应。\n\n\n200~299成功状态码#\n\n状态码   原因短语                           含义\n200   OK                             请求成功，实体的主体部分包含了所请求的资源\n201   Created                        用于创建服务器对象的请求（如PUT），响应的主体包含了引用了已创建资源的URL，Location首部包含了具体引用\n202   Accepted                       请求已被接受，但服务器还未对其执行任何操作。不能保证服务器会完成这个请求，只表示接受请求时是有效的。应该在body中包含\n                                     请求状态描述，以及预计完成时间（或者一个可以获取此信息的指针）\n203   Non-Authoritative Infomation   实体首部包含的信息不是来自源服务器，而是来自资源的一份副本。如果中间节点上有副本，但无法或者没有对它所发送的资源有关元信\n                                     息（首部）进行验证，就会出现这种情况。不是非用不可的，如果实体首部来自源服务器，相应为200的应用程序可以将其作为一种可\n                                     选项使用\n204   No Content                     相应报文中包含若干首部和状态行，没有body。主要用于在浏览器不转为显示新文档的情况下，对其进行更新（如刷新一个表单）\n205   Reset Content                  用于告知浏览器清除当前前面中的所有HTML表单元素\n206   Partial Content                成功执行了一个部分或者Range请求。可以通过特殊的首部来获取部分或者某个范围内的文档。响应中必须包含Content-R\n                                     ange、Date以及Etag或Content Location首部\n\n\n300~399重定向状态码#\n\n状态码   原因短语                 含义\n300   Moltiple Choice      请求一个实际指向多个资源的URL时返回的状态码，带有一个选项列表，Location首部包含首选URL\n301   Moved Permanently    请求的URL被移除，Location首部包含新URL\n302   Found                临时重定向，Location首部包含临时地址，将来还请求这个URL。HTTP\n                           1.0加入，但是POST有问题，所以HTTP 1.1增加了303，很多浏览器将其当做303处理\n303   See Other            用Location首部的地址来获取资源，主要目的是允许POST请求将客户端定位到某个资源上，会将POST转为GET\n304   Not Modified         结合不同首部不同意义。对于GET请求，表明资源未被修改，响应不包含body部分\n305   Use Proxy            用Location首部返回的代理地址访问资源\n307   Temporary Redirect   与303类似，但是需要跟用户询问是否应该在新URI上发起POST方法，不会转为GET\n\n\n400～499客户端错误状态码#\n\n状态码   原因短语                            含义\n400   Bad Request                     客户端发送了一个错误的请求\n401   Unauthorized                    无访问权限，需要进行验证\n402   Payment Required                保留状态码，供未来使用\n403   Forbidden                       请求被服务器拒绝，用于服务器不想说明拒绝原因\n404   Not Found                       服务器无法找到所请求的URL，通常会包含一个404页面供浏览器展示给用户看\n405   Mothod Not Allowed              请求方法对于的URL不支持。在响应body中包含Allow首部，告知可以使用那些方法\n406   Not Acceptable                  客户端可以指定参数用以说明可接受的实体类型。表明服务器没有对应资源。一般服务器会包含一些首部，告知客户端原因\n407   Proxy Authentication Required   与401类似，用于对资源进行验证的代理服务器\n408   Request Timeout                 完成客户端的请求耗时过长时，发送此状态码，并关闭连接\n\n\nHTTP首部#\n\nHTTP首部字段向请求报文和响应报文中添加了一些附加消息。HTTP首部是一系列的名/值对列表。可分为以下几类：\n\n * 通用首部，既可以出现在请求报文里，也可以出现在响应报文里\n * 请求首部，提供更多关于请求的信息\n * 响应首部，提供更多关于响应的信息\n * 实体首部，描述实体的长度和内容、或者资源自身\n * 扩展首部，规范中没有定义的首部\n\n将长的首部行分为多行可以提高可读性，被称之为首部延续行，多出来的每行前面至少要有一个空格或者制表符（Tab）\n\n\nGET与POST的区别#\n\n\n浏览器的GET和POST#\n\n特指浏览器中非Ajax的HTTP请求，浏览器GET用于读取一个资源，POST用于提交一个表单。GET请求是没有副作用的，是幂等的，而POST请求用副作用，是不幂\n等的，但是接口中POST是可以幂等的。\n\n因为GET是读取，可以对GET请求的数据做缓存。可以做缓存浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），或者做到server端（用Et\nag，至少可以减少带宽消耗）。而POST不能缓存，也不能保存为书签。如果尝试重新执行POST请求，浏览器会弹一个框提示下刷新可能会有副作用，询问要不要继续。\n\nGET和POST携带数据的格式也有区别，GET请求的数据附在URL上而POST请求的数据在body里。并不是GET只能用URL，而是浏览器直接发出的GET只能由\n一个URL触发。所以GET请求参数只能在URL上附带query string，但HTTP协议本身并没有这个限制。\n\n浏览器的POST请求都来自表单提交，表单的数据被浏览器用编码到HTTP请求的body里。主要有有两种格式，一种是application/x-www-form-u\nrlencoded，用来传输类似key1=value1&key2=value2这样的简单数据；另外一种是multipart/form-data，用来传输文件。因\n为application/x-www-form-urlencoded对于文件这种二进制的数据非常低效。\n\n\n接口中的GET和POST#\n\n指通过浏览器的Ajax，或者iOS/Android等的HTTP\nClient发出的GET和POST请求。此时GET/POST不光能用在前端和后端的交互中，还能用在后端各个子服务的调用中（即当一种RPC协议使用）。\n\n从HTTP协议本身看，并没有什么限制GET一定不能没有body，POST一定不能把参书放到URL的查询参数（query\nstring）上。为了统一风格，形成了一系列的接口规范/风格，例如REST、GraphQL等。REST推荐在body中使用application/json格式，\n与x-www-form-urlencoded相比，具有可嵌套和数据类型更丰富的优势。\n\n\n关于安全性#\n\n\nWeb的结构组件#\n\n * 代理，位于客户端和服务器之间的HTTP中间实体\n * 缓存，HTTP的仓库，使常用页面的副本可以保存在离客户端更近的地方\n * 网关，连接其他应用程序的特殊Web服务器\n * 隧道，对HTTP通信报文进行盲转发的特殊代理\n * Agent代理，发起自动HTTP请求的半智能Web客户端\n\n\nHTTP/2 与 HTTP/3#\n\n\nHTTP/2#\n\nHTTP/2旨在解决HTTP/1.1的性能问题，没有改变HTTP的语义（方法、状态码等），改变了数据传输的格式和方式。\n\n主要特点与改进：\n\n * 二进制分帧： 不再使用纯文本，而是将传输的数据分割为更小的二进制帧。这使得解析更快、更高效，错误更少。\n * 多路复用：\n   这是最核心的特性。在一个TCP连接上，可以同时交错地发送多个请求和响应帧。请求A和请求B的帧可以混杂在一起传输，服务器也能将其正确组装。这彻底解决了\n   HTTP 层面的队头阻塞，使得单个连接就能实现高效并行。\n * 头部压缩： 使用HPACK算法对HTTP头部进行压缩，大幅减少了冗余头部数据的传输。\n * 服务器推送： 服务器可以预测客户端的需要，在客户端请求一个资源（如HTML）时，主动将其他关联资源（如CSS、JS）推送给客户端，减少请求往返\n\n\nHTTP/3#\n\nHTTP/3是下一代协议，它通过彻底更换底层传输协议来解决HTTP/2遗留的TCP队头阻塞问题。\n\n主要特点与革命：\n\n * 基于QUIC协议： 这是最根本的改变。QUIC不再使用TCP，而是基于UDP协议，并在其上实现了可靠传输。\n * 解决TCP队头阻塞：\n   QUIC在协议层面原生实现了多路复用。每个数据流都是独立的，单个数据流的丢包只会影响该流本身，其他流完全不受影响。这彻底解决了TCP队头阻塞问题，使得单个\n   连接能并行处理多个请求。\n * 极快的连接建立：\n   QUIC将加密和连接建立合二为一。对于访问过的服务器，它可以实现0-RTT的握手，意味着在第一次发送数据时就可以携带应用数据，极大降低延迟。\n * 连接迁移： 当你的网络在 Wi-Fi 和 5G\n   之间切换导致IP地址变化时，TCP连接会中断。而QUIC使用连接ID来标识连接，网络切换时只要ID不变，连接就能无缝保持。\n * 内建加密： 加密（TLS 1.3）是QUIC协议不可分割的一部分，所有HTTP/3流量都是加密的。","routePath":"/network/http","lang":"","toc":[{"text":"URI与URL","id":"uri与url","depth":2,"charIndex":3},{"text":"URL语法","id":"url语法","depth":3,"charIndex":585},{"text":"相对URL","id":"相对url","depth":3,"charIndex":1630},{"text":"URL字符集","id":"url字符集","depth":3,"charIndex":1746},{"text":"`URL`方案","id":"url方案","depth":3,"charIndex":-1},{"text":"HTTP事务","id":"http事务","depth":2,"charIndex":3349},{"text":"HTTP协议版本","id":"http协议版本","depth":2,"charIndex":3450},{"text":"HTTP报文","id":"http报文","depth":2,"charIndex":3744},{"text":"报文流","id":"报文流","depth":3,"charIndex":3754},{"text":"报文的组成部分","id":"报文的组成部分","depth":3,"charIndex":3991},{"text":"HTTP报文的语法","id":"http报文的语法","depth":3,"charIndex":4261},{"text":"HTTP方法","id":"http方法","depth":2,"charIndex":4808},{"text":"HTTP状态码","id":"http状态码","depth":2,"charIndex":5150},{"text":"100~199信息性状态码","id":"100199信息性状态码","depth":3,"charIndex":5319},{"text":"200~299成功状态码","id":"200299成功状态码","depth":3,"charIndex":5969},{"text":"300~399重定向状态码","id":"300399重定向状态码","depth":3,"charIndex":6915},{"text":"400～499客户端错误状态码","id":"400499客户端错误状态码","depth":3,"charIndex":7508},{"text":"HTTP首部","id":"http首部","depth":2,"charIndex":8159},{"text":"GET与POST的区别","id":"get与post的区别","depth":2,"charIndex":8400},{"text":"浏览器的GET和POST","id":"浏览器的get和post","depth":3,"charIndex":8415},{"text":"接口中的GET和POST","id":"接口中的get和post","depth":3,"charIndex":9048},{"text":"关于安全性","id":"关于安全性","depth":3,"charIndex":9357},{"text":"Web的结构组件","id":"web的结构组件","depth":2,"charIndex":9366},{"text":"HTTP/2 与 HTTP/3","id":"http2-与-http3","depth":2,"charIndex":9525},{"text":"HTTP/2","id":"http2","depth":3,"charIndex":9544},{"text":"HTTP/3","id":"http3","depth":3,"charIndex":9921}],"domain":"","frontmatter":{},"version":""},{"id":38,"title":"Node内存管理和垃圾回收","content":"#\n\n> 参考文章Node-内存管理和垃圾回收\n\n\n垃圾回收#\n\n由于Node是基于V8构建的，而V8对于内存的使用有一定的限制。在默认情况下64位的机器大概可以使用1.4G，而32位则为0.7G。\n\n限制内存大小的原因有两个方面：\n\n * V8一开始用于浏览器， 这样的内存大小绰绰有余\n * 垃圾回收机制。垃圾回收会暂停JS的运行，内存过大会导致垃圾回收的时间变长，从而导致JS暂停的时间过长\n\n在启动Node服务时，可以手动设置内存的大小：\n\n\n\n在Node环境中，可以通过process.memoryUsage()来查看内存分配：\n\n\n\n对于大文件的操作通常会使用Buffer，主要是因为Node中可以使用内存小，而Buffer是堆外内存即external\n\n\nV8的内存分代#\n\nV8的内部采用两种垃圾回收算法，分别针对生存周期较短和生存周期较长的两种对象。\n\n\n新生代#\n\n主要存放生存周期较短的对象，具有From和To两个空间semispace。在分配内存的时候将内存分配给From空间，\n当垃圾回收的时候，检查From空间存活的对象(广度优先算法)并复制到To空间，然后清空From空间，再互相交换From和To空间的位置，使To空间变为From空\n间。\n\n该算法缺陷是有一半的空间一直闲置着并且需要复制对象，但新生代本身具有的内存比较小并且其分配的对象都是生存周期比较短的对象，所以浪费的空间以及复制使用的开销会比较\n小。\n\n在64位系统中一个semisapce为16MB，32位为8MB，所以新生代内存大小分别为32MB和16MB。\n\n\n老生代#\n\n主要存放生存周期比较长的对象。内存按照1MB分页，并且都按照1MB对齐。新生代的内存是连续的，而老生代的内存是分散的，以链表的形式串联起来。\n\n老生代的内部有4种类型：\n\n\nOld Space#\n\nOld Space保存的是老生代里的普通对象（在V8中指的是Old Object Space，与保存对象结构的Map Space和保存编译出的代码的Code\nSpace相对），这些对象大部分是从新生代（即New Space）晋升而来。\n\n\nLarge Object Space#\n\n当V8需要分配一个1MB的页（减去header）无法直接容纳的对象时，就会直接在Large Object Space而不是New\nSpace分配。在垃圾回收时，Large Object Space里的对象不会被移动或者复制（因为成本太高）。Large Object\nSpace属于老生代，使用 Mark-Sweep-Compact回收内存。\n\n\nMap Space#\n\n所有在堆上分配的对象都带有指向它的“隐藏类”的指针，这些“隐藏类”是V8根据运行时的状态记录下的对象布局结构，用于快速访问对象成员，而这些“隐藏类”（Map）就\n保存在Map Space。\n\n\nCode Space#\n\n编译器针对运行平台架构编译出的机器码（存储在可执行内存中）本身也是数据，连同一些其它的元数据（比如由哪个编译器编译，源代码的位置等），放置在Code\nSpace中。\n\n\nV8的垃圾回收机制#\n\n\n新生代#\n\n新生代采用Scavenge垃圾回收算法，在算法实现时主要采用Cheney算法。新生代的对象晋升到老生代，主要有两个判断条件：\n\n在默认情况下，V8的对象分配主要集中在From空间中。对象从From空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回\n收。如果已经经历过了，会将该对象从From空间复制到老生代空间中，如果没有，则复制到To空间中。\n\n另一个判断条件是To空间的内存占用比。当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代空间中。\n\n写屏障write barrier\n\n关于新生代扫描的问题，由于我们想回收的是新生代的对象，只需检查指向新生代的引用。在跟随根对象->新生代或者新生代->新生代的引用时，那么扫描会很快。但出现了老生\n代指向新生代或者指向根对象时，如果选择跟随，扫描整个堆，就会花费太多时间。 对于这个问题，V8选择的解决方案是使用write\nbarrier，即每次往一个对象写入一个指针（添加引用）的时候，都执行一段代码，这段代码会检查这个被写入的指针是否是由老生代对象指向新生代对象的，这样我们就能明\n确地记录下所有从老生代指向新生代的指针了。这个用于记录的数据结构叫做store\nbuffer，每个堆维护一个，为了防止它无限增长下去，会定期地进行清理、去重和更新。这样，我们可以通过扫描，得知根对象->新生代和新生代->新生代的引用，通过检\n查 store buffer，得知老生代->新生代的引用，就没有漏网之鱼，可以安心地对新生代进行回收了。\n\n\n老生代#\n\n老生代在64位和32位下具有的内存分别是1400MB和700MB，其垃圾回收策略为Mark-Sweep和Mark-Compact相结合。\n\n标记清除Mark-Sweep\n\n标记清除分为标记和清除两个阶段。在标记阶段需要遍历堆中的所有对象，并标记那些活着的对象，然后进入清除阶段。在清除阶段，只清除没有被标记的对象。由于标记清除只清除\n死亡对象，而死亡对象在老生代中占用的比例很小，所以效率较高\n\n在进行一次标记清楚后，内存空间往往是不连续的，会出现很多的内存碎片。后续需要分配一个需要内存空间较多的对象时，如果所有的内存碎片都不够用，将会使得V8无法完成这\n次分配，提前触发垃圾回收。\n\n标记整理Mark-Compact\n\n标记整理是为了解决标记清除所带来的内存碎片的问题。标记整理在标记清除的基础进行修改，将其的清除阶段变为紧缩极端。在整理的过程中，将活着的对象向内存区的一端移动，\n移动完成后直接清理掉边界外的内存。紧缩过程涉及对象的移动，所以效率并不是太好，但是能保证不会生成内存碎片\n\n如果将对中的对象看做由指针做边的有向图，标记算法的核心就是深度优先搜索。\n\nV8使用每个对象的两个mark-bits和一个标记工作栈来实现标记，两个mark-bits编码三种颜色：白色（00），灰色（10）和黑色（11）。\n\n * 白色： 表示对象可以回收\n * 黑色： 表示对象不可以回收，并且他的所有引用都被标记完毕了\n * 灰色： 表示对象不可回收，他的引用对象没有扫描完毕。\n\n当老生代GC启动时，V8会扫描老生代的对象，并对其进行标记。大致的流程如下：\n\n * 将所有非根对象标记为白色。\n * 将根的所有直接引用对象入栈，并标记为灰色（marking worklist）\n * 从这些对象开始做深度优先搜索，每访问一个对象，就将它pop出来，标记为黑色，然后将它引用的所有白色对象标记为灰色，push到栈上\n * 栈空的时候，回收白色的对象\n\n当对象太大无法push进空间有限的栈的时候，V8会先把这个对象保留灰色放弃掉，然后将整个栈标记为溢出状态（overflowed）。在溢出状态下，V8会继续从栈上\npop对象，标记为黑色，再将引用的白色对象标记为灰色和溢出，但不会将这些灰色的对象push到栈上去。这样没多久，栈上的所有对象都被标黑清空了。此时V8开始遍历整\n个堆，把那些同时标记为灰色和溢出对象按照老方法标记完。由于溢出后需要额外扫描一遍堆（如果发生多次溢出还可能扫描多遍），当程序创建了太多大对象的时候，就会显著影响\nGC的效率。\n\n事实上，V8为了降低全堆垃圾回收带来的停顿时间，使用了增量标记和惰性清理两种方式。\n\n增量标记\n\n增量标记(incremental\nmarking)是指将原本要一口气停顿完成的动作拆分为许多小“步进”，每做完一“步进”就让JavaScript应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行直\n到标记阶段完成。\n\n因为增量标记的过程中，很有可能被标记为白色的对象又被重新引用，所以需要一个写屏障（write-barrier）来实现通知。\n\n惰性清理\n\n所有的对象已被处理，因此非死即活，堆上多少空间可以变为空闲已经成为定局。此时我们可以不急着释放那些空间，而将清理的过程延迟一下也并无大碍。因此无需一次清理所有的\n页，垃圾回收器会视需要逐一进行清理，直到所有的页都清理完毕。\n\n\nOrinoco#\n\nV8将新一代的GC称为Orinoco，在Orinoco下，GC的算法更加高效。\n\nOrinoco新生代\n\n在Orinoco新生代中，增加了几个Worker线程处理内存\n\nOrinoco老生代\n\n并行标记parallel marking是标记由主线程和工作线程进行，程序会阻塞。\n\nmarking worklist负责决定分给其他worker thread的工作量，决定了性能与保持本地线程的均衡\n\n并发标记concurrent marking是由工作线程进行标记，主线程继续运行，程序不会阻塞\n\n并发标记允许标记行为与应用程序同时进行，很可能发生数据竞争，V8利用一个bailout worklist来处理被独占的整个对象，并由主线程处理\n\n基于并行标记和并发标记，V8的垃圾回收机制步骤如下：\n\n * 从root对象开始扫描，填充对象到marking worklist\n * 分布并发标记任务到worker threads\n * worker threads通过合作耗尽marking worklist来帮助main threads更快地完成标记\n * 有时候main threads也会通过处理bailout worklist和marking worklist参与标记\n * 如果marking worklist为空，则主线程完成垃圾回收\n * 在结束之前，main thread重新扫描roots，可能会发现其他的白色节点，这些白色节点会在worker threads的帮助下，被平行标记\n\n\n准确式GC#\n\n虽然ECMAScript中没有规定整数类型，Number都是IEEE浮点数，但是由于在CPU上浮点数相关的操作通常比整型操作要慢，大多数的JavaScript引\n擎都在底层实现中引入了整型，用于提升for循环和数组索引等场景的性能，并配以一定的技巧来将指针和整数（可能还有浮点数）“压缩”到同一种数据结构中节省空间。\n\n在V8中，对象都按照4字节（32位机器）或者8字节（64位机器）对齐，因此对象的地址都能被4或者8整除，这意味着地址的二进制表示最后2位或者3位都会是0，也就是\n说所有指针的这几位是可以空出来使用的。如果将另一种类型的数据的最后一位也保留出来另作他用，就可以通过判断最后一位是\n0还是1，来直接分辨两种类型。那么，这另一种类型的数据就可以直接塞在前面几位，而不需要沿着一个指针去读取它的实际内容。在V8的语境内这种结构叫做小整数（SMI,\nsmall integer），这是语言实现中历史悠久的常用技巧tagging的一种。V8\n预留所有的字（word，32位机器是4字节，64位机器是8字节）的最后一位用于标记（tag）这个字中的内容的类型，1表示指针，0表示整数，这样给定一个内存中的字\n，它能通过查看最后一位快速地判断它包含的指针还是整数，并且可以将整数直接存储在字中，无需先通过一个指针间接引用过来，节省空间。\n\n由于V8能够通过查看字的最后一位，快速地分辨指针和整数，在GC的时候，V8能够跳过所有的整数，更快地沿着指针扫描堆中的对象。由于在GC的过程中，V8能够准确地分\n辨它所遍历到的每一块内存的内容属于什么类型，因此V8的垃圾回收器是准确式的。与此相对的是保守式GC，即垃圾回收器因为某些设计导致无法确定内存中内容的类型，只能保\n守地先假设它们都是指针然后再加以验证，以免误回收不该回收的内存，因此可能误将数据当作指针，进而误以为一些对象仍然被引用，无法回收而浪费内存。同时因为保守式的垃圾\n回收器没有十足的把握区分指针和数据，也就不能确保自己能安全地修改指针，无法使用那些需要移动对象，更新指针的算法。","routePath":"/node/garbage-collection","lang":"","toc":[{"text":"垃圾回收","id":"垃圾回收","depth":2,"charIndex":25},{"text":"V8的内存分代","id":"v8的内存分代","depth":2,"charIndex":334},{"text":"新生代","id":"新生代","depth":3,"charIndex":386},{"text":"老生代","id":"老生代","depth":3,"charIndex":678},{"text":"Old Space","id":"old-space","depth":3,"charIndex":771},{"text":"Large Object Space","id":"large-object-space","depth":3,"charIndex":903},{"text":"Map Space","id":"map-space","depth":3,"charIndex":1097},{"text":"Code Space","id":"code-space","depth":3,"charIndex":1206},{"text":"V8的垃圾回收机制","id":"v8的垃圾回收机制","depth":2,"charIndex":1304},{"text":"新生代","id":"新生代-1","depth":3,"charIndex":1317},{"text":"老生代","id":"老生代-1","depth":3,"charIndex":2014},{"text":"Orinoco","id":"orinoco","depth":3,"charIndex":3436},{"text":"准确式GC","id":"准确式gc","depth":2,"charIndex":4096}],"domain":"","frontmatter":{},"version":""},{"id":39,"title":"WebGL","content":"#\n\nWebGL使用的是右手坐标系。\n\n\n着色器（Shader）#\n\n * 顶点着色器Vertex Shader: 用于描述顶点特性的程序，例如位置、颜色、纹理坐标等。顶点是指场景中的每一个点\n * 片段着色器Fragment Shader: 进行逐片元处理过程的程序，如光照。片元是指屏幕上的每一个像素\n\n\n变量#\n\n * attribute变量，用于传递顶点相关的数据，例如位置、颜色等\n * uniform变量，用于传输所有顶点都相同的数据，例如相机位置、光源位置等\n * varying 变化变量，在顶点着色器中计算，在片元着色器中插值，用于实现平滑的效果，例如颜色、纹理坐标等\n\ngl.drawArrays用于绘制场景中的对象。其中第一个参数mode支持7种基本图形类型：\n\n * gl.POINTS：绘制点\n * gl.LINES：绘制线\n * gl.LINE_STRIP：绘制折线\n * gl.LINE_LOOP：绘制闭合折线\n * gl.TRIANGLES：绘制三角形\n * gl.TRIANGLE_STRIP：绘制三角形带\n * gl.TRIANGLE_FAN：绘制三角形扇","routePath":"/webgl/","lang":"","toc":[{"text":"着色器（Shader）","id":"着色器shader","depth":2,"charIndex":20},{"text":"变量","id":"变量","depth":3,"charIndex":154}],"domain":"","frontmatter":{},"version":""},{"id":40,"title":"Three.js","content":"#\n\n\n三要素#\n\n\n场景（Scene）#\n\n场景是Three.js中用于组织和管理 3D\n对象的容器。每个场景都可以包含多个对象，例如模型、几何体、材质等。场景可以用于组织和管理场景中的对象，例如添加、删除、遍历等操作。\n\n\n相机（Camera）#\n\n相机是 Three.js 中用于定义场景中可见区域的对象。相机可以是透视相机或正交相机，用于模拟人眼或相机的视角。相机的位置和方向决定了场景中可见的区域。\n\n\n渲染器（Renderer）#\n\n渲染器是 Three.js 中用于将场景渲染到屏幕上的对象。渲染器可以是 WebGL 渲染器或 Canvas\n渲染器，用于在浏览器中显示场景。渲染器的配置参数可以用于调整渲染效果，例如抗锯齿、阴影等。\n\n\n对象（Object）#\n\n对象是 Three.js 中用于表示 3D\n模型、几何体、材质等的对象。对象可以是静态的，也可以是动态的，例如动画模型、交互对象等。对象的属性和方法可以用于操作和管理对象，例如位置、旋转、缩放、材质等。","routePath":"/webgl/three","lang":"","toc":[{"text":"三要素","id":"三要素","depth":2,"charIndex":3},{"text":"场景（Scene）","id":"场景scene","depth":3,"charIndex":10},{"text":"相机（Camera）","id":"相机camera","depth":3,"charIndex":113},{"text":"渲染器（Renderer）","id":"渲染器renderer","depth":3,"charIndex":206},{"text":"对象（Object）","id":"对象object","depth":3,"charIndex":325}],"domain":"","frontmatter":{},"version":""}]