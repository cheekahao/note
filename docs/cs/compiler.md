# 编译原理

>《编译系统透视：图解编译原理》读书笔记

## C程序的运行式结构

C程序运行的核心是函数的执行和调用，它构成了整个C程序运行时结构的基础框架。这一运行过程主要是在程序指令的驱动以及数据压栈、清栈的支持下实现的。

以下面的程序为例：

```c
int fun(int a, int b);
int m = 10;
int main() {
    int i = 4;
    int j = 5;
    m = fun(i, j);
    return 0;
}
int fun(int a,int b) {
    int c=0;
    c=a+b;
    return c;
}
```

### 程序加载时的内存概况

运行时，在内存中，共有代码区、静态数据区和动态数据区三个区域。

![内存区域](//img.haozhenjia.com/blog/code_memory.jpg)

其中，**代码区**装载了程序所对应的机器指令；全局变量`m`的数值装载在**静态数据区**中；**动态数据区**加载程序运行过程中产生的数据。

程序执行的本质就是代码区的指令不断执行，驱使动态数据区和静态数据区产生数据变化。

`CPU`中有三个寄存器，分别是`eip`、`ebp`和`esp`。

`eip`永远指向代码区将要执行的下一条指令，它的管控方式有两种，一种是“顺序执行”，即程序执行完一条指令后自动指向下一条执行；另一种是跳转，也就是执行完一条跳转指令后跳转到指定的位置。

`ebp`和`esp`用来管控栈空间，`ebp`指向栈底，`esp`指向栈顶。在代码区中，函数调用、返回和执行伴随着不断压栈和清栈，栈中数据存储和释放的原则是后进先出。

`eip`指向`main`函数的第一条指令，此时程序还没有运行，栈空间里还没有数据，ebp和esp指向的位置是程序加载时内核设置的。

### 程序运行过程中的内存变化

程序开始执行`main`函数第一条指令(`call`指令)，`eip`自动指向下一条指令。第一条指令的执行，致使`ebp`的地址值被保存在栈中，保存的目的是本程序执行完毕后，`ebp`还能返回现在的位置，复原现在的栈。

随着`ebp`地址值的压栈，`esp`自动向栈顶方向移动，它将永远指向栈顶。

接下来，开始构建`main`函数自己的栈，`ebp`原来指向的地址值已经被保存了，此时和`esp`是重叠的，用来看管main函数的栈底。



## 汇编中的寄存器

`eax`, `ebx`, `ecx`, `edx`, `esi`, `edi`, `ebp`, `esp`等都是`X86`汇编语言中`CPU`上的通用寄存器的名称，是32位的寄存器。

如果用C语言来解释，可以把这些寄存器当作变量看待。

| 汇编名称     | 寄存器类型             | 作用  |
| ------------ | --- | - | 
| `EAX` |累加寄存器`accumulator register`| 加法乘法指令的缺省寄存器 |
| `EBX` |基址寄存器`base register`| 内存寻址时存放基地址 |
| `ECX` |程序计数器`program counter`| 重复`REP`前缀指令和`LOOP`指令的内定计数器 |
| `EDX` | | 用来存放整数除法产生的余数 |
| `ESI` | 源索引寄存器`source index`| 在很多字符串操作指令中, `DS:ESI`指向源串 |
| `EDI` | 目标索引寄存器`destination index`| 在很多字符串操作指令中, `ES:EDI`指向目标串 |
| `EBP` | 基址指针`base pointer`| 常被用作高级语言函数调用的**框架指针`frame pointer`**，存放当前线程的栈底指针|
| `ESP` | 堆栈指针 | 存放当前线程的栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。|
| `EIP` | 指令寄存器`instrution register` | 存放下一个`CPU`指令存放的内存地址 |

因此，在函数的起始部分经常有：

```
push ebp; 保存当前ebp
mov ebp, esp; EBP设为当前堆栈指针
sub esp, xxx; 预留xxx字节给函数临时变量.
```