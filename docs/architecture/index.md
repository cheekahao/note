# 整洁架构

> 《架构整洁之道》读书笔记

## 编程范式

* 结构化编程，结构化编程对程序控制权的直接转移进行了限制和规范。限制goto语句
* 面向对象编程，面向对象编程对程序控制权的间接转移进行了限制和规范。限制函数指针
* 函数式编程，函数式编程对程序中的赋值进行了限制和规范。限制赋值语句的使用

## 软件架构

* 功能性
* 组件独立性
* 数据管理
* 顺序结构
* 分支结构
* 循环结构

### 面向对象

* 封装
* 继承
* 多态

## 设计原则

`SOLID`原则

* SRP: 单一职责原则。每个软件模块有且只有一个需要被改变的理由
* OCP: 开闭原则。如果软件系统想要更容易被改变，其设计必须允许新增代码来修改系统行为，而非只能靠修改原来的代码
* LSP: 里氏替换原则。软件系统的组件要遵守同一个约定，以便让这些组件可以相互替换
* ISP: 接口隔离原则。在设计中避免不必要的依赖
* DIP: 依赖反转原则。高层策略性代码不应该依赖实现底层细节的代码，实现底层细节的代码应该依赖高层策略性代码
* LKP: 最少知识原则。一个软件实体应当尽可能少地与其他实体发生相互作用

## 架构关注点

架构是系统设计的一部分，它突出了某些细节，并通过抽象省略掉另一些细节。

架构关注的是组件之间的关系和系统组件外部可见的属性，设计还要关注这些组件的内部结构。

### 架构关注点

* 品质关注点，例如稳定性，技术栈等

## 组件构建基本原则

* REP：复用/发布等同原则。软件复用的最小粒度应等同于其发布的最小粒度
* CCP：共同闭包原则。将会同时修改，且为了相同目的而修改的代码放到同一个组件中。反之亦然。
* CRP：共同复用原则。不应强迫一个组件的用户依赖他们不需要的东西。

## 组件之间的关系

* 无依赖环原则，组件依赖关系图中不应该出现环。
* 稳定依赖原则，依赖关系必须要指向更稳定的方向。
* 稳定抽象原则，一个组件的抽象化程度应该与其稳定性保持一致。

## 什么是软件架构

**设计软件架构的目的**是为了在工作中更好地对这些组件进行研发、部署、运行以及维护。

**软件架构设计**的主要目标是支撑软件系统的全生命周期，设计良好的架构可以让系统便于理解、易于修改、方便维护，并且能轻松部署。软件架构的终极目标就是**最大化程序员的生产力**，同时最小化系统的总运营成本。

对于一个只有五个开发人员的小团队来说，他们完全可以非常高效地共同开发一个没有明确定义组件和接口的单体系统（monolithic system）。

设计良好的系统架构应该可以使开发人员对系统的运行过程一目了然。

所有的软件系统都可以降解为**策略**与**细节**这两种主要元素。**策略体现的是软件中所有的业务规则与操作过程**。

软件架构师的目标是创建一种系统形态，该形态会以策略为最基本的元素，并让细节与策略脱离关系，以允许在具体决策过程中推迟或延迟与细节相关的内容。

软件架构设计本身就是一门划分边界的艺术。边界的作用是将软件分割成各种元素，以便约束边界两侧之间的依赖关系。

本质上，所有的软件系统都是一组策略语句的集合。

软件架构设计的工作重点之一就是，将这些策略彼此分离，然后将它们按照变更的方式软件架构设计的工作重点之一就是，将这些策略彼此分离，然后将它们按照变更的方式进行重新分组。其中变更原因、时间和层次相同的策略应该被分到同一个组件中。反之，变更原因、时间和层次不同的策略则应该分属于不同的组件。

我们对“层次”是严格按照“输入与输出之间的距离”来定义的。一条策略距离系统的输入/输出越远，它所属的层次就越高。而直接管理输入/输出的策略在系统中的层次是最低的。

我们希望源码中的依赖关系与其数据流向脱钩，而与组件所在的层次挂钩。

离输入/输出最远的策略——高层策略——一般变更没有那么频繁。即使发生变更，其原因也比低层策略所在的组件更重大。反之，低层策略则很有可能会频繁地进行一些小变更。

## 划分边界

软件架构设计是一门划分边界的艺术。边界的作用是将软件分割成各种元素，以便约束边界两侧之间的依赖关系。

一个系统的架构是由一系列软件组件以及它们之间的边界共同定义的。在运行时，跨边界调用指的是边界线一侧的函数调用另一侧的函数，并同时传递数据的行为。构造合理的跨边界调用需要我们对源码中的依赖关系进行合理管控。

SRP的作用就是告诉我们应该在哪里画边界线。

这也是依赖反转原则(DIP)和稳定抽象原则(SAP)的具体应用，依赖箭头应该由底层具体实现细节指向高层抽象的方向。

## 策略与层次

本质上，所有的软件系统都是一组策略语句的集合。软件架构设计的工作重点之一就是，将这些策略彼此分离，然后将它们按照变更的方式进行重新分组。其中变更原因、时间和层次相同的策略应该被分到同一个组件中。

架构设计的工作常常需要将组件重排组合成为一个有向无环图。

## 业务逻辑

如果我们要将自己的应用程序划分为业务逻辑和插件两部分，就必须更仔细地了解业务逻辑究竟是什么，它到底有几种类型。

业务逻辑就是程序中那些真正用于赚钱或省钱的业务逻辑与过程。更严格地讲，无论这些业务逻辑是在计算机上实现的，还是人工执行的，它们在省钱/赚钱上的作用都是一样的。

“关键业务逻辑”通常会需要处理一些数据，我们将这些数据称为“关键业务数据”，关键业务逻辑和关键业务数据是紧密相关的，所以它们很适合被放在同一个对象中处理。我们将这种对象称为“业务实体（Entity）”。

## 架构设计的主题

架构设计不是（或者说不应该是）与框架相关的，框架只是一个可用的工具和手段。

软件的系统架构应该为该系统的用例提供支持。

六边形架构(Hexagonal Architecture)（也称为端口与适配器架构，Ports and Adpaters）、DCI架构、 BCE架构等都有一个共同的设计目标：按照不同关注点对软件进行切割。也就是说，这些架构都会将软件切割成不同的层，至少有一层是只包含该软件的业务逻辑的，而用户接口、系统接口则属于其他层。

整洁架构的特点：

* 独立于框架：系统的架构并不依赖某个功能丰富的框架之中的某个函数。框架可以被当成工具来使用，但不需要让系统来适应框架。
* 可被测试：系统的业务逻辑可以脱离UI、数据库、Web服务以及其他的外部元素来进行测试。
* 独立于UI：系统的UI变更起来很容易，不需要修改其他的系统部分。例如可以在不修改业务逻辑的前提下将一个系统的UI由Web界面替换成命令行界面。
* 独立于数据库：可以轻易将系统使用的Oracle、SQL Server替换成Mongo、BigTable、CouchDB之类的数据库。因为业务逻辑与数据库之间已经完成了解耦。
* 独立于任何外部机构：系统的业务逻辑并不需要知道任何其他外部接口的存在。

![clean](/images/arch/clean_arch.png)

## 展示器和谦卑对象

展示器是采用谦卑对象(humble object)模式的一种形式，可以很好地帮助识别和保护系统架构的边界。

谦卑对象模式最初的设计目的是帮助单元测试的编写者区分容易测试的行为与难以测试的行为，并将它们隔离。其设计思路非常简单，就是将这两类行为拆分成两组模块或类。其中一组模块被称为谦卑(Humble)组，包含了系统中所有难以测试的行为，这些行为已经被简化到不能再简化了。另一组模块则包含了所有不属于谦卑对象的行为。

强大的可测试性是一个架构的设计是否优秀的显著衡量标准之一。谦卑对象模式就是这方面的一个非常好的例子。

### 展示器与视图

视图部分属于难以测试的谦卑对象。视图部分属于难以测试的谦卑对象。

展示器的工作是负责从应用程序中接收数据，然后按视图的需要将这些数据格式化，以便视图将其呈现在屏幕上。

### 数据库网关

数据库网关是指用例交互器`Interactor`与数据库中间的组件。是一个多态接口，包含了应用程序在数据库上所要执行的创建、读取、更新、删除等所有操作。数据库网关属于谦卑对象，利用SQL或其他数据库提供的接口来访问所需要的数据。

交互器不属于谦卑对象，因为它们封装的是特定应用场景下的业务逻辑。但交互器是可测试的，因为数据库网关通常可以被替换成对应的测试桩和测试替身类。

### 数据映射器

