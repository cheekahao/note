# 设计模式

## 单例模式

**单例模式**，保证一个类仅有一个实例，并提供一个访问他的全局访问点。

## 策略模式

定义一些列的算法，把它们一个个的封装起来，并且使他们可以相互替换。

## 代理模式

**代理模式**是为一个对象提供一个代用品或者占位符，以便控制对它的访问。

## 迭代器模式

## 发布订阅模式

## 命令模式

命令模式中的命令`command`指的是一个执行某些特定事情的指令。

命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。

相对于过程化的请求调用，`command`对象拥有更长的生命周期。对象的生命周期是跟初始请求无关的，因为这个请求已经被封装在了`command`对象的方法中，成为了这个对象的行为，我们可以在程序运行的任意时刻去调用这个方法。此外，命令模式还支持撤销、排队等操作。

命令模式的由来，其实是回调`callback`函数的一个面向对象的替代品。

```js
const setCommand = (button, command) => {
    button.onClick = () => command.execute()
}

const MenuBar = {
    refresh(){
        console.log('刷新菜单')
    },
}

const RefreshMenuCommand = (receiver) => () => ({
    execute(){
        receiver.refresh()
    },
    // 撤销命令
    undo(){

    }
})
const refreshMenuCommand = RefreshMenuCommand(MenuBar)

// 假设html中已经存在id为button1的button
const button1 = document.getElementById('button1')
setCommand(button1, refreshMenuCommand)
```

命令的**撤消**一般是给命令对象增加一个名为`unexecude`或者`undo`的方法，执行`execute`的反向操作。

需要撤销一系列的命令时，可以把所有执行过的命令都储存在一个历史列表中，然后倒序循环来依次执行需要撤销的命令的`undo`操作。

对于某些无法顺利地利用`undo`操作让对象回到`execute`之前状态的情况，可以通过先回退初始状态，再把执行过的命令全部重新执行一遍来实现。

## 状态模式

GoF中的定义：**允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类**。

将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。

所使用的对象，在不同的状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。

**状态模式的优点：**

* 状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。
* 避免`Context`无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了`Context`中原本过多的条件分支。
* 用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。
* `Context`中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。

**状态模式的缺点:**

会在系统中定义许多状态类，而且系统中会因此而增加不少对象。另外，由于逻辑分散在状态类中，虽然避开了不受欢迎的条件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑。

**状态模式和策略模式的异同**

**相同点**是都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行。

**区别**是策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系，所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法；而在状态模式中，状态和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情发生在状态模式内部。对客户来说，并不需要了解这些细节。