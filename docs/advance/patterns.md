# 设计模式

设计模式由`GoF`在《设计模式：可复用面向对象软件的基础》一书在中提出。是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。是对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述。

在《设计模式：可复用面向对象软件的基础》一书中提出了23中设计模式，按照模式的目的可以分为以下三类：

* 创建型，用于描述**怎样创建对象**，主要特点是**将对象的创建与使用分离**，包括工厂模式、抽象工厂模式、建造者模式、单例模式和原型模式5种
* 结构型，用于描述如何将类或对象按某种布局组成更大的结构，包括适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式和享元模式
* 行为型，用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。包括策略模式，模板方法模式，发布订阅模式，迭代器模式，职责链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式

## 单例模式Singleton

**单例模式**，保证一个类仅有一个实例，并提供一个访问他的全局访问点。

## 策略模式

定义一系列的算法，把它们一个个的封装起来，并且使他们可以相互替换。

## 代理模式

**代理模式**是为一个对象提供一个代用品或者占位符，以便控制对它的访问。

## 迭代器模式Iterator

提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。

## 观察者模式Observer

用于定义对象间一对多依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

## 命令模式

命令模式是指将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开，并且可以对请求排队或记录日志，并支持可撤销的操作。

其中的命令`command`指的是一个执行某些特定事情的指令。

命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。

相对于过程化的请求调用，`command`对象拥有更长的生命周期。对象的生命周期是跟初始请求无关的，因为这个请求已经被封装在了`command`对象的方法中，成为了这个对象的行为，我们可以在程序运行的任意时刻去调用这个方法。此外，命令模式还支持撤销、排队等操作。

命令模式的由来，其实是回调`callback`函数的一个面向对象的替代品。

```js
const setCommand = (button, command) => {
    button.onClick = () => command.execute()
}

const MenuBar = {
    refresh(){
        console.log('刷新菜单')
    },
}

const RefreshMenuCommand = (receiver) => () => ({
    execute(){
        receiver.refresh()
    },
    // 撤销命令
    undo(){

    }
})
const refreshMenuCommand = RefreshMenuCommand(MenuBar)

// 假设html中已经存在id为button1的button
const button1 = document.getElementById('button1')
setCommand(button1, refreshMenuCommand)
```

命令的**撤消**一般是给命令对象增加一个名为`unexecude`或者`undo`的方法，执行`execute`的反向操作。

需要撤销一系列的命令时，可以把所有执行过的命令都储存在一个历史列表中，然后倒序循环来依次执行需要撤销的命令的`undo`操作。

对于某些无法顺利地利用`undo`操作让对象回到`execute`之前状态的情况，可以通过先回退初始状态，再把执行过的命令全部重新执行一遍来实现。

## 状态模式State

GoF中的定义：**允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类**。

将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。

所使用的对象，在不同的状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。

**状态模式的优点：**

* 状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。
* 避免`Context`无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了`Context`中原本过多的条件分支。
* 用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。
* `Context`中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。

**状态模式的缺点:**

会在系统中定义许多状态类，而且系统中会因此而增加不少对象。另外，由于逻辑分散在状态类中，虽然避开了不受欢迎的条件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑。

**状态模式和策略模式的异同**

**相同点**是都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行。

**区别**是策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系，所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法；而在状态模式中，状态和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情发生在状态模式内部。对客户来说，并不需要了解这些细节。