(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{283:function(t,s,v){"use strict";v.r(s);var _=v(10),a=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"编译原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译原理"}},[t._v("#")]),t._v(" 编译原理")]),t._v(" "),s("blockquote",[s("p",[t._v("《编译系统透视：图解编译原理》读书笔记")])]),t._v(" "),s("h2",{attrs:{id:"c程序的运行式结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c程序的运行式结构"}},[t._v("#")]),t._v(" C程序的运行式结构")]),t._v(" "),s("p",[t._v("C程序运行的核心是函数的执行和调用，它构成了整个C程序运行时结构的基础框架。这一运行过程主要是在程序指令的驱动以及数据压栈、清栈的支持下实现的。")]),t._v(" "),s("p",[t._v("以下面的程序为例：")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fun")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" m "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    m "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fun")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fun")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    c"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br")])]),s("h3",{attrs:{id:"程序加载时的内存概况"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#程序加载时的内存概况"}},[t._v("#")]),t._v(" 程序加载时的内存概况")]),t._v(" "),s("p",[t._v("运行时，在内存中，共有代码区、静态数据区和动态数据区三个区域。")]),t._v(" "),s("p",[s("img",{attrs:{src:"//img.haozhenjia.com/blog/code_memory.jpg",alt:"内存区域"}})]),t._v(" "),s("p",[t._v("其中，"),s("strong",[t._v("代码区")]),t._v("装载了程序所对应的机器指令；全局变量"),s("code",[t._v("m")]),t._v("的数值装载在"),s("strong",[t._v("静态数据区")]),t._v("中；"),s("strong",[t._v("动态数据区")]),t._v("加载程序运行过程中产生的数据。")]),t._v(" "),s("p",[t._v("程序执行的本质就是代码区的指令不断执行，驱使动态数据区和静态数据区产生数据变化。")]),t._v(" "),s("p",[s("code",[t._v("CPU")]),t._v("中有三个寄存器，分别是"),s("code",[t._v("eip")]),t._v("、"),s("code",[t._v("ebp")]),t._v("和"),s("code",[t._v("esp")]),t._v("。")]),t._v(" "),s("p",[s("code",[t._v("eip")]),t._v("永远指向代码区将要执行的下一条指令，它的管控方式有两种，一种是“顺序执行”，即程序执行完一条指令后自动指向下一条执行；另一种是跳转，也就是执行完一条跳转指令后跳转到指定的位置。")]),t._v(" "),s("p",[s("code",[t._v("ebp")]),t._v("和"),s("code",[t._v("esp")]),t._v("用来管控栈空间，"),s("code",[t._v("ebp")]),t._v("指向栈底，"),s("code",[t._v("esp")]),t._v("指向栈顶。在代码区中，函数调用、返回和执行伴随着不断压栈和清栈，栈中数据存储和释放的原则是后进先出。")]),t._v(" "),s("p",[s("code",[t._v("eip")]),t._v("指向"),s("code",[t._v("main")]),t._v("函数的第一条指令，此时程序还没有运行，栈空间里还没有数据，ebp和esp指向的位置是程序加载时内核设置的。")]),t._v(" "),s("h3",{attrs:{id:"程序运行过程中的内存变化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#程序运行过程中的内存变化"}},[t._v("#")]),t._v(" 程序运行过程中的内存变化")]),t._v(" "),s("p",[t._v("程序开始执行"),s("code",[t._v("main")]),t._v("函数第一条指令("),s("code",[t._v("call")]),t._v("指令)，"),s("code",[t._v("eip")]),t._v("自动指向下一条指令。第一条指令的执行，致使"),s("code",[t._v("ebp")]),t._v("的地址值被保存在栈中，保存的目的是本程序执行完毕后，"),s("code",[t._v("ebp")]),t._v("还能返回现在的位置，复原现在的栈。")]),t._v(" "),s("p",[t._v("随着"),s("code",[t._v("ebp")]),t._v("地址值的压栈，"),s("code",[t._v("esp")]),t._v("自动向栈顶方向移动，它将永远指向栈顶。")]),t._v(" "),s("p",[t._v("接下来，开始构建"),s("code",[t._v("main")]),t._v("函数自己的栈，"),s("code",[t._v("ebp")]),t._v("原来指向的地址值已经被保存了，此时和"),s("code",[t._v("esp")]),t._v("是重叠的，用来看管main函数的栈底。")]),t._v(" "),s("h2",{attrs:{id:"汇编中的寄存器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#汇编中的寄存器"}},[t._v("#")]),t._v(" 汇编中的寄存器")]),t._v(" "),s("p",[s("code",[t._v("eax")]),t._v(", "),s("code",[t._v("ebx")]),t._v(", "),s("code",[t._v("ecx")]),t._v(", "),s("code",[t._v("edx")]),t._v(", "),s("code",[t._v("esi")]),t._v(", "),s("code",[t._v("edi")]),t._v(", "),s("code",[t._v("ebp")]),t._v(", "),s("code",[t._v("esp")]),t._v("等都是"),s("code",[t._v("X86")]),t._v("汇编语言中"),s("code",[t._v("CPU")]),t._v("上的通用寄存器的名称，是32位的寄存器。")]),t._v(" "),s("p",[t._v("如果用C语言来解释，可以把这些寄存器当作变量看待。")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("汇编名称")]),t._v(" "),s("th",[t._v("寄存器类型")]),t._v(" "),s("th",[t._v("作用")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[s("code",[t._v("EAX")])]),t._v(" "),s("td",[t._v("累加寄存器"),s("code",[t._v("accumulator register")])]),t._v(" "),s("td",[t._v("加法乘法指令的缺省寄存器")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("EBX")])]),t._v(" "),s("td",[t._v("基址寄存器"),s("code",[t._v("base register")])]),t._v(" "),s("td",[t._v("内存寻址时存放基地址")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("ECX")])]),t._v(" "),s("td",[t._v("程序计数器"),s("code",[t._v("program counter")])]),t._v(" "),s("td",[t._v("重复"),s("code",[t._v("REP")]),t._v("前缀指令和"),s("code",[t._v("LOOP")]),t._v("指令的内定计数器")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("EDX")])]),t._v(" "),s("td"),t._v(" "),s("td",[t._v("用来存放整数除法产生的余数")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("ESI")])]),t._v(" "),s("td",[t._v("源索引寄存器"),s("code",[t._v("source index")])]),t._v(" "),s("td",[t._v("在很多字符串操作指令中, "),s("code",[t._v("DS:ESI")]),t._v("指向源串")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("EDI")])]),t._v(" "),s("td",[t._v("目标索引寄存器"),s("code",[t._v("destination index")])]),t._v(" "),s("td",[t._v("在很多字符串操作指令中, "),s("code",[t._v("ES:EDI")]),t._v("指向目标串")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("EBP")])]),t._v(" "),s("td",[t._v("基址指针"),s("code",[t._v("base pointer")])]),t._v(" "),s("td",[t._v("常被用作高级语言函数调用的"),s("strong",[t._v("框架指针"),s("code",[t._v("frame pointer")])]),t._v("，存放当前线程的栈底指针")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("ESP")])]),t._v(" "),s("td",[t._v("堆栈指针")]),t._v(" "),s("td",[t._v("存放当前线程的栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("EIP")])]),t._v(" "),s("td",[t._v("指令寄存器"),s("code",[t._v("instrution register")])]),t._v(" "),s("td",[t._v("存放下一个"),s("code",[t._v("CPU")]),t._v("指令存放的内存地址")])])])]),t._v(" "),s("p",[t._v("因此，在函数的起始部分经常有：")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("push ebp; 保存当前ebp\nmov ebp, esp; EBP设为当前堆栈指针\nsub esp, xxx; 预留xxx字节给函数临时变量.\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("h2",{attrs:{id:"编译过程概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译过程概述"}},[t._v("#")]),t._v(" 编译过程概述")]),t._v(" "),s("p",[t._v("源程序是给人看的，本质上就是文本文件。需要通过"),s("strong",[t._v("编译器")]),s("code",[t._v("Compiler")]),t._v("将源程序编译为计算机可执行的程序。")]),t._v(" "),s("p",[t._v("编译过程主要分为词法分析、语法分析、中间代码生成、目标代码生成四个过程。")]),t._v(" "),s("h3",{attrs:{id:"词法分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#词法分析"}},[t._v("#")]),t._v(" 词法分析")]),t._v(" "),s("p",[t._v("词法分析的作用是从连续的字符中识别出标识符、关键字、数字、运算符并存储为符号"),s("code",[t._v("token")]),t._v("流。")]),t._v(" "),s("p",[t._v("词法分析器"),s("code",[t._v("Lexer")]),t._v("，也叫扫描器"),s("code",[t._v("Scanner")]),t._v("，重要功能是根据对应语言的语法规则，一个字符一个字符从源程序的字符串中识别出一个个的符号"),s("code",[t._v("token")]),t._v("，并按序保存。")]),t._v(" "),s("p",[t._v("C语言的语法规则是由一个"),s("strong",[t._v("状态转换图")]),t._v("实现的。")]),t._v(" "),s("p",[t._v("在词法分析阶段，词法分析器能够识别出一些符号的含义，包括关键字、数字、字符串、分隔符、运算符等，但是另外一切符号需要通过前后其他符号才能确定准确含义，仅能初步判断是一个标识符，更多详细信息在语法分析阶段完成。")]),t._v(" "),s("h3",{attrs:{id:"语法分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#语法分析"}},[t._v("#")]),t._v(" 语法分析")]),t._v(" "),s("p",[t._v("语法分析的作用是从词法分析识别出的"),s("strong",[t._v("token流")]),t._v("中识别出符合对应语言语法的语句。")]),t._v(" "),s("p",[t._v("语法分析器"),s("code",[t._v("Parser")]),t._v("依据用计算机表示的语法，一个符号一个符号地识别出符合C语言语法的语句。")]),t._v(" "),s("p",[t._v("在语法分析器中把通过产生式产生的对应语言语法映射成一套模板，并把这套模板融汇在语法分析器的程序中。语法分析器的作用就是将词法分析器识别出的符号"),s("code",[t._v("token")]),t._v("一个一个地与这套模板进行匹配，匹配上这套模板中的某个语法，就可以识别出一句完整的语句，并确定这条语句的语法。")]),t._v(" "),s("p",[t._v("语法的计算机表示就是产生式。")]),t._v(" "),s("p",[t._v("语法分析器的最终输出是语法树"),s("code",[t._v("AST")]),t._v("，是一个二维结构。语法树已经承载了源程序的全部信息，后续的转换工作就和源程序没关系了。")]),t._v(" "),s("h3",{attrs:{id:"从语法树到中间代码再到目标代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从语法树到中间代码再到目标代码"}},[t._v("#")]),t._v(" 从语法树到中间代码再到目标代码")]),t._v(" "),s("p",[t._v("鉴于计算机存在着多种"),s("code",[t._v("CPU")]),t._v("硬件平台，考虑到程序在不同"),s("code",[t._v("CPU")]),t._v("之间的可移植性，需要先将语法树转换成一个通用的、抽象的"),s("strong",[t._v("CPU指令")]),t._v("，这就是中间代码最初的设计思想。然后根据具体选定的"),s("code",[t._v("CPU")]),t._v("，将中间代码落实到具体"),s("code",[t._v("CPU")]),t._v("的目标代码。")]),t._v(" "),s("p",[t._v("语法树是个二维结构，中间代码是准一维结构，语法树到中间代码的转换过程，本质上是将二维结构转换为准一维结构的过程。")]),t._v(" "),s("p",[t._v("选定具体的"),s("code",[t._v("CPU")]),t._v("、操作系统后，中间代码就可以转换为目标代码——汇编代码。")])])}),[],!1,null,null,null);s.default=a.exports}}]);